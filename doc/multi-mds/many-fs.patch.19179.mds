Index: zfs/src/zfs-fuse/zfs_dir.c
===================================================================
--- zfs/src/zfs-fuse/zfs_dir.c	(revision 19179)
+++ zfs/src/zfs-fuse/zfs_dir.c	(working copy)
@@ -731,19 +731,11 @@
 
 	value = zfs_dirent(zp);
 
-	/*
-	 * In the new directory format, each entry has a tuple of two values.
-	 * For local files, the SLASH FID will be zero.
-	 */
 	dirent.d_id = value;
-	if (zp->z_phys->zp_s2fid)
-		dirent.d_s2fid = zp->z_phys->zp_s2fid;
-	else
-		FID_SET_FLAGS(dirent.d_s2fid, SLFIDF_LOCAL_DENTRY);
 
 	/* FALLOWDIRLINK is only set by zfsslash2_fidlink() */
 	error = _zap_add(zp->z_zfsvfs->z_os, dzp->z_id,
-	    dl->dl_name, 8, 2, &dirent, tx, flag & FALLOWDIRLINK);
+	    dl->dl_name, 8, 1, &dirent, tx, flag & FALLOWDIRLINK);
 	ASSERT(error == 0);
 
 	dnlc_update(ZTOV(dzp), dl->dl_name, vp);
Index: zfs/src/zfs-fuse/util.c
===================================================================
--- zfs/src/zfs-fuse/util.c	(revision 19179)
+++ zfs/src/zfs-fuse/util.c	(working copy)
@@ -35,6 +35,8 @@
 #include <syslog.h>
 #include <signal.h>
 
+#include "sys/zfs_znode.h"
+
 #include "libsolkerncompat.h"
 #include "zfs_ioctl.h"
 #include "zfsfuse_socket.h"
@@ -51,6 +53,8 @@
 #endif
 #include "util.h"
 
+#include "zfs_slashlib.h"
+
 static int ioctl_fd = -1;
 static int lock_fd = -1;
 
@@ -62,6 +66,11 @@
 
 int num_filesystems;
 
+int		mount_index;
+mount_info_t	zfsMount[MAX_FILESYSTEMS];
+
+void (*zfsslash2_hook_func)(int) = NULL;
+
 char * fuse_mount_options;
 char * zfs_lock_file;
 
@@ -313,22 +322,20 @@
 	static int mounted=0;
 	extern void *zfsVfs;
 
+	int error;
+	znode_t *rootzp;
+	zfsvfs_t *zfsvfs;
+	file_info_t *finfo;
+
 	VERIFY(mflag == 0);
 
 	vfs_t *vfs = kmem_zalloc(sizeof(vfs_t), KM_SLEEP);
 	if(vfs == NULL)
 		return ENOMEM;
 
-#if 0
-	if (mounted) 
-		return EALREADY;
-#endif
-
 	VFS_INIT(vfs, zfs_vfsops, 0);
 	VFS_HOLD(vfs);
 
-	zfsVfs = vfs;
-
 	struct mounta uap = {
 	.spec = spec,
 	.dir = dir,
@@ -341,7 +348,7 @@
 	};
 
 	int ret;
-	if ((ret = VFS_MOUNT(vfs, rootdir, &uap, kcred)) != 0) {
+	if ((ret = VFS_MOUNT(vfs, rootdir, &uap, kcred)) != 0) {	/* zfs_mount */
 		kmem_free(vfs, sizeof(vfs_t));
 		return ret;
 	} else
@@ -414,6 +421,45 @@
 		return EIO;
 	}
 #endif
+
+#ifdef ZFS_SLASHLIB
+	if (mount_index >= MAX_FILESYSTEMS - 1)
+		return ENOMEM;
+
+	zfsvfs = vfs->vfs_data;
+	ASSERT(zfsvfs->z_root == 3);
+	zfsMount[mount_index].rootid = zfsvfs->z_root; 
+
+	error = zfs_zget(zfsvfs, zfsvfs->z_root, &rootzp, B_FALSE);
+	ASSERT(!error);
+
+	finfo = kmem_cache_alloc(file_info_cache, KM_NOSLEEP);
+	ASSERT(finfo);
+
+	finfo->vp = ZTOV(rootzp);
+	finfo->flags = 0;
+
+	zfsMount[mount_index].rootinfo = finfo;
+
+	zfsMount[mount_index].flag = 0;
+	zfsMount[mount_index].vfs = vfs;
+	zfsMount[mount_index].fsid = -1;
+	zfsMount[mount_index].uuid = -1; 
+	strcpy(zfsMount[mount_index].name, dir);
+
+#if 0
+	/* 
+	 * A better idea is to scan for new file systems when we do 
+ 	 * a readdir under the root file system. Yeah, that is on-demand
+ 	 * registration.
+ 	 */
+	if (zfsslash2_hook_func)
+		zfsslash2_hook_func(mount_index);
+#endif
+
+	mount_index++;
+#endif
+
 	return 0;
 }
 
Index: zfs/src/zfs-fuse/zfs_vnops.c
===================================================================
--- zfs/src/zfs-fuse/zfs_vnops.c	(revision 19179)
+++ zfs/src/zfs-fuse/zfs_vnops.c	(working copy)
@@ -2212,7 +2212,6 @@
 	outcount = 0;
 	while (outcount < bytes_wanted) {
 		ino64_t objnum;
-		uint64_t s2num;
 		ushort_t reclen;
 		off64_t *next;
 
@@ -2243,7 +2242,7 @@
 			}
 
 			if (zap.za_integer_length != 8 ||
-			    zap.za_num_integers != 2) {
+			    zap.za_num_integers != 1) {
 				cmn_err(CE_WARN, "zap_readdir: bad directory "
 				    "entry, obj = %lld, offset = %lld\n",
 				    (u_longlong_t)zp->z_id,
@@ -2253,7 +2252,6 @@
 			}
 
 			objnum = ZFS_DIRENT_OBJ(zap.za_first_integer);
-			s2num = ZFS_DIRENT_OBJ(zap.za_second_integer);
 
 			/*
 			 * MacOS X can extract the object type here such as:
@@ -2319,7 +2317,6 @@
 			 * Add normal entry:
 			 */
 			odp->d_ino = objnum;
-			odp->d_s2fid = s2num;
 			odp->d_reclen = reclen;
 			/* NOTE: d_off is the offset for the *next* entry */
 			next = &(odp->d_off);
Index: zfs/src/zfs-fuse/zfs_slashlib.h
===================================================================
--- zfs/src/zfs-fuse/zfs_slashlib.h	(revision 19179)
+++ zfs/src/zfs-fuse/zfs_slashlib.h	(working copy)
@@ -19,34 +19,64 @@
 } file_info_t;
 #endif
 
+#define MAX_FILESYSTEMS		1000
+
+#define	 ZFS_SLASH2_NONE 	0x00
+#define	 ZFS_SLASH2_MKDIR	0x01
+#define	 ZFS_SLASH2_READY	0x02
+
+typedef struct mount_info {
+	uint64_t	 fsid;
+	uint64_t	 uuid;
+	uint64_t	 rootid;
+	int		 flag;			
+	char		 name[MAXPATHLEN];
+	void		*vfs;
+	void		*rootinfo;
+} mount_info_t;
+
+extern int		mount_index;
+extern mount_info_t	zfsMount[MAX_FILESYSTEMS];
+
+extern int		current_vfsid;
+
+extern void (*zfsslash2_hook_func)(int);
+
 //XXX shouldn't this be a single bit???
 #define SLASH2_CURSOR_FLAG	0x12345678	/* overload the ioflag of zfs_write() */
 
-int	zfsslash2_access(mdsio_fid_t, int, const struct slash_creds *);
-int	zfsslash2_fsync(const struct slash_creds *, int, void *);
-int	zfsslash2_getattr(mdsio_fid_t, void *finfo, const struct slash_creds *, struct srt_stat *);
-int	zfsslash2_link(mdsio_fid_t, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, sl_log_update_t);
-int	zfsslash2_lookup(mdsio_fid_t, const char *, mdsio_fid_t *, const struct slash_creds *, struct srt_stat *);
-int	zfsslash2_lookup_slfid(slfid_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *);
-int	zfsslash2_mkdir(mdsio_fid_t, const char *, const struct srt_stat *, int, int, struct srt_stat *, mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
-int	zfsslash2_mknod(mdsio_fid_t, const char *, mode_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t);
-int	zfsslash2_opencreate(mdsio_fid_t, const struct slash_creds *, int, int, mode_t, const char *, mdsio_fid_t *, struct srt_stat *, void *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
-int	zfsslash2_opendir(mdsio_fid_t, const struct slash_creds *, struct slash_fidgen *, void *);
-int	zfsslash2_preadv(const struct slash_creds *, struct iovec *, int, size_t *, off_t, void *);
-int	zfsslash2_pwritev(const struct slash_creds *, const struct iovec *, int, size_t *, off_t, int, void *, sl_log_write_t, void *);
-int	zfsslash2_read(const struct slash_creds *, void *, size_t, size_t *, off_t, void *);
-int	zfsslash2_readdir(const struct slash_creds *, size_t, off_t, void *, size_t *, size_t *, void  *, int, void *);
-int	zfsslash2_readlink(mdsio_fid_t, char *, const struct slash_creds *);
-int	zfsslash2_release(const struct slash_creds *, void *);
-int	zfsslash2_rename(mdsio_fid_t, const char *, mdsio_fid_t, const char *, const struct slash_creds *, sl_log_update_t, void *);
-int	zfsslash2_rmdir(mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t);
-int	zfsslash2_setattr(mdsio_fid_t, const struct srt_stat *, int, const struct slash_creds *, struct srt_stat *, void *, sl_log_update_t);
-int	zfsslash2_statfs(struct statvfs *);
-int	zfsslash2_symlink(const char *, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *, sl_getslfid_cb_t, sl_log_update_t);
-int	zfsslash2_unlink(mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t, void *);
-int	zfsslash2_write(const struct slash_creds *, const void *, size_t, size_t *, off_t, int, void *, sl_log_write_t, void *);
+int	zfsslash2_access(int, mdsio_fid_t, int, const struct slash_creds *);
+int	zfsslash2_fsync(int, const struct slash_creds *, int, void *);
+int	zfsslash2_getattr(int, mdsio_fid_t, void *finfo, const struct slash_creds *, struct srt_stat *);
+int	zfsslash2_link(int, mdsio_fid_t, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, sl_log_update_t);
+int	zfsslash2_lookup(int, mdsio_fid_t, const char *, mdsio_fid_t *, const struct slash_creds *, struct srt_stat *);
+int	zfsslash2_lookup_slfid(int, slfid_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *);
+int	zfsslash2_mkdir(int, mdsio_fid_t, const char *, const struct srt_stat *, int, int, struct srt_stat *, \
+			mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
+int	zfsslash2_mknod(int, mdsio_fid_t, const char *, mode_t, const struct slash_creds *, struct srt_stat *, \
+			mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t);
+int	zfsslash2_opencreate(int, mdsio_fid_t, const struct slash_creds *, int, int, mode_t, const char *, mdsio_fid_t *, \
+			     struct srt_stat *, void *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
+int	zfsslash2_opendir(int, mdsio_fid_t, const struct slash_creds *, struct slash_fidgen *, void *);
+int	zfsslash2_preadv(int, const struct slash_creds *, struct iovec *, int, size_t *, off_t, void *);
+int	zfsslash2_pwritev(int, const struct slash_creds *, const struct iovec *, int, size_t *, off_t, int, \
+			  void *, sl_log_write_t, void *);
+int	zfsslash2_read(int, const struct slash_creds *, void *, size_t, size_t *, off_t, void *);
+int	zfsslash2_readdir(int, const struct slash_creds *, size_t, off_t, void *, size_t *, size_t *, void  *, int, void *);
+int	zfsslash2_readlink(int, mdsio_fid_t, char *, const struct slash_creds *);
+int	zfsslash2_release(int, const struct slash_creds *, void *);
+int	zfsslash2_rename(int, mdsio_fid_t, const char *, mdsio_fid_t, const char *, const struct slash_creds *, \
+			 sl_log_update_t, void *);
+int	zfsslash2_rmdir(int, mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t);
+int	zfsslash2_setattr(int, mdsio_fid_t, const struct srt_stat *, int, const struct slash_creds *, \
+			  struct srt_stat *, void *, sl_log_update_t);
+int	zfsslash2_statfs(int, struct statvfs *);
+int	zfsslash2_symlink(int, const char *, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, \
+			  mdsio_fid_t *, sl_getslfid_cb_t, sl_log_update_t);
+int	zfsslash2_unlink(int, mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t, void *);
+int	zfsslash2_write(int, const struct slash_creds *, const void *, size_t, size_t *, off_t, int, void *, sl_log_write_t, void *);
 
-int	zfsslash2_write_cursor(void *, size_t, void *, sl_log_write_t);
+int	zfsslash2_write_cursor(int, void *, size_t, void *, sl_log_write_t);
 
 int	do_init_fusesocket(void);
 int	do_init(void);
@@ -56,22 +86,25 @@
 #define libzfs_init		do_init
 #define libzfs_exit		do_exit
 
-void	zfsslash2_build_immns_cache(void);
+void	zfsslash2_register_hook(void *);
+int	zfsslash2_build_immns_cache(int);
 int	zfsslash2_setattrmask_2_slflags(uint);
 uint	zfsslash2_slflags_2_setattrmask(int);
 
-int	zfsslash2_replay_create(slfid_t, char *, struct srt_stat *stat);
-int	zfsslash2_replay_fidlink(slfid_t, const struct slash_creds *);
-int	zfsslash2_replay_link(slfid_t, slfid_t, char *, struct srt_stat *stat);
-int	zfsslash2_replay_mkdir(slfid_t, char *, struct srt_stat *stat);
-int	zfsslash2_replay_rename(slfid_t, const char *, slfid_t, const char *, struct srt_stat *);
-int	zfsslash2_replay_rmdir(slfid_t, slfid_t, char *);
-int	zfsslash2_replay_setattr(slfid_t, uint, struct srt_stat *);
-int	zfsslash2_replay_symlink(slfid_t, slfid_t, char *, char *, struct srt_stat *stat);
-int	zfsslash2_replay_unlink(slfid_t, slfid_t, char *);
+int	zfsslash2_replay_create(int, slfid_t, char *, struct srt_stat *stat);
+int	zfsslash2_replay_fidlink(int, slfid_t, const struct slash_creds *);
+int	zfsslash2_replay_link(int, slfid_t, slfid_t, char *, struct srt_stat *stat);
+int	zfsslash2_replay_mkdir(int, slfid_t, char *, struct srt_stat *stat);
+int	zfsslash2_replay_rename(int, slfid_t, const char *, slfid_t, const char *, struct srt_stat *);
+int	zfsslash2_replay_rmdir(int, slfid_t, slfid_t, char *);
+int	zfsslash2_replay_setattr(int, slfid_t, uint, struct srt_stat *);
+int	zfsslash2_replay_symlink(int, slfid_t, slfid_t, char *, char *, struct srt_stat *stat);
+int	zfsslash2_replay_unlink(int, slfid_t, slfid_t, char *);
 
 uint64_t	zfsslash2_last_synced_txg(void);
 uint64_t	zfsslash2_return_synced(void);
 void		zfsslash2_wait_synced(uint64_t);
 
+int		mdsio_fid_to_vfsid(slfid_t, int *);
+
 #endif /* _ZFS_SLASHLIB_H_ */
Index: zfs/src/zfs-fuse/zfs_operations_slash.c
===================================================================
--- zfs/src/zfs-fuse/zfs_operations_slash.c	(revision 19179)
+++ zfs/src/zfs-fuse/zfs_operations_slash.c	(working copy)
@@ -67,10 +67,9 @@
 
 kmem_cache_t	*file_info_cache;
 cred_t		 zrootcreds;
-vfs_t		*zfsVfs;			/* initialized by do_mount() */
 int		 stack_size;
 
-uint64_t        *immnsIdCache;
+uint64_t        *immnsIdCache[MAX_FILESYSTEMS];
 uint64_t         immnsIdMask;
 
 /* flags for zfsslash2_fidlink() */
@@ -84,13 +83,13 @@
  *	ZFS/MDSIO layer inum "fid" (internal) for a vnode.
  */
 static __inline void
-get_vnode_fids(const vnode_t *vp, struct slash_fidgen *fgp,
-    mdsio_fid_t *mfp)
+get_vnode_fids(int vfsid, const vnode_t *vp, struct slash_fidgen *fgp, mdsio_fid_t *mfp)
 {
 	if (fgp) {
-		if (VTOZ(vp)->z_id == MDSIO_FID_ROOT)
+		if (VTOZ(vp)->z_id == MDSIO_FID_ROOT) {
 			fgp->fg_fid = SLFID_ROOT;
-		else
+			FID_SET_SITEID(fgp->fg_fid, zfsMount[vfsid].fsid);
+		} else
 			fgp->fg_fid = VTOZ(vp)->z_phys->zp_s2fid;
 		fgp->fg_gen = VTOZ(vp)->z_phys->zp_s2gen;
 	}
@@ -186,6 +185,7 @@
 void
 zfsslash2_destroy(void)
 {
+	int i;
 #ifdef DEBUG
 	extern int pscfs_exit_fuse_listener;
 
@@ -198,21 +198,24 @@
 	 * force unmount since there could still be open files.
 	 */
 	sync();
-	while (do_umount(zfsVfs, 0) != 0)
-		sync();
+	for (i = 0; i < mount_index; i++) {
+		while (do_umount(zfsMount[i].vfs, 0) != 0)
+			sync();
+	}
 #ifdef DEBUG
 	fprintf(stderr, "do_umount() done\n");
 #endif
 }
 
 int
-zfsslash2_statfs(struct statvfs *sfb)
+zfsslash2_statfs(int vfsid, struct statvfs *sfb)
 {
 	struct statvfs64 zsfb;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
 
 	memset(sfb, 0, sizeof(*sfb));
 	memset(&zsfb, 0, sizeof(zsfb));
-	int ret = VFS_STATVFS(zfsVfs, &zsfb);
+	int ret = VFS_STATVFS(vfs, &zsfb);
 	if (ret != 0)
 		return (ret);
 
@@ -236,7 +239,7 @@
 }
 
 static int
-fill_sstb(vnode_t *vp, mdsio_fid_t *mfp, struct srt_stat *sstb,
+fill_sstb(int vfsid, vnode_t *vp, mdsio_fid_t *mfp, struct srt_stat *sstb,
     cred_t *cred)
 {
 	struct slash_fidgen fg;
@@ -244,7 +247,7 @@
 	int error;
 
 	ASSERT(vp);
-	get_vnode_fids(vp, &fg, mfp);
+	get_vnode_fids(vfsid, vp, &fg, mfp);
 
 	if (sstb == NULL)
 		return (0);
@@ -309,11 +312,12 @@
 }
 
 int
-zfsslash2_getattr(mdsio_fid_t ino, void *finfo,
+zfsslash2_getattr(int vfsid, mdsio_fid_t ino, void *finfo,
     const struct slash_creds *slcrp, struct srt_stat *sstb)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 	file_info_t *info = finfo;
 	vnode_t *vp;
 	int error;
@@ -341,7 +345,7 @@
 	}
 	ASSERT(vp);
 
-	error = fill_sstb(vp, NULL, sstb, &cred);
+	error = fill_sstb(vfsid, vp, NULL, sstb, &cred);
 
 	if (release)
 		VN_RELE(vp);
@@ -609,13 +613,15 @@
 }
 
 int
-zfsslash2_lookup(mdsio_fid_t parent, const char *name,
+zfsslash2_lookup(int vfsid, mdsio_fid_t parent, const char *name,
     mdsio_fid_t *mfp, const struct slash_creds *slcrp,
     struct srt_stat *sstb)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
+
 	ZFS_ENTER(zfsvfs);
 
 	if (strlen(name) > MAXNAMELEN)
@@ -648,7 +654,7 @@
 	}
 
 	if (sstb || mfp)
-		error = fill_sstb(vp, mfp, sstb, &cred);
+		error = fill_sstb(vfsid, vp, mfp, sstb, &cred);
 
  out:
 	if (vp)
@@ -663,11 +669,12 @@
  * XXX replace finfop with something meaningful for slash d_ino cache
  */
 int
-zfsslash2_opendir(mdsio_fid_t ino, const struct slash_creds *slcrp,
+zfsslash2_opendir(int vfsid, mdsio_fid_t ino, const struct slash_creds *slcrp,
     struct slash_fidgen *fgp, void *finfop)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
@@ -692,7 +699,7 @@
 	/*
 	 * Check permissions.
 	 */
-	if (!(zfsVfs->fuse_attribute & FUSE_VFS_HAS_DEFAULT_PERM)) {
+	if (!(vfs->fuse_attribute & FUSE_VFS_HAS_DEFAULT_PERM)) {
 		error = VOP_ACCESS(vp, VREAD | VEXEC, 0, &cred, NULL);
 		if (error)
 			goto out;
@@ -709,7 +716,7 @@
 	finfo->vp = vp;
 	finfo->flags = FREAD;
 
-	get_vnode_fids(vp, fgp, NULL);
+	get_vnode_fids(vfsid, vp, fgp, NULL);
 
  out:
 	if (error)
@@ -723,10 +730,11 @@
  * XXX convert to the slash d_ino cache .. same as above
  */
 int
-zfsslash2_release(__unusedx const struct slash_creds *slcrp, void
+zfsslash2_release(int vfsid, __unusedx const struct slash_creds *slcrp, void
     *finfo)
 {
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 	file_info_t *info = finfo;
 
 	ZFS_ENTER(zfsvfs);
@@ -743,59 +751,65 @@
 	return 0;
 }
 
-void
-zfsslash2_build_immns_cache_helper(vnode_t *root, int curdepth,
+int
+zfsslash2_build_immns_cache_helper(int vfsid, vnode_t *root, int curdepth,
     int maxdepth, int *cnt)
 {
 	vnode_t         *vp;
-	int              i;
+	int              i, error = 0;
 	char		 id_name[2];
 
 	for (i = 0; i < 16; i++) {
 		snprintf(id_name, 2, "%x", i);
 
-		if (VOP_LOOKUP(root, id_name, &vp, NULL, 0, NULL,
-		    &zrootcreds, NULL, NULL, NULL))
-			abort();
+		error = VOP_LOOKUP(root, id_name, &vp, NULL, 0, NULL,
+		    &zrootcreds, NULL, NULL, NULL);
+		if (error)
+			break;
 
-		if (curdepth < maxdepth)
-			zfsslash2_build_immns_cache_helper(vp,
+		if (curdepth < maxdepth) {
+			error = zfsslash2_build_immns_cache_helper(vfsid, vp,
 			    curdepth + 1, maxdepth, cnt);
-		else {
-			immnsIdCache[(*cnt)++] = VTOZ(vp)->z_id;
+			if (error)
+				break;
+		} else {
+			immnsIdCache[vfsid][(*cnt)++] = VTOZ(vp)->z_id;
 			psclog_debug("depth=%d cnt=%d zfid=%#"PRIx64,
 			    curdepth, *cnt, VTOZ(vp)->z_id);
 		}
 
 		VN_RELE(vp);
 	}
+	return (error);
 }
 
-void
-zfsslash2_build_immns_cache(void)
+int
+zfsslash2_build_immns_cache(int vfsid)
 {
 	znode_t         *znode;
 	vnode_t		*dvp;
 	int		 error, cnt=0;
-	zfsvfs_t	*zfsvfs = zfsVfs->vfs_data;
+	struct vfs	*vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t	*zfsvfs = vfs->vfs_data;
 	uint64_t ndirs;
 
 	/* the number of directories at the lowest level */
 	ndirs = 1 << (BPHXC * FID_PATH_DEPTH);
-	immnsIdCache = malloc(sizeof(uint64_t) * ndirs);
+	immnsIdCache[vfsid] = malloc(sizeof(uint64_t) * ndirs);
 	immnsIdMask = (ndirs - 1) << (BPHXC * FID_PATH_START);
 
-	error = zfs_zget(zfsvfs, mds_fidnsdir_inum, &znode, B_TRUE);
+	error = zfs_zget(zfsvfs, mds_fidnsdir_inum[vfsid], &znode, B_TRUE);
 	if (error)
-		psc_fatal("error=%d", error);
+		return (error);
 
 	ASSERT(znode);
 	dvp = ZTOV(znode);
 	ASSERT(dvp);
 
-	zfsslash2_build_immns_cache_helper(dvp, 1, FID_PATH_DEPTH,
-	    &cnt);
+	error = zfsslash2_build_immns_cache_helper(vfsid, dvp, 1, 
+			FID_PATH_DEPTH, &cnt);
 	VN_RELE(dvp);
+	return (error);
 }
 
 /*
@@ -803,7 +817,7 @@
  * readdir result, attrs points to prefetched attributes.
  */
 int
-zfsslash2_readdir(const struct slash_creds *slcrp, size_t size,
+zfsslash2_readdir(int vfsid, const struct slash_creds *slcrp, size_t size,
     off_t off, void *outbuf, size_t *outbuf_len, size_t *nents,
     void *attrs, int nstbprefetch, void *finfo)
 {
@@ -818,7 +832,8 @@
 	if (vp->v_type != VDIR)
 		return ENOTDIR;
 
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
@@ -911,7 +926,7 @@
 
 		if (nstbprefetch) {
 			/* XXX look at fidcache first */
-			if (fill_sstb(tvp, NULL, attr, &cred))
+			if (fill_sstb(vfsid, tvp, NULL, attr, &cred))
 				attr->sst_fid = FID_ANY;
 			nstbprefetch--;
 			attr++;
@@ -969,8 +984,8 @@
 	return error;
 }
 
-#define zfsslash2_fidlink(fid, flags, svp, vpp)				\
-	_zfsslash2_fidlink(PFL_CALLERINFOSS(SLMSS_ZFS), (fid), (flags), (svp), (vpp))
+#define zfsslash2_fidlink(vfsid, fid, flags, svp, vpp)				\
+	_zfsslash2_fidlink(PFL_CALLERINFOSS(SLMSS_ZFS), (vfsid), (fid), (flags), (svp), (vpp))
 
 /**
  * zfsslash2_fidlink - Construct the by-id namespace for our internal
@@ -983,10 +998,11 @@
  * file system.
  */
 int
-_zfsslash2_fidlink(const struct pfl_callerinfo *pci, slfid_t fid,
+_zfsslash2_fidlink(const struct pfl_callerinfo *pci, int vfsid, slfid_t fid,
     int flags, vnode_t *svp, vnode_t **vpp)
 {
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 	vnode_t *vp, *dvp;
 	znode_t *znode;
 	char id_name[20];
@@ -996,7 +1012,7 @@
 	/*
 	 * Map the root of SLASH2 metadir to the root of the underlying ZFS.
 	 */
-	if ((flags & FIDLINK_LOOKUP) && fid == SLFID_ROOT) {
+	if ((flags & FIDLINK_LOOKUP) && FID_GET_INUM(fid) == SLFID_ROOT) {
 #if 0
 /*
  * I have found a place in zfs_mknode() where I can write SLASH FID 1 into the
@@ -1021,7 +1037,7 @@
 	}
 
 	error = zfs_zget(zfsvfs,
-	    immnsIdCache[(fid & immnsIdMask) >> (BPHXC * FID_PATH_START)],
+	    immnsIdCache[vfsid][(fid & immnsIdMask) >> (BPHXC * FID_PATH_START)],
 	    &znode, B_TRUE);
 	if (error)
 		return error == EEXIST ? ENOENT : error;
@@ -1084,7 +1100,7 @@
 }
 
 int
-zfsslash2_lookup_slfid(slfid_t fid, const struct slash_creds *slcrp,
+zfsslash2_lookup_slfid(int vfsid, slfid_t fid, const struct slash_creds *slcrp,
     struct srt_stat *sstb, mdsio_fid_t *mfp)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
@@ -1092,11 +1108,11 @@
 	int error;
 
 	vp = NULL;
-	error = zfsslash2_fidlink(fid, FIDLINK_LOOKUP, NULL, &vp);
+	error = zfsslash2_fidlink(vfsid, fid, FIDLINK_LOOKUP, NULL, &vp);
 	if (error)
 		return (error);
 	if (sstb || mfp)
-		error = fill_sstb(vp, mfp, sstb, &cred);
+		error = fill_sstb(vfsid, vp, mfp, sstb, &cred);
 
 	VN_RELE(vp);
 	return (error);
@@ -1122,13 +1138,14 @@
  * the inode of the parent.
  */
 int
-zfsslash2_opencreate(mdsio_fid_t ino, const struct slash_creds *slcrp,
+zfsslash2_opencreate(int vfsid, mdsio_fid_t ino, const struct slash_creds *slcrp,
     int fflags, int opflags, mode_t createmode, const char *name,
     mdsio_fid_t *mfp, struct srt_stat *sstb, void *finfop,
     sl_log_update_t logfunc, sl_getslfid_cb_t getslfid, slfid_t fid)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
@@ -1224,6 +1241,7 @@
 		vp = new_vp;
 		if ((opflags & MDSIO_OPENCRF_NOLINK) == 0) {
 			error = zfsslash2_fidlink(
+			    vfsid,
 			    VTOZ(vp)->z_phys->zp_s2fid,
 			    FIDLINK_CREATE, vp, NULL);
 #if 0
@@ -1259,7 +1277,7 @@
 		/*
 		 * Check permissions.
 		 */
-		if (!(zfsVfs->fuse_attribute & FUSE_VFS_HAS_DEFAULT_PERM)) {
+		if (!(vfs->fuse_attribute & FUSE_VFS_HAS_DEFAULT_PERM)) {
 			error = VOP_ACCESS(vp, mode, 0, &cred, NULL);
 			if (error)
 				goto out;
@@ -1272,7 +1290,7 @@
 	}
 
 	if (sstb || mfp) {
-		error = fill_sstb(vp, mfp, sstb, &cred);
+		error = fill_sstb(vfsid, vp, mfp, sstb, &cred);
 		if (error)
 			goto out;
 	}
@@ -1300,11 +1318,12 @@
 }
 
 int
-zfsslash2_readlink(mdsio_fid_t ino, char *buf,
+zfsslash2_readlink(int vfsid, mdsio_fid_t ino, char *buf,
     const struct slash_creds *slcrp)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
@@ -1355,7 +1374,7 @@
  * Returns errno on failure, 0 on success.
  */
 int
-zfsslash2_preadv(const struct slash_creds *slcrp, struct iovec *iovs,
+zfsslash2_preadv(int vfsid, const struct slash_creds *slcrp, struct iovec *iovs,
     int niov, size_t *nb, off_t off, void *finfo)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
@@ -1365,7 +1384,8 @@
 	ASSERT(vp);
 	ASSERT(VTOZ(vp));
 
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
@@ -1382,7 +1402,7 @@
 		uio.uio_resid += iovs[i].iov_len;
 	uio.uio_loffset = off;
 
-	int error = VOP_READ(vp, &uio, info->flags, &cred, NULL);
+	int error = VOP_READ(vp, &uio, info->flags, &cred, NULL); /* zfs_read() */
 
 	ZFS_EXIT(zfsvfs);
 
@@ -1392,24 +1412,25 @@
 }
 
 int
-zfsslash2_read(const struct slash_creds *slcrp, void *buf, size_t size,
+zfsslash2_read(int vfsid, const struct slash_creds *slcrp, void *buf, size_t size,
     size_t *nb, off_t off, void *finfo)
 {
 	struct iovec iov;
 
 	iov.iov_base = buf;
 	iov.iov_len = size;
-	return (zfsslash2_preadv(slcrp, &iov, 1, nb, off, finfo));
+	return (zfsslash2_preadv(vfsid, slcrp, &iov, 1, nb, off, finfo));
 }
 
 int
-zfsslash2_mkdir(mdsio_fid_t parent, const char *name,
+zfsslash2_mkdir(int vfsid, mdsio_fid_t parent, const char *name,
     const struct srt_stat *sstb_in, int atflag, int opflags,
     struct srt_stat *sstb_out, mdsio_fid_t *mfp,
     sl_log_update_t logfunc, sl_getslfid_cb_t getslfid, slfid_t fid)
 {
 	cred_t cred = { sstb_in->sst_uid, sstb_in->sst_gid };
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
@@ -1456,13 +1477,15 @@
 
 	ASSERT(vp);
 
-	error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
-	    FIDLINK_CREATE, vp, NULL);
-	if (error)
-		goto out;
+	if ((opflags & MDSIO_OPENCRF_NOLINK) == 0) {
+		error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
+		    FIDLINK_CREATE, vp, NULL);
+		if (error)
+			goto out;
+	}
 
 	if (sstb_out || mfp)
-		error = fill_sstb(vp, mfp, sstb_out, &zrootcreds);
+		error = fill_sstb(vfsid, vp, mfp, sstb_out, &zrootcreds);
 
 #if 0
 	fprintf(stderr, "mkdir: name=%s fid=0x%lx txg=%lx error=%d\n",
@@ -1478,12 +1501,14 @@
 }
 
 int
-zfsslash2_rmdir(mdsio_fid_t parent, slfid_t *fid, const char *name,
+zfsslash2_rmdir(int vfsid, mdsio_fid_t parent, slfid_t *fid, const char *name,
     const struct slash_creds *slcrp, sl_log_update_t logfunc)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
+
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
@@ -1529,7 +1554,7 @@
 	if (fid)
 		*fid = VTOZ(vp)->z_phys->zp_s2fid;
 	if (!error)
-		error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+		error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 		    FIDLINK_REMOVE|FIDLINK_DIR, NULL, NULL);
 
 	VN_RELE(vp);
@@ -1541,12 +1566,14 @@
 }
 
 int
-zfsslash2_setattr(mdsio_fid_t ino, const struct srt_stat *sstb_in,
+zfsslash2_setattr(int vfsid, mdsio_fid_t ino, const struct srt_stat *sstb_in,
     int to_set, const struct slash_creds *slcrp,
     struct srt_stat *sstb_out, void *finfo, sl_log_update_t logfunc)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 	file_info_t *info = finfo;
 	znode_t *znode;
 
@@ -1689,7 +1716,7 @@
 
  out:
 	if (!error && sstb_out)
-		error = fill_sstb(vp, NULL, sstb_out, &cred);
+		error = fill_sstb(vfsid, vp, NULL, sstb_out, &cred);
 
 	if (release)
 		VN_RELE(vp);
@@ -1700,12 +1727,14 @@
 }
 
 int
-zfsslash2_unlink(mdsio_fid_t parent, slfid_t *fid, const char *name,
+zfsslash2_unlink(int vfsid, mdsio_fid_t parent, slfid_t *fid, const char *name,
     const struct slash_creds *slcrp, sl_log_update_t logfunc, void *arg)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
+
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
@@ -1752,7 +1781,7 @@
 	 * the file.
 	 */
 	if (vattr.va_nlink == 1)
-		error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+		error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 		    FIDLINK_REMOVE, NULL, NULL);
 
  out:
@@ -1768,7 +1797,7 @@
  * Returns errno on failure, 0 on success.
  */
 int
-zfsslash2_pwritev(const struct slash_creds *slcrp,
+zfsslash2_pwritev(int vfsid, const struct slash_creds *slcrp,
     const struct iovec *iovs, int niov, size_t *nb, off_t off,
     int update_mtime, void *finfo, sl_log_write_t funcp, void *datap)
 {
@@ -1779,7 +1808,8 @@
 	ASSERT(vp);
 	ASSERT(VTOZ(vp));
 
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
@@ -1813,7 +1843,7 @@
 }
 
 __inline int
-zfsslash2_write(const struct slash_creds *slcrp, const void *buf,
+zfsslash2_write(int vfsid, const struct slash_creds *slcrp, const void *buf,
     size_t size, size_t *nb, off_t off, int update_mtime, void *finfo,
     sl_log_write_t funcp, void *datap)
 {
@@ -1821,18 +1851,19 @@
 
 	iov.iov_base = (void *)buf;
 	iov.iov_len = size;
-	return (zfsslash2_pwritev(slcrp, &iov, 1, nb, off, update_mtime,
+	return (zfsslash2_pwritev(vfsid, slcrp, &iov, 1, nb, off, update_mtime,
 	    finfo, funcp, datap));
 }
 
 int
-zfsslash2_write_cursor(void *buf, size_t size, void *finfo,
+zfsslash2_write_cursor(int vfsid, void *buf, size_t size, void *finfo,
     sl_log_write_t funcp)
 {
 	file_info_t *info = finfo;
 
 	vnode_t *vp = info->vp;
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
@@ -1859,13 +1890,15 @@
 }
 
 int
-zfsslash2_mknod(mdsio_fid_t parent, const char *name, mode_t mode,
+zfsslash2_mknod(int vfsid, mdsio_fid_t parent, const char *name, mode_t mode,
     const struct slash_creds *slcrp, struct srt_stat *sstb,
     mdsio_fid_t *mfp, sl_log_update_t logfunc, sl_getslfid_cb_t getslfid)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
+
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
@@ -1909,13 +1942,13 @@
 
 	ASSERT(vp);
 
-	error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+	error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 	    FIDLINK_CREATE, vp, NULL);
 	if (error)
 		goto out;
 
 	if (sstb || mfp)
-		error = fill_sstb(vp, mfp, sstb, &cred);
+		error = fill_sstb(vfsid, vp, mfp, sstb, &cred);
 
  out:
 	if (vp)
@@ -1928,13 +1961,15 @@
 }
 
 int
-zfsslash2_symlink(const char *link, mdsio_fid_t parent, const char *name,
+zfsslash2_symlink(int vfsid, const char *link, mdsio_fid_t parent, const char *name,
     const struct slash_creds *slcrp, struct srt_stat *sstb,
     mdsio_fid_t *mfp, sl_getslfid_cb_t getslfid, sl_log_update_t logfunc)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
+
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
@@ -1980,7 +2015,7 @@
 	if (error)
 		goto out;
 
-	error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+	error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 	    FIDLINK_CREATE, vp, NULL);
 	if (error)
 		goto out;
@@ -1988,7 +2023,7 @@
 	ASSERT(vp);
 
 	if (sstb || mfp)
-		error = fill_sstb(vp, mfp, sstb, &cred);
+		error = fill_sstb(vfsid, vp, mfp, sstb, &cred);
 
  out:
 	if (vp)
@@ -2001,13 +2036,15 @@
 }
 
 int
-zfsslash2_rename(mdsio_fid_t oldparent, const char *oldname,
+zfsslash2_rename(int vfsid, mdsio_fid_t oldparent, const char *oldname,
     mdsio_fid_t newparent, const char *newname,
     const struct slash_creds *slcrp, sl_log_update_t logfunc, void *arg)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
+
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *op_znode, *np_znode;
@@ -2056,12 +2093,14 @@
 }
 
 int
-zfsslash2_fsync(const struct slash_creds *slcrp, int datasync,
+zfsslash2_fsync(int vfsid, const struct slash_creds *slcrp, int datasync,
     void *finfo)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
+
 	ZFS_ENTER(zfsvfs);
 
 	file_info_t *info = finfo;
@@ -2079,13 +2118,15 @@
 }
 
 int
-zfsslash2_link(mdsio_fid_t ino, mdsio_fid_t newparent,
+zfsslash2_link(int vfsid, mdsio_fid_t ino, mdsio_fid_t newparent,
     const char *newname, const struct slash_creds *slcrp,
     struct srt_stat *sstb, sl_log_update_t logfunc)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
+
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *td_znode, *s_znode;
@@ -2132,7 +2173,7 @@
 	ASSERT(vp);
 
 	if (sstb)
-		error = fill_sstb(vp, NULL, sstb, &cred);
+		error = fill_sstb(vfsid, vp, NULL, sstb, &cred);
 
  out:
 	if (vp)
@@ -2146,11 +2187,13 @@
 }
 
 int
-zfsslash2_access(mdsio_fid_t ino, int mask, const struct slash_creds *slcrp)
+zfsslash2_access(int vfsid, mdsio_fid_t ino, int mask, const struct slash_creds *slcrp)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
+
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
@@ -2216,8 +2259,9 @@
 zfsslash2_wait_synced(uint64_t txg)
 {
 	dsl_pool_t *dp;
+	struct vfs *vfs = zfsMount[current_vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 	dp = spa_get_dsl(zfsvfs->z_os->os_spa);
 	txg_wait_synced(dp, txg);
 }
@@ -2227,8 +2271,9 @@
 {
 	dsl_pool_t *dp;
 	uint64_t txg;
+	struct vfs *vfs = zfsMount[current_vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 	dp = spa_get_dsl(zfsvfs->z_os->os_spa);
 	txg = txg_return_synced(dp);
 	return (txg);
@@ -2271,7 +2316,7 @@
 }
 
 int
-zfsslash2_replay_symlink(slfid_t pfid, slfid_t fid, char *name,
+zfsslash2_replay_symlink(int vfsid, slfid_t pfid, slfid_t fid, char *name,
     char *link, struct srt_stat *sstb)
 {
 	vnode_t *vp, *pvp;
@@ -2284,7 +2329,7 @@
 	/*
 	 * Make sure the parent exists, at least in the by-id namespace.
 	 */
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP | FIDLINK_CREATE,
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP | FIDLINK_CREATE,
 	    NULL, &pvp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
@@ -2311,7 +2356,7 @@
 	if (error)
 		goto out;
 
-	error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+	error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 	    FIDLINK_CREATE, vp, NULL);
 
  out:
@@ -2323,7 +2368,7 @@
 }
 
 int
-zfsslash2_replay_link(slfid_t pfid, slfid_t fid, char *name,
+zfsslash2_replay_link(int vfsid, slfid_t pfid, slfid_t fid, char *name,
     struct srt_stat *sstb)
 {
 	vnode_t *pvp, *svp;
@@ -2335,14 +2380,14 @@
 	/*
 	 * Make sure the parent exists, at least in the by-id namespace.
 	 */
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP | FIDLINK_CREATE,
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP | FIDLINK_CREATE,
 	    NULL, &pvp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    fid, slstrerror(error));
 		goto out;
 	}
-	error = zfsslash2_fidlink(fid, FIDLINK_LOOKUP | FIDLINK_CREATE,
+	error = zfsslash2_fidlink(vfsid, fid, FIDLINK_LOOKUP | FIDLINK_CREATE,
 	    NULL, &svp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
@@ -2365,7 +2410,7 @@
 }
 
 int
-zfsslash2_replay_mkdir(slfid_t pfid, char *name, struct srt_stat *sstb)
+zfsslash2_replay_mkdir(int vfsid, slfid_t pfid, char *name, struct srt_stat *sstb)
 {
 	vnode_t *pvp, *tvp;
 	vattr_t vattr;
@@ -2377,7 +2422,7 @@
 	/*
 	 * Make sure the parent exists, at least in the by-id namespace.
 	 */
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP,
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP,
 	    NULL, &pvp);
 	if (error) {
 		psclog_errorx("failed to look up parent fid "SLPRI_FID": %s",
@@ -2403,7 +2448,7 @@
 		goto out;
 	}
 
-	error = zfsslash2_fidlink(sstb->sst_fid, FIDLINK_CREATE, tvp, NULL);
+	error = zfsslash2_fidlink(vfsid, sstb->sst_fid, FIDLINK_CREATE, tvp, NULL);
 	if (error)
 		psclog_errorx("failed to create fidlink "SLPRI_FID": %s",
 		    sstb->sst_fid, slstrerror(error));
@@ -2417,7 +2462,7 @@
 }
 
 int
-zfsslash2_replay_create(slfid_t pfid, char *name, struct srt_stat *sstb)
+zfsslash2_replay_create(int vfsid, slfid_t pfid, char *name, struct srt_stat *sstb)
 {
 	vnode_t *pvp, *tvp;
 	vattr_t vattr;
@@ -2429,7 +2474,7 @@
 	/*
 	 * Make sure the parent exists, at least in the by-id namespace.
 	 */
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP,
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP,
 	    NULL, &pvp);
 	if (error) {
 		psclog_errorx("failed to look up parent fid "SLPRI_FID": %s",
@@ -2452,7 +2497,7 @@
 	if (error)
 		goto out;
 
-	error = zfsslash2_fidlink(sstb->sst_fid, FIDLINK_CREATE, tvp,
+	error = zfsslash2_fidlink(vfsid, sstb->sst_fid, FIDLINK_CREATE, tvp,
 	    NULL);
 	if (error)
 		psclog_errorx("failed to create fidlink "SLPRI_FID": %s",
@@ -2466,14 +2511,14 @@
 }
 
 int
-zfsslash2_replay_rmdir(slfid_t pfid, slfid_t fid, char *name)
+zfsslash2_replay_rmdir(int vfsid, slfid_t pfid, slfid_t fid, char *name)
 {
 	vnode_t *dvp, *vp;
 	int error;
 
 	vp = NULL;
 	dvp = NULL;
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP, NULL, &dvp);
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP, NULL, &dvp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    fid, slstrerror(error));
@@ -2499,7 +2544,7 @@
 		error = ENOTEMPTY;
 
 	if (!error) {
-		error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+		error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 		    FIDLINK_REMOVE | FIDLINK_DIR, NULL, NULL);
 		if (!error)
 			/*
@@ -2518,13 +2563,13 @@
 }
 
 int
-zfsslash2_replay_unlink(slfid_t pfid, slfid_t fid, char *name)
+zfsslash2_replay_unlink(int vfsid, slfid_t pfid, slfid_t fid, char *name)
 {
 	vnode_t *vp, *dvp;
 	int error;
 
 	vp = dvp = NULL;
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP, NULL, &dvp);
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP, NULL, &dvp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    fid, slstrerror(errno));
@@ -2557,7 +2602,7 @@
 	 * so remove the file.
 	 */
 	if (vattr.va_nlink == 1)
-		error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+		error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 		    FIDLINK_REMOVE, NULL, NULL);
 
  out:
@@ -2569,14 +2614,14 @@
 }
 
 int
-zfsslash2_replay_setattr(slfid_t fid, uint mask, struct srt_stat *sstb)
+zfsslash2_replay_setattr(int vfsid, slfid_t fid, uint mask, struct srt_stat *sstb)
 {
 	int error, flag;
 	vattr_t vattr;
 	vnode_t *vp;
 
 	vp = NULL;
-	error = zfsslash2_fidlink(fid, FIDLINK_LOOKUP, NULL, &vp);
+	error = zfsslash2_fidlink(vfsid, fid, FIDLINK_LOOKUP, NULL, &vp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID, fid);
 		goto out;
@@ -2596,7 +2641,7 @@
 	/* Note: not using zrootcreds will return EPERM (1) */
 	error = VOP_SETATTR(vp, &vattr, flag, &zrootcreds, NULL, NULL);		/* zfs_setattr() */
 	if (!error)
-		error = fill_sstb(vp, NULL, sstb, &zrootcreds);
+		error = fill_sstb(vfsid, vp, NULL, sstb, &zrootcreds);
  out:
 	if (vp)
 		VN_RELE(vp);
@@ -2604,20 +2649,20 @@
 }
 
 int
-zfsslash2_replay_rename(slfid_t parent, const char *name, slfid_t
+zfsslash2_replay_rename(int vfsid, slfid_t parent, const char *name, slfid_t
     newparent, const char *newname, __unusedx struct srt_stat *stat)
 {
 	vnode_t *p_vp, *np_vp;
 	int error;
 
 	p_vp = np_vp = NULL;
-	error = zfsslash2_fidlink(parent, FIDLINK_LOOKUP, NULL, &p_vp);
+	error = zfsslash2_fidlink(vfsid, parent, FIDLINK_LOOKUP, NULL, &p_vp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    parent, slstrerror(errno));
 		goto out;
 	}
-	error = zfsslash2_fidlink(newparent, FIDLINK_LOOKUP, NULL, &np_vp);
+	error = zfsslash2_fidlink(vfsid, newparent, FIDLINK_LOOKUP, NULL, &np_vp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    newparent, slstrerror(errno));
@@ -2635,7 +2680,7 @@
 }
 
 int
-zfsslash2_replay_fidlink(slfid_t fid, const struct slash_creds *slcrp)
+zfsslash2_replay_fidlink(int vfsid, slfid_t fid, const struct slash_creds *slcrp)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
 	vnode_t *vp;
@@ -2647,7 +2692,7 @@
 	 * and create the fidlink if it is missing.
 	 */
 	vp = NULL;
-	error = zfsslash2_fidlink(fid, FIDLINK_LOOKUP | FIDLINK_CREATE,
+	error = zfsslash2_fidlink(vfsid, fid, FIDLINK_LOOKUP | FIDLINK_CREATE,
 	    NULL, &vp);
 	if (error)
 		return (error);
@@ -2655,3 +2700,9 @@
 	VN_RELE(vp);
 	return 0;
 }
+
+void
+zfsslash2_register_hook(void *funp)
+{
+	zfsslash2_hook_func = funp;
+}
Index: zfs/src/zfs-fuse/main.c
===================================================================
--- zfs/src/zfs-fuse/main.c	(revision 19179)
+++ zfs/src/zfs-fuse/main.c	(working copy)
@@ -44,7 +44,6 @@
 extern void fuse_unmount_all(); // in fuse_listener.c
 static int cf_daemonize = 1;
 extern int no_kstat_mount; // kstat.c
-void *zfsVfs;
 
 static void exit_handler(int sig)
 {
Index: zfs/src/lib/libzfscommon/include/sys/zap.h
===================================================================
--- zfs/src/lib/libzfscommon/include/sys/zap.h	(revision 19179)
+++ zfs/src/lib/libzfscommon/include/sys/zap.h	(working copy)
@@ -312,7 +312,6 @@
 	boolean_t za_normalization_conflict;
 	uint64_t za_num_integers;
 	uint64_t za_first_integer;	/* no sign extension for <8byte ints */
-	uint64_t za_second_integer;	/* slash2: may be used to store s2id */
 	char za_name[MAXNAMELEN];
 } zap_attribute_t;
 
Index: zfs/src/lib/libsolkerncompat/include/sys/dirent.h
===================================================================
--- zfs/src/lib/libsolkerncompat/include/sys/dirent.h	(revision 19179)
+++ zfs/src/lib/libsolkerncompat/include/sys/dirent.h	(working copy)
@@ -76,7 +76,6 @@
  */
 typedef struct dirent64 {
 	ino64_t		d_ino;		/* "inode number" of entry */
-	uint64_t	d_s2fid;	/* SLASH FID and flags */
 	off64_t		d_off;		/* offset of disk directory entry */
 	unsigned short	d_reclen;	/* length of this record */
 	char		d_name[1];	/* name of file */
Index: slash_nara/slimmns/slimmns_format.c
===================================================================
--- slash_nara/slimmns/slimmns_format.c	(revision 19179)
+++ slash_nara/slimmns/slimmns_format.c	(working copy)
@@ -52,6 +52,7 @@
 int		 wipe;
 int		 ion;
 struct passwd	*pw;
+uint64_t         fsid = 0;
 uint64_t         fsUuid = 0;
 const char      *datadir = SL_PATH_DATA_DIR;
 
@@ -201,12 +202,23 @@
 
 	if (!fsUuid)
 		fsUuid = psc_random64();
-	fprintf(fp, "%16"PRIx64"\n", fsUuid);
+	fprintf(fp, "%18"PRIx64"\n", fsUuid);
 	if (!ion)
-		printf("The UUID of the pool is %#16"PRIx64"\n", fsUuid);
+		printf("The UUID of the file system is %#18"PRIx64"\n", fsUuid);
 
 	fclose(fp);
 
+	/* create the FSID file */
+	xmkfn(fn, "%s/%s", metadir, SL_FN_FSID);
+	fp = fopen(fn, "w");
+	if (fp == NULL)
+		psc_fatal("open %s", fn);
+	fprintf(fp, "%18"PRIx64"\n", fsid);
+	if (!ion)
+		printf("The FSID of the file system is %#18"PRIx64"\n", fsid);
+
+	fclose(fp);
+
 	/* create the journal cursor file */
 	xmkfn(fn, "%s/%s", metadir, SL_FN_CURSOR);
 	fd = open(fn, O_CREAT | O_TRUNC | O_WRONLY, 0600);
@@ -220,6 +232,7 @@
 	cursor.pjc_version = PJRNL_CURSOR_VERSION;
 	cursor.pjc_timestamp = time(NULL);
 	cursor.pjc_fid = SLFID_MIN;
+	FID_SET_SITEID(cursor.pjc_fid, fsid);
 	if (pwrite(fd, &cursor, sizeof(cursor), 0) != sizeof(cursor))
 		psc_fatal("write %s", fn);
 	close(fd);
@@ -293,7 +306,7 @@
 
 	pfl_init();
 	progname = argv[0];
-	while ((c = getopt(argc, argv, "c:D:iWu:")) != -1)
+	while ((c = getopt(argc, argv, "c:D:iI:Wu:")) != -1)
 		switch (c) {
 		case 'c':
 			cfgfn = optarg;
@@ -310,6 +323,14 @@
 			if (endp == optarg || *endp)
 				errx(1, "%s: invalid FSUUID", optarg);
 			break;
+		case 'I':
+			endp = NULL;
+			fsid = strtoull(optarg, &endp, 16);
+			if (endp == optarg || *endp)
+				errx(1, "%s: invalid FSID", optarg);
+			if (fsid >= (1 << SLASH_FID_SITE_BITS))
+				errx(1, "%lu: FSID too big", fsid);
+			break;
 		case 'W':
 			wipe = 1;
 			break;
Index: slash_nara/include/pathnames.h
===================================================================
--- slash_nara/include/pathnames.h	(revision 19179)
+++ slash_nara/include/pathnames.h	(working copy)
@@ -65,6 +65,7 @@
 
 #define SL_FN_CURSOR		"cursor"
 #define SL_FN_FSUUID		"fsuuid"
+#define SL_FN_FSID		"fsid"
 
 extern const char *sl_datadir;
 
Index: slash_nara/slmkjrnl/slmkjrnl.c
===================================================================
--- slash_nara/slmkjrnl/slmkjrnl.c	(revision 19179)
+++ slash_nara/slmkjrnl/slmkjrnl.c	(working copy)
@@ -47,8 +47,6 @@
 struct pscfs	 pscfs;
 struct mdsio_ops mdsio_ops;
 
-mdsio_fid_t	 mds_fidnsdir_inum;
-
 __dead void
 usage(void)
 {
Index: slash_nara/utils/typedump/typedump.c
===================================================================
--- slash_nara/utils/typedump/typedump.c	(revision 19179)
+++ slash_nara/utils/typedump/typedump.c	(working copy)
@@ -199,6 +199,7 @@
 	PRTYPE(struct resm_mds_info);
 	PRTYPE(struct resprof_cli_info);
 	PRTYPE(struct resprof_mds_info);
+	PRTYPE(struct rootNames);
 	PRTYPE(struct site_mds_info);
 	PRTYPE(struct site_progress);
 	PRTYPE(struct sl_buffer);
Index: slash_nara/slashd/up_sched_res.c
===================================================================
--- slash_nara/slashd/up_sched_res.c	(revision 19179)
+++ slash_nara/slashd/up_sched_res.c	(working copy)
@@ -54,6 +54,8 @@
 #include "slutil.h"
 #include "up_sched_res.h"
 
+extern int current_vfsid;
+
 struct upschedtree	 upsched_tree = SPLAY_INITIALIZER(&upsched_tree);
 struct psc_poolmgr	*upsched_pool;
 struct psc_lockedlist	 upsched_listhd =
@@ -197,7 +199,7 @@
 	else if (rc >= (int)sizeof(fn))
 		rc = ENAMETOOLONG;
 	else
-		rc = mdsio_unlink(mds_upschdir_inum, NULL, fn,
+		rc = mdsio_unlink(current_vfsid, mds_upschdir_inum[current_vfsid], NULL, fn,
 		    &rootcreds, NULL, NULL);
 	if (rc)
 		psclog_error("trying to remove upsch link: %s",
@@ -665,7 +667,7 @@
 				dst_res = psc_dynarray_getpos(
 				    &site->site_resources,
 				    dst_res_i.ri_rnd_idx);
-				iosidx = mds_repl_ios_lookup(
+				iosidx = mds_repl_ios_lookup(current_vfsid,
 				    USWI_INOH(wk), dst_res->res_id);
 				if (iosidx < 0)
 					continue;
@@ -1103,7 +1105,7 @@
 	uint32_t j;
 	void *data;
 
-	rc = mdsio_opendir(mds_upschdir_inum, &rootcreds, NULL, &data);
+	rc = mdsio_opendir(current_vfsid, mds_upschdir_inum[current_vfsid], &rootcreds, NULL, &data);
 	if (rc)
 		psc_fatalx("mdsio_opendir %s: %s", SL_RPATH_UPSCH_DIR,
 		    slstrerror(rc));
@@ -1113,7 +1115,7 @@
 	buf = PSCALLOC(siz);
 
 	for (;;) {
-		rc = mdsio_readdir(&rootcreds, siz,
+		rc = mdsio_readdir(current_vfsid, &rootcreds, siz,
 			   off, buf, &tsiz, NULL, NULL, 0, data);
 		if (rc)
 			psc_fatalx("mdsio_readdir %s: %s",
@@ -1143,7 +1145,7 @@
 				/* XXX if ENOENT, remove from repldir and continue */
 				psclog_errorx("mds_repl_loadino: %s",
 				    slstrerror(rc));
-				mdsio_unlink(mds_upschdir_inum, NULL, fn,
+				mdsio_unlink(current_vfsid, mds_upschdir_inum[current_vfsid], NULL, fn,
 				    &rootcreds, NULL, NULL);
 				continue;
 			}
@@ -1199,7 +1201,7 @@
 		}
 		off += tsiz;
 	}
-	rc = mdsio_release(&rootcreds, data);
+	rc = mdsio_release(current_vfsid, &rootcreds, data);
 	if (rc)
 		psc_fatalx("mdsio_release %s: %s", SL_RPATH_UPSCH_DIR,
 		    slstrerror(rc));
@@ -1241,12 +1243,12 @@
 		goto out;
 	}
 
-	rc = mdsio_opencreatef(mds_upschdir_inum, &rootcreds,
+	rc = mdsio_opencreatef(current_vfsid, mds_upschdir_inum[current_vfsid], &rootcreds,
 	    O_CREAT | O_WRONLY, MDSIO_OPENCRF_NOLINK, 0600, fn,
 	    NULL, NULL, &mdsio_data, NULL, uswi_getslfid, 0);
 	if (rc)
 		goto out;
-	mdsio_release(&rootcreds, mdsio_data);
+	mdsio_release(current_vfsid, &rootcreds, mdsio_data);
 
 	UPSCHED_MGR_LOCK();
 	*wkp = uswi_find(fgp);
Index: slash_nara/slashd/repl_mds.c
===================================================================
--- slash_nara/slashd/repl_mds.c	(revision 19179)
+++ slash_nara/slashd/repl_mds.c	(working copy)
@@ -62,6 +62,8 @@
 int			 repl_busytable_nents;
 psc_spinlock_t		 repl_busytable_lock = SPINLOCK_INIT;
 
+extern int current_vfsid;
+
 __static int
 iosidx_cmp(const void *a, const void *b)
 {
@@ -98,7 +100,7 @@
 SPLAY_GENERATE(upschedtree, up_sched_work_item, uswi_tentry, uswi_cmp);
 
 int
-_mds_repl_ios_lookup(struct slash_inode_handle *ih, sl_ios_id_t ios,
+_mds_repl_ios_lookup(int vfsid, struct slash_inode_handle *ih, sl_ios_id_t ios,
     int add, int log)
 {
 	int locked, rc = -ENOENT, inox_rc = 0;
@@ -166,7 +168,7 @@
 		DEBUG_INOH(PLL_INFO, ih, "add IOS(%u) to repls, index %d",
 		    ios, j);
 
-		mds_inodes_odsync(ih->inoh_fcmh, mdslog_ino_repls);
+		mds_inodes_odsync(vfsid, ih->inoh_fcmh, mdslog_ino_repls);
 
 		rc = j;
 	}
@@ -175,20 +177,20 @@
 	return (inox_rc ? inox_rc : rc);
 }
 
-#define mds_repl_iosv_lookup(ih, ios, iosidx, nios)			\
-	_mds_repl_iosv_lookup((ih), (ios), (iosidx), (nios), 0)
+#define mds_repl_iosv_lookup(vfsid, ih, ios, iosidx, nios)			\
+	_mds_repl_iosv_lookup((vfsid), (ih), (ios), (iosidx), (nios), 0)
 
-#define mds_repl_iosv_lookup_add(ih, ios, iosidx, nios)			\
-	_mds_repl_iosv_lookup((ih), (ios), (iosidx), (nios), 1)
+#define mds_repl_iosv_lookup_add(vfsid, ih, ios, iosidx, nios)			\
+	_mds_repl_iosv_lookup((vfsid), (ih), (ios), (iosidx), (nios), 1)
 
 __static int
-_mds_repl_iosv_lookup(struct slash_inode_handle *ih,
+_mds_repl_iosv_lookup(int vfsid, struct slash_inode_handle *ih,
     const sl_replica_t iosv[], int iosidx[], int nios, int add)
 {
 	int k, last;
 
 	for (k = 0; k < nios; k++)
-		if ((iosidx[k] = _mds_repl_ios_lookup(ih,
+		if ((iosidx[k] = _mds_repl_ios_lookup(vfsid, ih,
 		    iosv[k].bs_id, add, add)) < 0)
 			return (-iosidx[k]);
 
@@ -521,7 +523,7 @@
 	slm_iosv_setbusy(iosv, nios);
 
 	/* Find/add our replica's IOS ID */
-	rc = mds_repl_iosv_lookup_add(USWI_INOH(wk), iosv, iosidx,
+	rc = mds_repl_iosv_lookup_add(current_vfsid, USWI_INOH(wk), iosv, iosidx,
 	    nios);
 	if (rc)
 		goto out;
@@ -644,7 +646,7 @@
 	slm_iosv_setbusy(iosv, nios);
 
 	/* Find replica IOS indexes */
-	rc = mds_repl_iosv_lookup(USWI_INOH(wk), iosv, iosidx, nios);
+	rc = mds_repl_iosv_lookup(current_vfsid, USWI_INOH(wk), iosv, iosidx, nios);
 	if (rc)
 		goto out;
 
@@ -845,7 +847,7 @@
 			continue;
 		PLL_ULOCK(&upsched_listhd);
 
-		iosidx = mds_repl_ios_lookup(USWI_INOH(wk), resid);
+		iosidx = mds_repl_ios_lookup(current_vfsid, USWI_INOH(wk), resid);
 		if (iosidx < 0)
 			goto end;
 
Index: slash_nara/slashd/repl_mds.h
===================================================================
--- slash_nara/slashd/repl_mds.h	(revision 19179)
+++ slash_nara/slashd/repl_mds.h	(working copy)
@@ -60,7 +60,7 @@
 int	 mds_repl_delrq(const struct slash_fidgen *, sl_bmapno_t, sl_replica_t *, int);
 void	 mds_repl_init(void);
 int	 mds_repl_inv_except(struct bmapc_memb *, int);
-int	_mds_repl_ios_lookup(struct slash_inode_handle *, sl_ios_id_t, int, int);
+int	_mds_repl_ios_lookup(int, struct slash_inode_handle *, sl_ios_id_t, int, int);
 int	 mds_repl_loadino(const struct slash_fidgen *, struct fidc_membh **);
 void	 mds_repl_node_clearallbusy(struct sl_resm *);
 int64_t mds_repl_nodes_adjbusy(struct sl_resm *, struct sl_resm *, int64_t);
@@ -117,8 +117,8 @@
 
 #define mds_repl_nodes_clearbusy(a, b)		 mds_repl_nodes_adjbusy((a), (b), INT64_MIN)
 
-#define mds_repl_ios_lookup_add(ih, iosid, log)	_mds_repl_ios_lookup((ih), (iosid), 1, (log))
-#define mds_repl_ios_lookup(ih, iosid)		_mds_repl_ios_lookup((ih), (iosid), 0, 0)
+#define mds_repl_ios_lookup_add(vfsid, ih, iosid, log)	_mds_repl_ios_lookup((vfsid), (ih), (iosid), 1, (log))
+#define mds_repl_ios_lookup(vfsid, ih, iosid)		_mds_repl_ios_lookup((vfsid), (ih), (iosid), 0, 0)
 
 extern struct psc_listcache	 slm_replst_workq;
 
Index: slash_nara/slashd/odtable_mds.c
===================================================================
--- slash_nara/slashd/odtable_mds.c	(revision 19179)
+++ slash_nara/slashd/odtable_mds.c	(working copy)
@@ -35,6 +35,8 @@
 
 #include "odtable_mds.h"
 
+extern int current_vfsid;
+
 struct psc_lockedlist psc_odtables =
     PLL_INIT(&psc_odtables, struct odtable, odt_lentry);
 
@@ -63,7 +65,7 @@
 		/* XXX either trust the bitmap or initialize the footer of new items */
 
 		odt->odt_hdr->odth_nelems = psc_vbitmap_getsize(odt->odt_bitmap);
-		rc = mdsio_write(&rootcreds, &odt->odt_hdr,
+		rc = mdsio_write(current_vfsid, &rootcreds, &odt->odt_hdr,
 		    sizeof(struct odtable_hdr), &nb, 0, 0,
 		    odt->odt_handle, NULL, NULL);
 		psc_assert(!rc && nb == sizeof(struct odtable_hdr));
@@ -97,7 +99,7 @@
 	odtr->odtr_elem = elem;
 	odtr->odtr_key = crc;
 
-	rc = mdsio_write(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_write(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + elem * odt->odt_hdr->odth_slotsz,
 	    0, odt->odt_handle, NULL, NULL);
 	psc_assert(!rc && nb == odt->odt_hdr->odth_slotsz);
@@ -120,7 +122,7 @@
 	psc_assert(odtr->odtr_elem <= odt->odt_hdr->odth_nelems - 1);
 
 	p = PSCALLOC(odt->odt_hdr->odth_slotsz);
-	rc = mdsio_read(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_read(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + odtr->odtr_elem *
 	    odt->odt_hdr->odth_slotsz, odt->odt_handle);
 	if (nb != odt->odt_hdr->odth_slotsz) {
@@ -167,7 +169,7 @@
 	psc_assert(len <= odt->odt_hdr->odth_elemsz);
 
 	p = PSCALLOC(odt->odt_hdr->odth_slotsz);
-	rc = mdsio_read(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_read(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + odtr->odtr_elem *
 	    odt->odt_hdr->odth_slotsz, odt->odt_handle);
 
@@ -183,7 +185,7 @@
 
 	psclog_info("slot=%zd elemcrc=%"PSCPRIxCRC64, odtr->odtr_elem, crc);
 
-	rc = mdsio_write(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_write(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + odtr->odtr_elem *
 	    odt->odt_hdr->odth_slotsz, 0, odt->odt_handle, NULL, NULL);
 	psc_assert(!rc && nb == odt->odt_hdr->odth_slotsz);
@@ -206,7 +208,7 @@
 	struct odtable_entftr *odtf;
 
 	p = PSCALLOC(odt->odt_hdr->odth_slotsz);
-	rc = mdsio_read(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_read(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + odtr->odtr_elem *
 	    odt->odt_hdr->odth_slotsz, odt->odt_handle);
 
@@ -218,7 +220,7 @@
 	psc_vbitmap_unset(odt->odt_bitmap, odtr->odtr_elem);
 	freelock(&odt->odt_lock);
 
-	rc = mdsio_write(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_write(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + odtr->odtr_elem *
 	    odt->odt_hdr->odth_slotsz, 0, odt->odt_handle, NULL, NULL);
 	psc_assert(!rc && nb == odt->odt_hdr->odth_slotsz);
@@ -249,15 +251,15 @@
 
 	INIT_SPINLOCK(&odt->odt_lock);
 
-	rc = mdsio_lookup(mds_metadir_inum, fn, &mf, &rootcreds, NULL);
+	rc = mdsio_lookup(current_vfsid, mds_metadir_inum[current_vfsid], fn, &mf, &rootcreds, NULL);
 	psc_assert(rc == 0);
 
-	rc = mdsio_opencreate(mf, &rootcreds, O_RDWR, 0, NULL, NULL,
+	rc = mdsio_opencreate(current_vfsid, mf, &rootcreds, O_RDWR, 0, NULL, NULL,
 	    NULL, &odt->odt_handle, NULL, NULL, 0);
 	psc_assert(!rc && odt->odt_handle);
 
 	odth = PSCALLOC(sizeof(*odth));
-	rc = mdsio_read(&rootcreds, odth, sizeof(*odth), &nb, 0,
+	rc = mdsio_read(current_vfsid, &rootcreds, odth, sizeof(*odth), &nb, 0,
 	    odt->odt_handle);
 	odt->odt_hdr = odth;
 	psc_assert(rc == 0 && nb == sizeof(*odth));
@@ -276,7 +278,7 @@
 
 	p = PSCALLOC(odth->odth_slotsz);
 	for (i = 0; i < odth->odth_nelems; i++) {
-		rc = mdsio_read(&rootcreds, p,
+		rc = mdsio_read(current_vfsid, &rootcreds, p,
 		    odth->odth_slotsz, &nb,
 		    odth->odth_start + i *
 		    odth->odth_slotsz, odt->odt_handle);
@@ -338,8 +340,8 @@
 	odt->odt_bitmap = NULL;
 
 	PSCFREE(odt->odt_hdr);
-	mdsio_fsync(&rootcreds, 0, odt->odt_handle);
-	mdsio_release(&rootcreds, odt->odt_handle);
+	mdsio_fsync(current_vfsid, &rootcreds, 0, odt->odt_handle);
+	mdsio_release(current_vfsid, &rootcreds, odt->odt_handle);
 	PSCFREE(odt);
 }
 
@@ -362,7 +364,7 @@
 			odtr = PSCALLOC(sizeof(*odtr));
 		if (!psc_vbitmap_get(odt->odt_bitmap, i))
 			continue;
-		rc = mdsio_read(&rootcreds, p,
+		rc = mdsio_read(current_vfsid, &rootcreds, p,
 		    odt->odt_hdr->odth_slotsz, &nb,
 		    odt->odt_hdr->odth_start + i *
 		    odt->odt_hdr->odth_slotsz, odt->odt_handle);
Index: slash_nara/slashd/mdsio.h
===================================================================
--- slash_nara/slashd/mdsio.h	(revision 19179)
+++ slash_nara/slashd/mdsio.h	(working copy)
@@ -26,6 +26,7 @@
 
 #include "fid.h"
 #include "sltypes.h"
+#include "pfl/hashtbl.h"
 
 struct statvfs;
 struct iovec;
@@ -38,6 +39,7 @@
 
 typedef uint64_t mdsio_fid_t;
 
+
 struct mdsio_fh {
 	void *fh;
 };
@@ -59,14 +61,14 @@
 #define MDSIO_OPENCRF_NOLINK	(1 << 0)	/* do not create links in FID namespace */
 #define MDSIO_OPENCRF_NOMTIM	(1 << 1)	/* do not update st_mtim */
 
-#define mdsio_opencreate(pino, crp, fflags, mode, fn, mfp, sstb,	\
+#define mdsio_opencreate(vfs, pino, crp, fflags, mode, fn, mfp, sstb,	\
 	    mdsio_datap, logfunc, getslfid, slfid)			\
-	mdsio_opencreatef((pino), (crp), (fflags), 0, (mode), (fn),	\
+	mdsio_opencreatef((vfs), (pino), (crp), (fflags), 0, (mode), (fn),	\
 	    (mfp), (sstb), (mdsio_datap), (logfunc), (getslfid), (slfid))
 
 /* high-level interface */
 int	mdsio_fcmh_refreshattr(struct fidc_membh *, struct srt_stat *);
-int	mdsio_write_cursor(void *, size_t, void *, sl_log_write_t);
+int	mdsio_write_cursor(int, void *, size_t, void *, sl_log_write_t);
 
 struct mdsio_ops {
 	/* control interface */
@@ -78,40 +80,48 @@
 	uint	(*mio_slflags_2_setattrmask)(int);
 
 	/* low-level file system interface */
-	int	(*mio_access)(mdsio_fid_t, int, const struct slash_creds *);
-	int	(*mio_fsync)(const struct slash_creds *, int, void *);
-	int	(*mio_getattr)(mdsio_fid_t, void *, const struct slash_creds *, struct srt_stat *);
-	int	(*mio_link)(mdsio_fid_t, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, sl_log_update_t);
-	int	(*mio_lookup)(mdsio_fid_t, const char *, mdsio_fid_t *, const struct slash_creds *, struct srt_stat *);
-	int	(*mio_lookup_slfid)(slfid_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *);
-	int	(*mio_mkdir)(mdsio_fid_t, const char *, const struct srt_stat *, int, int, struct srt_stat *, mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
-	int	(*mio_mknod)(mdsio_fid_t, const char *, mode_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t);
-	int	(*mio_opencreatef)(mdsio_fid_t, const struct slash_creds *, int, int, mode_t, const char *, mdsio_fid_t *, struct srt_stat *, void *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
-	int	(*mio_opendir)(mdsio_fid_t, const struct slash_creds *, struct slash_fidgen *, void *);
-	int	(*mio_preadv)(const struct slash_creds *, struct iovec *, int, size_t *, off_t, void *);
-	int	(*mio_pwritev)(const struct slash_creds *, const struct iovec *, int, size_t *, off_t, int, void *, sl_log_write_t, void *);
-	int	(*mio_read)(const struct slash_creds *, void *, size_t, size_t *, off_t, void *);
-	int	(*mio_readdir)(const struct slash_creds *, size_t, off_t, void *, size_t *, size_t *, void *, int, void *);
-	int	(*mio_readlink)(mdsio_fid_t, char *, const struct slash_creds *);
-	int	(*mio_release)(const struct slash_creds *, void *);
-	int	(*mio_rename)(mdsio_fid_t, const char *, mdsio_fid_t, const char *, const struct slash_creds *, sl_log_update_t, void *);
-	int	(*mio_rmdir)(mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t);
-	int	(*mio_setattr)(mdsio_fid_t, const struct srt_stat *, int, const struct slash_creds *, struct srt_stat *, void *, sl_log_update_t);
-	int	(*mio_statfs)(struct statvfs *);
-	int	(*mio_symlink)(const char *, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *, sl_getslfid_cb_t, sl_log_update_t);
-	int	(*mio_unlink)(mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t, void *);
-	int	(*mio_write)(const struct slash_creds *, const void *, size_t, size_t *, off_t, int, void *, sl_log_write_t, void *);
+	int	(*mio_access)(int, mdsio_fid_t, int, const struct slash_creds *);
+	int	(*mio_fsync)(int, const struct slash_creds *, int, void *);
+	int	(*mio_getattr)(int, mdsio_fid_t, void *, const struct slash_creds *, struct srt_stat *);
+	int	(*mio_link)(int, mdsio_fid_t, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, sl_log_update_t);
+	int	(*mio_lookup)(int, mdsio_fid_t, const char *, mdsio_fid_t *, const struct slash_creds *, struct srt_stat *);
+	int	(*mio_lookup_slfid)(int, slfid_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *);
+	int	(*mio_mkdir)(int, mdsio_fid_t, const char *, const struct srt_stat *, int, int, struct srt_stat *, mdsio_fid_t *, \
+			sl_log_update_t, sl_getslfid_cb_t, slfid_t);
+	int	(*mio_mknod)(int, mdsio_fid_t, const char *, mode_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *, \
+			sl_log_update_t, sl_getslfid_cb_t);
+	int	(*mio_opencreatef)(int, mdsio_fid_t, const struct slash_creds *, int, int, mode_t, const char *, mdsio_fid_t *, \
+			struct srt_stat *, void *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
+	int	(*mio_opendir)(int, mdsio_fid_t, const struct slash_creds *, struct slash_fidgen *, void *);
+	int	(*mio_preadv)(int, const struct slash_creds *, struct iovec *, int, size_t *, off_t, void *);
+	int	(*mio_pwritev)(int, const struct slash_creds *, const struct iovec *, int, size_t *, off_t, int, void *, \
+			sl_log_write_t, void *);
+	int	(*mio_read)(int, const struct slash_creds *, void *, size_t, size_t *, off_t, void *);
+	int	(*mio_readdir)(int, const struct slash_creds *, size_t, off_t, void *, size_t *, size_t *, void *, int, void *);
+	int	(*mio_readlink)(int, mdsio_fid_t, char *, const struct slash_creds *);
+	int	(*mio_release)(int, const struct slash_creds *, void *);
+	int	(*mio_rename)(int, mdsio_fid_t, const char *, mdsio_fid_t, const char *, const struct slash_creds *, \
+			sl_log_update_t, void *);
+	int	(*mio_rmdir)(int, mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t);
+	int	(*mio_setattr)(int, mdsio_fid_t, const struct srt_stat *, int, const struct slash_creds *, struct srt_stat *, \
+			void *, sl_log_update_t);
+	int	(*mio_statfs)(int, struct statvfs *);
+	int	(*mio_symlink)(int, const char *, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, \
+			mdsio_fid_t *, sl_getslfid_cb_t, sl_log_update_t);
+	int	(*mio_unlink)(int, mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t, void *);
+	int	(*mio_write)(int, const struct slash_creds *, const void *, size_t, size_t *, off_t, int, void *, \
+			sl_log_write_t, void *);
 
 	/* replay interface */
-	int	(*mio_redo_create)(slfid_t, char *, struct srt_stat *);
-	int	(*mio_redo_fidlink)(slfid_t, const struct slash_creds *);
-	int	(*mio_redo_link)(slfid_t, slfid_t, char *, struct srt_stat *);
-	int	(*mio_redo_mkdir)(slfid_t, char *, struct srt_stat *);
-	int	(*mio_redo_rename)(slfid_t, const char *, slfid_t, const char *, struct srt_stat *);
-	int	(*mio_redo_rmdir)(slfid_t, slfid_t, char *);
-	int	(*mio_redo_setattr)(slfid_t, uint, struct srt_stat *);
-	int	(*mio_redo_symlink)(slfid_t, slfid_t, char *, char *, struct srt_stat *);
-	int	(*mio_redo_unlink)(slfid_t, slfid_t, char *);
+	int	(*mio_redo_create)(int, slfid_t, char *, struct srt_stat *);
+	int	(*mio_redo_fidlink)(int,slfid_t, const struct slash_creds *);
+	int	(*mio_redo_link)(int, slfid_t, slfid_t, char *, struct srt_stat *);
+	int	(*mio_redo_mkdir)(int, slfid_t, char *, struct srt_stat *);
+	int	(*mio_redo_rename)(int, slfid_t, const char *, slfid_t, const char *, struct srt_stat *);
+	int	(*mio_redo_rmdir)(int, slfid_t, slfid_t, char *);
+	int	(*mio_redo_setattr)(int, slfid_t, uint, struct srt_stat *);
+	int	(*mio_redo_symlink)(int, slfid_t, slfid_t, char *, char *, struct srt_stat *);
+	int	(*mio_redo_unlink)(int, slfid_t, slfid_t, char *);
 };
 
 #define mdsio_init		mdsio_ops.mio_init			/* zfsslash2_init() */
@@ -155,9 +165,15 @@
 #define mdsio_redo_unlink	mdsio_ops.mio_redo_unlink		/* zfsslash2_replay_unlink() */
 
 extern struct mdsio_ops	mdsio_ops;
-extern mdsio_fid_t	mds_upschdir_inum;
-extern mdsio_fid_t	mds_metadir_inum;
-extern mdsio_fid_t	mds_fidnsdir_inum;
-extern mdsio_fid_t	mds_tmpdir_inum;
+extern mdsio_fid_t	mds_upschdir_inum[];
+extern mdsio_fid_t	mds_metadir_inum[];
+extern mdsio_fid_t	mds_fidnsdir_inum[];
+extern mdsio_fid_t	mds_tmpdir_inum[];
 
+struct rootNames {
+	char			 rn_name[MAXPATHLEN];
+	int			 rn_vfsid;
+	struct psc_hashent	 rn_hentry;
+};
+
 #endif
Index: slash_nara/slashd/bmap_mds.c
===================================================================
--- slash_nara/slashd/bmap_mds.c	(revision 19179)
+++ slash_nara/slashd/bmap_mds.c	(working copy)
@@ -31,6 +31,8 @@
 #include "slerr.h"
 #include "up_sched_res.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 static __inline void *
 bmap_2_mdsio_data(struct bmapc_memb *b)
 {
@@ -102,13 +104,17 @@
 	uint64_t crc, od_crc = 0;
 	struct iovec iovs[2];
 	size_t nb;
-	int rc;
+	int rc, vfsid;
+	struct fidc_membh *fcmh;
 
 	iovs[0].iov_base = bmap_2_ondisk(b);
 	iovs[0].iov_len = BMAP_OD_CRCSZ;
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb,
+
+	fcmh = b->bcm_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb,
 	    (off_t)BMAP_OD_SZ * b->bcm_bmapno + SL_BMAP_START_OFF,
 	    bmap_2_mdsio_data(b));
 
@@ -214,6 +220,8 @@
 	int locked, rc, new;
 	uint64_t crc;
 	size_t nb;
+	struct fidc_membh *fcmh;
+	int vfsid;
 
 	BMAPOD_REQRDLOCK(bmap_2_bmi(b));
 	if (BMAP_HASLOCK(b))
@@ -229,7 +237,9 @@
 
 	if (logf)
 		mds_reserve_slot(1);
-	rc = mdsio_pwritev(&rootcreds, iovs, nitems(iovs), &nb,
+	fcmh = b->bcm_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_pwritev(vfsid, &rootcreds, iovs, nitems(iovs), &nb,
 	    (off_t)BMAP_OD_SZ * b->bcm_bmapno + SL_BMAP_START_OFF,
 	    update_mtime, bmap_2_mdsio_data(b), logf, logarg);
 	if (logf)
@@ -294,18 +304,23 @@
 	struct srt_stat sstb;
 	uint32_t i;
 	sl_ios_id_t iosid;
-	int fl, idx;
+	int fl, idx, vfsid;
 
 	psc_assert(bmap->bcm_flags & BMAP_MDS_CRC_UP);
 
 	f = bmap->bcm_fcmh;
 	ih = fcmh_2_inoh(f);
 
+	if (mdsio_fid_to_vfsid(fcmh_2_fid(f), &vfsid) < 0)
+		return (EINVAL);
+	if (vfsid != current_vfsid)
+		return (EINVAL);
+
 	FCMH_LOCK(f);
 	fcmh_wait_locked(f, f->fcmh_flags & FCMH_IN_SETATTR);
 
 	iosid = bmi->bmdsi_wr_ion->rmmi_resm->resm_res_id;
-	idx = mds_repl_ios_lookup(ih, iosid);
+	idx = mds_repl_ios_lookup(vfsid, ih, iosid);
 	if (idx < 0)
 		psc_fatal("not found");
 	sstb.sst_blocks = fcmh_2_nblks(f) + crcup->nblks -
@@ -313,13 +328,13 @@
 	fl = SL_SETATTRF_NBLKS;
 
 	/* use nolog because mdslog_bmap_crc will cover this */
-	mds_fcmh_setattr_nolog(f, fl, &sstb);
+	mds_fcmh_setattr_nolog(vfsid, f, fl, &sstb);
 
 	fcmh_set_repl_nblks(f, idx, crcup->nblks);
 	if (idx >= SL_DEF_REPLICAS)
-		mds_inox_write(ih, NULL, NULL);
+		mds_inox_write(vfsid, ih, NULL, NULL);
 	else
-		mds_inode_write(ih, NULL, NULL);
+		mds_inode_write(vfsid, ih, NULL, NULL);
 
 	FCMH_ULOCK(f);
 
Index: slash_nara/slashd/mds.c
===================================================================
--- slash_nara/slashd/mds.c	(revision 19179)
+++ slash_nara/slashd/mds.c	(working copy)
@@ -46,6 +46,8 @@
 #include "slerr.h"
 #include "up_sched_res.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 struct odtable	*mdsBmapAssignTable;
 uint64_t	 mdsBmapSequenceNo;
 
@@ -455,7 +457,7 @@
 
 	psc_assert(b->bcm_flags & BMAP_IONASSIGN);
 
-	iosidx = mds_repl_ios_lookup_add(ih, bia->bia_ios, 0);
+	iosidx = mds_repl_ios_lookup_add(current_vfsid, ih, bia->bia_ios, 0);
 	if (iosidx < 0)
 		psc_fatalx("ios_lookup_add %d: %s", bia->bia_ios,
 		   slstrerror(iosidx));
@@ -1328,8 +1330,13 @@
 	struct bmap_mds_info *bmi;
 	struct fidc_membh *fcmh;
 	struct sl_resource *res = libsl_id2res(ios);
-	int rc;
+	int rc, vfsid;
 
+	if (mdsio_fid_to_vfsid(c->fg.fg_fid, &vfsid) < 0)
+		return (-EINVAL);
+	if (vfsid != current_vfsid)
+		return (-EINVAL);
+
 	rc = slm_fcmh_get(&c->fg, &fcmh);
 	if (rc) {
 		if (rc == ENOENT) {
@@ -1426,7 +1433,7 @@
 		uint32_t bpol;
 
 		ih = fcmh_2_inoh(fcmh);
-		iosidx = mds_repl_ios_lookup(ih,
+		iosidx = mds_repl_ios_lookup(vfsid, ih,
 		    bmi->bmdsi_wr_ion->rmmi_resm->resm_res_id);
 		if (iosidx < 0)
 			psclog_errorx("ios not found");
@@ -1481,7 +1488,7 @@
 		    FCMH_IN_SETATTR);
 		sstb.sst_mode = fcmh->fcmh_sstb.sst_mode &
 		    ~(S_ISGID | S_ISUID);
-		mds_fcmh_setattr_nolog(fcmh, PSCFS_SETATTRF_MODE,
+		mds_fcmh_setattr_nolog(vfsid, fcmh, PSCFS_SETATTRF_MODE,
 		    &sstb);
 		FCMH_ULOCK(fcmh);
 	}
@@ -1957,7 +1964,7 @@
 			struct srt_stat sstb;
 
 			sstb.sst_size = fmi->fmi_ptrunc_size;
-			mds_fcmh_setattr_nolog(fcmh,
+			mds_fcmh_setattr_nolog(current_vfsid, fcmh,
 			    PSCFS_SETATTRF_DATASIZE, &sstb);
 		}
 		fcmh->fcmh_flags &= ~FCMH_IN_PTRUNC;
@@ -2013,7 +2020,7 @@
 	fcmh->fcmh_sstb.sst_size = fmi->fmi_ptrunc_size;
 
 	mds_reserve_slot(1);
-	rc = mdsio_setattr(fcmh_2_mdsio_fid(fcmh), &fcmh->fcmh_sstb,
+	rc = mdsio_setattr(current_vfsid, fcmh_2_mdsio_fid(fcmh), &fcmh->fcmh_sstb,
 	    to_set, &rootcreds, &fcmh->fcmh_sstb,
 	    fcmh_2_mdsio_data(fcmh), mdslog_namespace);
 	mds_unreserve_slot(1);
Index: slash_nara/slashd/slashd.h
===================================================================
--- slash_nara/slashd/slashd.h	(revision 19179)
+++ slash_nara/slashd/slashd.h	(working copy)
@@ -245,7 +245,7 @@
 extern struct sl_mds_nsstats	 slm_nsstats_aggr;	/* aggregate namespace stats */
 extern struct sl_mds_peerinfo	*localinfo;
 
-extern uint64_t			 slm_fsuuid;
+extern uint64_t			 slm_fsuuid[];
 extern struct psc_poolmgr	*slm_workrq_pool;
 extern struct psc_listcache	 slm_workq;
 extern struct psc_thread	*slmconnthr;
@@ -265,4 +265,6 @@
 	return (n);
 }
 
+void psc_scan_filesystems(void);
+
 #endif /* _SLASHD_H_ */
Index: slash_nara/slashd/rpc_mds.c
===================================================================
--- slash_nara/slashd/rpc_mds.c	(revision 19179)
+++ slash_nara/slashd/rpc_mds.c	(working copy)
@@ -34,10 +34,14 @@
 #include "slashd.h"
 #include "slashrpc.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 struct pscrpc_svc_handle slm_rmi_svc;
 struct pscrpc_svc_handle slm_rmm_svc;
 struct pscrpc_svc_handle slm_rmc_svc;
 
+extern int current_vfsid;
+
 void
 slm_rpc_initsvc(void)
 {
@@ -191,7 +195,7 @@
 	if (rq->rq_reqmsg->opc == SRMT_CONNECT) {
 		struct srm_connect_req *mq = *(void **)mqp;
 
-		mq->fsuuid = slm_fsuuid;
+		mq->fsuuid = zfsMount[current_vfsid].uuid;
 	}
 #endif
 	if (csvc->csvc_peertype == SLCONNT_IOD)
@@ -234,7 +238,7 @@
 	if (rc == 0 && rq->rq_reqmsg->opc == SRMT_CONNECT) {
 		struct srm_connect_rep *mp = *(void **)mpp;
 
-		mp->fsuuid = slm_fsuuid;
+		mp->fsuuid = zfsMount[current_vfsid].uuid;
 	}
 	return (rc);
 }
Index: slash_nara/slashd/ino_compat.c
===================================================================
--- slash_nara/slashd/ino_compat.c	(revision 19179)
+++ slash_nara/slashd/ino_compat.c	(working copy)
@@ -32,8 +32,12 @@
 #include "slashd.h"
 #include "slerr.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
+extern int current_vfsid;
+
 int
-mds_inode_dump(struct sl_ino_compat *sic, struct slash_inode_handle *ih,
+mds_inode_dump(int vfsid, struct sl_ino_compat *sic, struct slash_inode_handle *ih,
     void *readh)
 {
 	struct fidc_membh *f;
@@ -80,26 +84,27 @@
 			return (rc);
 	}
 
-	rc = mds_inox_write(ih, NULL, NULL);
+	rc = mds_inox_write(vfsid, ih, NULL, NULL);
 	if (rc)
 		return (rc);
 
-	rc = mds_inode_write(ih, NULL, NULL);
+	rc = mds_inode_write(vfsid, ih, NULL, NULL);
 	if (rc)
 		return (rc);
 
-	mdsio_fsync(&rootcreds, 1, th);
+	mdsio_fsync(vfsid, &rootcreds, 1, th);
 	return (0);
 }
 
 int
-mds_inode_update(struct slash_inode_handle *ih, int old_version)
+mds_inode_update(int vfsid, struct slash_inode_handle *ih, int old_version)
 {
 	char fn[NAME_MAX + 1];
 	struct sl_ino_compat *sic;
 	struct srt_stat sstb;
 	void *h = NULL, *th;
 	int rc;
+	struct fidc_membh	*fcmh;
 
 	sic = &sl_ino_compat_table[old_version];
 	rc = sic->sic_read_ino(ih);
@@ -108,11 +113,12 @@
 	DEBUG_INOH(PLL_INFO, ih, "updating old inode (v %d)",
 	    old_version);
 
+	fcmh = ih->inoh_fcmh;
 	snprintf(fn, sizeof(fn), "%016"PRIx64".update",
-	    fcmh_2_fid(ih->inoh_fcmh));
-	rc = mdsio_opencreatef(mds_tmpdir_inum, &rootcreds, O_RDWR |
-	    O_CREAT | O_TRUNC, MDSIO_OPENCRF_NOLINK, 0644, fn, NULL,
-	    NULL, &h, NULL, NULL, 0);
+	    fcmh_2_fid(fcmh));
+	rc = mdsio_opencreatef(vfsid, mds_tmpdir_inum[vfsid], 
+		&rootcreds, O_RDWR | O_CREAT | O_TRUNC, MDSIO_OPENCRF_NOLINK, 0644, fn, NULL, 
+		NULL, &h, NULL, NULL, 0);
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
@@ -127,30 +133,30 @@
 
 	th = inoh_2_mdsio_data(ih);
 	inoh_2_mdsio_data(ih) = h;
-	rc = mds_inode_dump(sic, ih, th);
+	rc = mds_inode_dump(vfsid, sic, ih, th);
 	inoh_2_mdsio_data(ih) = th;
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
 	/* move new structures to inode meta file */
 	memset(&sstb, 0, sizeof(sstb));
-	rc = mdsio_setattr(0, &sstb, SL_SETATTRF_METASIZE, &rootcreds,
+	rc = mdsio_setattr(vfsid, 0, &sstb, SL_SETATTRF_METASIZE, &rootcreds,
 	    NULL, th, NULL);
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
 //	mdsio_rename(mds_tmpdir_inum, NULL, fn, &rootcreds, NULL);
-	rc = mds_inode_dump(NULL, ih, h);
+	rc = mds_inode_dump(vfsid, NULL, ih, h);
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
-	mdsio_unlink(mds_tmpdir_inum, NULL, fn, &rootcreds, NULL, NULL);
+	mdsio_unlink(vfsid, mds_tmpdir_inum[vfsid], NULL, fn, &rootcreds, NULL, NULL);
 
  out:
 	if (h)
-		mdsio_release(&rootcreds, h);
+		mdsio_release(vfsid, &rootcreds, h);
 	if (rc) {
-		mdsio_unlink(mds_tmpdir_inum, NULL, fn, &rootcreds,
+		mdsio_unlink(vfsid, mds_tmpdir_inum[vfsid], NULL, fn, &rootcreds,
 		    NULL, NULL);
 		DEBUG_INOH(PLL_ERROR, ih, "error updating old inode "
 		    "rc=%d", rc);
@@ -159,7 +165,7 @@
 }
 
 int
-mds_inode_update_interrupted(struct slash_inode_handle *ih, int *rc)
+mds_inode_update_interrupted(int vfsid, struct slash_inode_handle *ih, int *rc)
 {
 	char fn[NAME_MAX + 1];
 	struct srt_stat sstb;
@@ -169,17 +175,24 @@
 	mdsio_fid_t inum;
 	int exists = 0;
 	size_t nb;
+	struct fidc_membh *fcmh;
 
+	fcmh = ih->inoh_fcmh;
+	if (vfsid != current_vfsid) {
+		*rc = EINVAL;
+		PFL_GOTOERR(out, *rc);
+	}
+	
 	th = inoh_2_mdsio_data(ih);
 
 	snprintf(fn, sizeof(fn), "%016"PRIx64".update",
 	    fcmh_2_fid(ih->inoh_fcmh));
 
-	*rc = mdsio_lookup(mds_tmpdir_inum, fn, &inum, &rootcreds, NULL);
+	*rc = mdsio_lookup(vfsid, mds_tmpdir_inum[vfsid], fn, &inum, &rootcreds, NULL);
 	if (*rc)
 		PFL_GOTOERR(out, *rc);
 
-	*rc = mdsio_opencreatef(inum, &rootcreds, O_RDONLY,
+	*rc = mdsio_opencreatef(vfsid, inum, &rootcreds, O_RDONLY,
 	    MDSIO_OPENCRF_NOLINK, 0644, NULL, NULL, NULL, &h, NULL,
 	    NULL, 0);
 	if (*rc)
@@ -189,7 +202,7 @@
 	iovs[0].iov_len = sizeof(ih->inoh_ino);
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	*rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb, 0, h);
+	*rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb, 0, h);
 	if (*rc)
 		PFL_GOTOERR(out, *rc);
 
@@ -213,21 +226,21 @@
 	inoh_2_mdsio_data(ih) = th;
 
 	memset(&sstb, 0, sizeof(sstb));
-	*rc = mdsio_setattr(0, &sstb, SL_SETATTRF_METASIZE, &rootcreds,
+	*rc = mdsio_setattr(vfsid, 0, &sstb, SL_SETATTRF_METASIZE, &rootcreds,
 	    NULL, th, NULL);
 	if (*rc)
 		PFL_GOTOERR(out, *rc);
 
-	*rc = mds_inode_dump(NULL, ih, h);
+	*rc = mds_inode_dump(vfsid, NULL, ih, h);
 	if (*rc)
 		PFL_GOTOERR(out, *rc);
 
-	mdsio_unlink(mds_tmpdir_inum, NULL, fn, &rootcreds, NULL, NULL);
+	mdsio_unlink(vfsid, mds_tmpdir_inum[vfsid], NULL, fn, &rootcreds, NULL, NULL);
 
  out:
 	if (h)
-		mdsio_release(&rootcreds, h);
-	mdsio_unlink(mds_tmpdir_inum, NULL, fn, &rootcreds, NULL, NULL);
+		mdsio_release(vfsid, &rootcreds, h);
+	mdsio_unlink(vfsid, mds_tmpdir_inum[vfsid], NULL, fn, &rootcreds, NULL, NULL);
 	inoh_2_mdsio_data(ih) = th;
 	return (exists);
 }
@@ -246,13 +259,17 @@
 	uint64_t crc, od_crc;
 	struct iovec iovs[2];
 	size_t nb;
-	int i, rc;
+	int i, rc, vfsid;
+	struct fidc_membh	*fcmh;
 
 	iovs[0].iov_base = &ino;
 	iovs[0].iov_len = sizeof(ino);
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb, 0,
+
+	fcmh = ih->inoh_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb, 0,
 	    inoh_2_mdsio_data(ih));
 
 	if (rc)
@@ -282,7 +299,8 @@
 	uint64_t crc, od_crc;
 	struct iovec iovs[2];
 	size_t nb;
-	int i, rc;
+	int i, rc, vfsid;
+	struct fidc_membh	*fcmh;
 
 	memset(&inox, 0, sizeof(inox));
 
@@ -290,7 +308,10 @@
 	iovs[0].iov_len = sizeof(inox);
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb, 0x400,
+
+	fcmh = ih->inoh_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb, 0x400,
 	    inoh_2_mdsio_data(ih));
 
 	if (rc)
@@ -321,7 +342,8 @@
 	uint64_t crc, od_crc;
 	struct iovec iovs[2];
 	size_t nb, bsz;
-	int i, rc;
+	int i, rc, vfsid;
+	struct fidc_membh	*fcmh;
 
 	bsz = sizeof(bod) + sizeof(crc);
 
@@ -329,7 +351,9 @@
 	iovs[0].iov_len = sizeof(bod);
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb,
+	fcmh = b->bcm_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb,
 	    bsz * b->bcm_bmapno + 0x1000, readh);
 
 	if (rc)
Index: slash_nara/slashd/rpc_mds.h
===================================================================
--- slash_nara/slashd/rpc_mds.h	(revision 19179)
+++ slash_nara/slashd/rpc_mds.h	(working copy)
@@ -84,7 +84,7 @@
 	    struct slash_fidgen *, char *, char *, uint32_t,
 	    const struct slash_creds *, struct srt_stat *, int32_t);
 
-int	slm_mkdir(struct srm_mkdir_req *, struct srm_mkdir_rep *, int,
+int	slm_mkdir(int, struct srm_mkdir_req *, struct srm_mkdir_rep *, int,
 	    struct fidc_membh **);
 int	slm_symlink(struct pscrpc_request *, struct srm_symlink_req *,
 	    struct srm_symlink_rep *, int);
Index: slash_nara/slashd/mdsio_zfs.c
===================================================================
--- slash_nara/slashd/mdsio_zfs.c	(revision 19179)
+++ slash_nara/slashd/mdsio_zfs.c	(working copy)
@@ -44,19 +44,49 @@
 
 #include "zfs-fuse/zfs_slashlib.h"
 
-mdsio_fid_t		 mds_metadir_inum;
-mdsio_fid_t		 mds_upschdir_inum;
-mdsio_fid_t		 mds_fidnsdir_inum;
-mdsio_fid_t		 mds_tmpdir_inum;
+mdsio_fid_t		 mds_metadir_inum[MAX_FILESYSTEMS];
+mdsio_fid_t		 mds_upschdir_inum[MAX_FILESYSTEMS];
+mdsio_fid_t		 mds_fidnsdir_inum[MAX_FILESYSTEMS];
+mdsio_fid_t		 mds_tmpdir_inum[MAX_FILESYSTEMS];
 
 int
+mdsio_fid_to_vfsid(slfid_t fid, int *vfsid)
+{
+	int i, fsid;
+	
+#if 0
+	/* our client uses this special fid to contact us
+	 * during mount. */
+	if (fid == SLFID_ROOT) {
+		*vfsid = current_vfsid;
+		return (0);
+	}
+#endif
+	/* only have default file system in the root */
+	if (mount_index == 1) {
+		*vfsid = current_vfsid;
+		return (0);
+	}
+
+	fsid = FID_GET_SITEID(fid);
+	for (i = 0; i < mount_index; i++) {
+		if (zfsMount[i].fsid == (uint64_t)fsid) {
+			*vfsid = i;
+			return (0);
+		}
+	}
+	return (-1);
+}
+
+int
 mdsio_fcmh_refreshattr(struct fidc_membh *f, struct srt_stat *out_sstb)
 {
-	int locked, rc;
+	int locked, rc, vfsid;
 
 	locked = FCMH_RLOCK(f);
 	fcmh_wait_locked(f, f->fcmh_flags & FCMH_IN_SETATTR);
-	rc = mdsio_getattr(fcmh_2_mdsio_fid(f), fcmh_2_mdsio_data(f),
+	mdsio_fid_to_vfsid(fcmh_2_fid(f), &vfsid);
+	rc = mdsio_getattr(vfsid, fcmh_2_mdsio_fid(f), fcmh_2_mdsio_data(f),
 	    &rootcreds, &f->fcmh_sstb);
 
 	psc_assert(rc == 0);
@@ -175,8 +205,8 @@
 };
 
 int
-mdsio_write_cursor(void *buf, size_t size, void *finfo,
+mdsio_write_cursor(int vfsid, void *buf, size_t size, void *finfo,
     sl_log_write_t funcp)
 {
-	return (zfsslash2_write_cursor(buf, size, finfo, funcp));
+	return (zfsslash2_write_cursor(vfsid, buf, size, finfo, funcp));
 }
Index: slash_nara/slashd/inode.c
===================================================================
--- slash_nara/slashd/inode.c	(revision 19179)
+++ slash_nara/slashd/inode.c	(working copy)
@@ -30,6 +30,8 @@
 #include "slashd.h"
 #include "slerr.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 __static void
 mds_inode_od_initnew(struct slash_inode_handle *ih)
 {
@@ -46,9 +48,14 @@
 	struct iovec iovs[2];
 	uint64_t crc, od_crc = 0;
 	uint16_t vers;
-	int rc, locked;
+	int rc, locked, vfsid;
 	size_t nb;
+	struct fidc_membh *fcmh;
 
+	fcmh = ih->inoh_fcmh;
+	if (mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid) < 0)
+		return (EINVAL);
+
 	locked = INOH_RLOCK(ih); /* XXX bad on slow archiver */
 	psc_assert(ih->inoh_flags & INOH_INO_NOTLOADED);
 
@@ -58,7 +65,8 @@
 	iovs[0].iov_len = sizeof(ih->inoh_ino);
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb, 0,
+
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb, 0,
 	    inoh_2_mdsio_data(ih));
 
 	if (rc == 0 && nb != sizeof(ih->inoh_ino) + sizeof(od_crc))
@@ -66,7 +74,7 @@
 
 	if (rc == SLERR_SHORTIO && od_crc == 0 &&
 	    pfl_memchk(&ih->inoh_ino, 0, sizeof(ih->inoh_ino))) {
-		if (!mds_inode_update_interrupted(ih, &rc)) {
+		if (!mds_inode_update_interrupted(vfsid, ih, &rc)) {
 			DEBUG_INOH(PLL_INFO, ih, "detected a new inode");
 			mds_inode_od_initnew(ih);
 			rc = 0;
@@ -79,10 +87,10 @@
 			vers = ih->inoh_ino.ino_version;
 			memset(&ih->inoh_ino, 0, sizeof(ih->inoh_ino));
 
-			if (mds_inode_update_interrupted(ih, &rc))
+			if (mds_inode_update_interrupted(vfsid, ih, &rc))
 				;
 			else if (vers && vers < INO_VERSION)
-				rc = mds_inode_update(ih, vers);
+				rc = mds_inode_update(vfsid, ih, vers);
 			else if (rc == SLERR_SHORTIO)
 				DEBUG_INOH(PLL_INFO, ih,
 				    "short read I/O (%zd vs %zd)",
@@ -105,7 +113,7 @@
 }
 
 int
-mds_inode_write(struct slash_inode_handle *ih, void *logf, void *arg)
+mds_inode_write(int vfsid, struct slash_inode_handle *ih, void *logf, void *arg)
 {
 	struct iovec iovs[2];
 	uint64_t crc;
@@ -128,7 +136,7 @@
 
 	if (logf)
 		mds_reserve_slot(1);
-	rc = mdsio_pwritev(&rootcreds, iovs, nitems(iovs), &nb, 0, 0,
+	rc = mdsio_pwritev(vfsid, &rootcreds, iovs, nitems(iovs), &nb, 0, 0,
 	    inoh_2_mdsio_data(ih), logf, arg);
 	if (logf)
 		mds_unreserve_slot(1);
@@ -154,7 +162,7 @@
 }
 
 int
-mds_inox_write(struct slash_inode_handle *ih, void *logf, void *arg)
+mds_inox_write(int vfsid, struct slash_inode_handle *ih, void *logf, void *arg)
 {
 	struct iovec iovs[2];
 	uint64_t crc;
@@ -179,7 +187,7 @@
 
 	if (logf)
 		mds_reserve_slot(1);
-	rc = mdsio_pwritev(&rootcreds, iovs, nitems(iovs), &nb,
+	rc = mdsio_pwritev(vfsid, &rootcreds, iovs, nitems(iovs), &nb,
 	    SL_EXTRAS_START_OFF, 0, inoh_2_mdsio_data(ih), logf, arg);
 	if (logf)
 		mds_unreserve_slot(1);
@@ -204,7 +212,8 @@
 	struct iovec iovs[2];
 	uint64_t crc, od_crc;
 	size_t nb;
-	int rc;
+	int rc, vfsid;
+	struct fidc_membh *fcmh;
 
 	INOH_LOCK_ENSURE(ih);
 
@@ -217,7 +226,10 @@
 	iovs[0].iov_len = INOX_SZ;
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb,
+
+	fcmh = ih->inoh_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb,
 	    SL_EXTRAS_START_OFF, inoh_2_mdsio_data(ih));
 	if (rc == 0 && od_crc == 0 &&
 	    pfl_memchk(ih->inoh_extras, 0, INOX_SZ)) {
@@ -260,7 +272,7 @@
 }
 
 int
-mds_inodes_odsync(struct fidc_membh *f, void (*logf)(void *, uint64_t, int))
+mds_inodes_odsync(int vfsid, struct fidc_membh *f, void (*logf)(void *, uint64_t, int))
 {
 	struct slash_inode_handle *ih = fcmh_2_inoh(f);
 	int locked, rc;
@@ -277,9 +289,9 @@
 		}
 	}
 
-	rc = mds_inode_write(ih, logf, f);
+	rc = mds_inode_write(vfsid, ih, logf, f);
 	if (rc == 0 && ih->inoh_ino.ino_nrepls > SL_DEF_REPLICAS)
-		rc = mds_inox_write(ih, NULL, NULL);
+		rc = mds_inox_write(vfsid, ih, NULL, NULL);
 
 	DEBUG_FCMH(PLL_DEBUG, f, "wrote updated ino_repls logf=%p", logf);
 	INOH_URLOCK(ih, locked);
Index: slash_nara/slashd/inode.h
===================================================================
--- slash_nara/slashd/inode.h	(revision 19179)
+++ slash_nara/slashd/inode.h	(working copy)
@@ -132,16 +132,16 @@
 	int			(*sic_read_bmap)(struct bmapc_memb *, void *);
 };
 
-int	mds_inode_update(struct slash_inode_handle *, int);
-int	mds_inode_update_interrupted(struct slash_inode_handle *, int *);
+int	mds_inode_update(int, struct slash_inode_handle *, int);
+int	mds_inode_update_interrupted(int, struct slash_inode_handle *, int *);
 int	mds_inode_read(struct slash_inode_handle *);
-int	mds_inode_write(struct slash_inode_handle *, void *, void *);
-int	mds_inox_write(struct slash_inode_handle *, void *, void *);
+int	mds_inode_write(int, struct slash_inode_handle *, void *, void *);
+int	mds_inox_write(int, struct slash_inode_handle *, void *, void *);
 
 int	mds_inox_load_locked(struct slash_inode_handle *);
 int	mds_inox_ensure_loaded(struct slash_inode_handle *);
 
-int	mds_inodes_odsync(struct fidc_membh *, void (*logf)(void *, uint64_t, int));
+int	mds_inodes_odsync(int, struct fidc_membh *, void (*logf)(void *, uint64_t, int));
 
 extern struct sl_ino_compat sl_ino_compat_table[];
 
Index: slash_nara/slashd/fidc_mds.c
===================================================================
--- slash_nara/slashd/fidc_mds.c	(revision 19179)
+++ slash_nara/slashd/fidc_mds.c	(working copy)
@@ -36,8 +36,10 @@
 #include "mdsio.h"
 #include "slashd.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 int
-_mds_fcmh_setattr(struct fidc_membh *f, int to_set,
+_mds_fcmh_setattr(int vfsid, struct fidc_membh *f, int to_set,
     const struct srt_stat *sstb, int log)
 {
 	int rc = 0;
@@ -53,7 +55,7 @@
 	FCMH_ULOCK(f);
 	if (log)
 		mds_reserve_slot(1);
-	rc = mdsio_setattr(fcmh_2_mdsio_fid(f), sstb, to_set,
+	rc = mdsio_setattr(vfsid, fcmh_2_mdsio_fid(f), sstb, to_set,
 	    &rootcreds, &f->fcmh_sstb, fcmh_2_mdsio_data(f),
 	    log ? mdslog_namespace : NULL);
 	if (log)
@@ -71,15 +73,21 @@
 {
 	struct fcmh_mds_info *fmi;
 	int rc;
+	int vfsid;
 
 	DEBUG_FCMH(PLL_INFO, fcmh, "ctor");
 
+	if (mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid) < 0) {
+		rc = EINVAL;
+		DEBUG_FCMH(PLL_WARN, fcmh, "invalid file system id (rc=%d)", rc);
+		return (rc);
+	}
 	fmi = fcmh_2_fmi(fcmh);
 	memset(fmi, 0, sizeof(*fmi));
 	psc_dynarray_init(&fmi->fmi_ptrunc_clients);
 
-	rc = mdsio_lookup_slfid(fcmh_2_fid(fcmh), &rootcreds,
-	    &fcmh->fcmh_sstb, &fcmh_2_mdsio_fid(fcmh));
+	rc = mdsio_lookup_slfid(vfsid, fcmh_2_fid(fcmh), 
+		&rootcreds, &fcmh->fcmh_sstb, &fcmh_2_mdsio_fid(fcmh));
 	if (rc) {
 		fmi->fmi_ctor_rc = rc;
 		DEBUG_FCMH(PLL_WARN, fcmh,
@@ -88,12 +96,12 @@
 	}
 
 	if (fcmh_isdir(fcmh)) {
-		rc = mdsio_opendir(fcmh_2_mdsio_fid(fcmh), &rootcreds,
-		    NULL, &fmi->fmi_mdsio_data);
+		rc = mdsio_opendir(vfsid, fcmh_2_mdsio_fid(fcmh), 
+			&rootcreds, NULL, &fmi->fmi_mdsio_data);
 
 	} else if (fcmh_isreg(fcmh)) {
 		slash_inode_handle_init(&fmi->fmi_inodeh, fcmh);
-		rc = mdsio_opencreate(fcmh_2_mdsio_fid(fcmh),
+		rc = mdsio_opencreate(vfsid, fcmh_2_mdsio_fid(fcmh),
 		    &rootcreds, O_RDWR, 0, NULL, NULL, NULL,
 		    &fcmh_2_mdsio_data(fcmh), NULL, NULL, 0);
 
@@ -117,7 +125,7 @@
 slm_fcmh_dtor(struct fidc_membh *fcmh)
 {
 	struct fcmh_mds_info *fmi;
-	int rc;
+	int rc, vfsid;
 
 	fmi = fcmh_2_fmi(fcmh);
 	psc_assert(psc_dynarray_len(&fmi->fmi_ptrunc_clients) == 0);
@@ -127,7 +135,8 @@
 	    S_ISDIR(fcmh->fcmh_sstb.sst_mode)) {
 		/* XXX Need to worry about other modes here */
 		if (!fmi->fmi_ctor_rc) {
-			rc = mdsio_release(&rootcreds,
+			mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+			rc = mdsio_release(vfsid, &rootcreds,
 			    fmi->fmi_mdsio_data);
 			psc_assert(rc == 0);
 		}
@@ -137,7 +146,7 @@
 }
 
 int
-_slm_fcmh_endow(struct fidc_membh *p, struct fidc_membh *c, int log)
+_slm_fcmh_endow(int vfsid, struct fidc_membh *p, struct fidc_membh *c, int log)
 {
 //	sl_replica_t repls[SL_MAX_REPLICAS];
 	uint32_t pol;
@@ -157,14 +166,14 @@
 		sstb.sstd_freplpol = pol;
 //		c->nrepls =
 //		c->memcpy();
-		mds_fcmh_setattr(c, SL_SETATTRF_FREPLPOL, &sstb);
+		mds_fcmh_setattr(vfsid, c, SL_SETATTRF_FREPLPOL, &sstb);
 	} else {
 //		fcmh_wait_locked(c, c->fcmh_flags & FCMH_IN_SETATTR);
 		fcmh_2_ino(c)->ino_replpol = pol;
 //		fcmh_2_ino(c)->ino_nrepls = 1;
 //		memcpy(fcmh_2_ino(c)->ino_repls, repls, sizeof());
 		if (log)
-			rc = mds_inode_write(fcmh_2_inoh(c), mdslog_ino_repls, c);
+			rc = mds_inode_write(vfsid, fcmh_2_inoh(c), mdslog_ino_repls, c);
 //		if (log)
 //			rc = mds_inox_write(fcmh_2_inoh(c), mdslog_ino_repls, c);
 	}
Index: slash_nara/slashd/fidc_mds.h
===================================================================
--- slash_nara/slashd/fidc_mds.h	(revision 19179)
+++ slash_nara/slashd/fidc_mds.h	(working copy)
@@ -56,20 +56,20 @@
 #define FCMH_HAS_GARBAGE(f)	(fcmh_nallbmaps(f) > fcmh_nvalidbmaps(f))
 
 #define IS_REMOTE_FID(fid)						\
-	((fid) != SLFID_ROOT && nodeSite->site_id != FID_GET_SITEID(fid))
+	((fid) != SLFID_ROOT && current_vfsid != (int)FID_GET_SITEID(fid))
 
 #define slm_fcmh_get(fgp, fp)	fidc_lookup((fgp), FIDC_LOOKUP_CREATE, NULL, 0, (fp))
 #define slm_fcmh_peek(fgp, fp)	fidc_lookup((fgp), FIDC_LOOKUP_NONE, NULL, 0, (fp))
 
-#define	mds_fcmh_setattr(f, to_set, sstb)	_mds_fcmh_setattr((f), (to_set), (sstb), 1)
-#define	mds_fcmh_setattr_nolog(f, to_set, sstb)	_mds_fcmh_setattr((f), (to_set), (sstb), 0)
+#define	mds_fcmh_setattr(vfsid, f, to_set, sstb)	_mds_fcmh_setattr((vfsid), (f), (to_set), (sstb), 1)
+#define	mds_fcmh_setattr_nolog(vfsid, f, to_set, sstb)	_mds_fcmh_setattr((vfsid), (f), (to_set), (sstb), 0)
 
-int	_mds_fcmh_setattr(struct fidc_membh *, int, const struct srt_stat *, int);
+int	_mds_fcmh_setattr(int, struct fidc_membh *, int, const struct srt_stat *, int);
 
-#define slm_fcmh_endow(p, c)			_slm_fcmh_endow((p), (c), 1)
-#define slm_fcmh_endow_nolog(p, c)		_slm_fcmh_endow((p), (c), 0)
+#define slm_fcmh_endow(vfsid, p, c)			_slm_fcmh_endow((vfsid), (p), (c), 1)
+#define slm_fcmh_endow_nolog(vfsid, p, c)		_slm_fcmh_endow((vfsid), (p), (c), 0)
 
-int	_slm_fcmh_endow(struct fidc_membh *, struct fidc_membh *, int);
+int	_slm_fcmh_endow(int, struct fidc_membh *, struct fidc_membh *, int);
 
 extern uint64_t		slm_next_fid;
 extern psc_spinlock_t	slm_fid_lock;
Index: slash_nara/slashd/rmc.c
===================================================================
--- slash_nara/slashd/rmc.c	(revision 19179)
+++ slash_nara/slashd/rmc.c	(working copy)
@@ -58,9 +58,22 @@
 #include "slutil.h"
 #include "up_sched_res.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 uint64_t		slm_next_fid = UINT64_MAX;
 psc_spinlock_t		slm_fid_lock = SPINLOCK_INIT;
 
+extern struct psc_hashtbl rootHtable;
+
+void *
+slm_rmc_search_roots(char *name)
+{
+	void *p;
+
+	p = psc_hashtbl_search(&rootHtable, NULL, NULL, name);
+	return (p);
+}
+
 slfid_t
 slm_get_curr_slashfid(void)
 {
@@ -132,6 +145,7 @@
 	struct fidc_membh *fcmh;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+
 	mp->rc = slm_fcmh_get(&mq->fg, &fcmh);
 	if (mp->rc)
 		goto out;
@@ -316,8 +330,15 @@
 	struct fidc_membh *p = NULL, *c = NULL;
 	struct srm_link_req *mq;
 	struct srm_link_rep *mp;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+
+	if (mdsio_fid_to_vfsid(mq->fg.fg_fid, &vfsid) < 0) {
+		mp->rc = -EINVAL;
+		goto out;
+	}
+
 	mp->rc = slm_fcmh_get(&mq->fg, &c);
 	if (mp->rc)
 		goto out;
@@ -327,7 +348,7 @@
 
 	mq->name[sizeof(mq->name) - 1] = '\0';
 	mds_reserve_slot(1);
-	mp->rc = mdsio_link(fcmh_2_mdsio_fid(c), fcmh_2_mdsio_fid(p),
+	mp->rc = mdsio_link(vfsid, fcmh_2_mdsio_fid(c), fcmh_2_mdsio_fid(p),
 	    mq->name, &rootcreds, &mp->cattr, mdslog_namespace);
 	mds_unreserve_slot(1);
 
@@ -347,8 +368,13 @@
 	struct srm_lookup_req *mq;
 	struct srm_lookup_rep *mp;
 	struct fidc_membh *p;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = -EINVAL;
+		goto out;
+	}
 	mp->rc = slm_fcmh_get(&mq->pfg, &p);
 	if (mp->rc)
 		goto out;
@@ -359,9 +385,35 @@
 		mp->rc = -EINVAL;
 		goto out;
 	}
-	mp->rc = mdsio_lookup(fcmh_2_mdsio_fid(p),
+	mp->rc = mdsio_lookup(vfsid, fcmh_2_mdsio_fid(p),
 	    mq->name, NULL, &rootcreds, &mp->attr);
+	if (mp->rc)
+		goto out;
+	if (mq->pfg.fg_fid == SLFID_ROOT) {
 
+		int error;
+		uint64_t fid;
+		struct rootNames *p;
+		mount_info_t *mountinfo;
+		struct srt_stat tmpattr;
+
+		p = slm_rmc_search_roots(mq->name);
+		if (p) {
+			mountinfo = &zfsMount[p->rn_vfsid];
+			fid = SLFID_ROOT;
+			FID_SET_SITEID(fid, mountinfo->fsid);
+
+			error = mdsio_getattr(p->rn_vfsid, mountinfo->rootid, 
+				mountinfo->rootinfo, &rootcreds, &tmpattr); 
+			if (!error) {
+				tmpattr.sst_fg.fg_fid = fid;
+				mp->attr = tmpattr;
+			} else
+				/* better than nothing */
+				mp->attr.sst_fg.fg_fid = fid;
+		}
+	}
+
  out:
 	if (p)
 		fcmh_op_done_type(p, FCMH_OPCNT_LOOKUP_FIDC);
@@ -369,7 +421,7 @@
 }
 
 int
-slm_mkdir(struct srm_mkdir_req *mq, struct srm_mkdir_rep *mp,
+slm_mkdir(int vfsid, struct srm_mkdir_req *mq, struct srm_mkdir_rep *mp,
     int opflags, struct fidc_membh **dp)
 {
 	struct fidc_membh *p = NULL, *c = NULL;
@@ -380,6 +432,7 @@
 	if (mp->rc)
 		goto out;
 
+#if 0
 	if (IS_REMOTE_FID(mq->pfg.fg_fid)) {
 		struct slash_creds cr;
 
@@ -391,9 +444,10 @@
 		    &cr, &mp->cattr, 0);
 		goto out;
 	}
+#endif
 
 	mds_reserve_slot(1);
-	mp->rc = -mdsio_mkdir(fcmh_2_mdsio_fid(p), mq->name, &mq->sstb,
+	mp->rc = -mdsio_mkdir(vfsid, fcmh_2_mdsio_fid(p), mq->name, &mq->sstb,
 	    0, opflags, &mp->cattr, NULL, mdslog_namespace,
 	    slm_get_next_slashfid, 0);
 	mds_unreserve_slot(1);
@@ -407,11 +461,11 @@
 	 * parent dir.
 	 */
 	if (mp->rc == 0 && slm_fcmh_get(&mp->cattr.sst_fg, &c) == 0)
-		slm_fcmh_endow_nolog(p, c);
+		slm_fcmh_endow_nolog(vfsid, p, c);
 
 	if (dp) {
 		if (mp->rc == -EEXIST &&
-		    mdsio_lookup(fcmh_2_mdsio_fid(p), mq->name, NULL,
+		    mdsio_lookup(vfsid, fcmh_2_mdsio_fid(p), mq->name, NULL,
 		    &rootcreds, &mp->cattr) == 0)
 			slm_fcmh_get(&mp->cattr.sst_fg, &c);
 		*dp = c;
@@ -429,9 +483,18 @@
 {
 	struct srm_mkdir_req *mq;
 	struct srm_mkdir_rep *mp;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
-	return (slm_mkdir(mq, mp, 0, NULL));
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		return (0);
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = -EACCES;
+		return (0);
+	}
+	return (slm_mkdir(vfsid, mq, mp, 0, NULL));
 }
 
 int
@@ -440,15 +503,22 @@
 	struct srm_mknod_req *mq;
 	struct srm_mknod_rep *mp;
 	struct fidc_membh *p;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+
 	mp->rc = slm_fcmh_get(&mq->pfg, &p);
 	if (mp->rc)
 		goto out;
 
 	mq->name[sizeof(mq->name) - 1] = '\0';
 	mds_reserve_slot(1);
-	mp->rc = mdsio_mknod(fcmh_2_mdsio_fid(p), mq->name, mq->mode,
+	mp->rc = mdsio_mknod(vfsid, fcmh_2_mdsio_fid(p), mq->name, mq->mode,
 	    &mq->creds, &mp->cattr, NULL, mdslog_namespace,
 	    slm_get_next_slashfid);
 	mds_unreserve_slot(1);
@@ -472,8 +542,19 @@
 	struct srm_create_req *mq;
 	struct bmapc_memb *bmap;
 	void *mdsio_data;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = -EINVAL;
+		goto out;
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EACCES;
+		goto out;
+	}
+
 	if (mq->flags & SRM_LEASEBMAPF_GETREPLTBL) {
 		mp->rc = -EINVAL;
 		goto out;
@@ -489,6 +570,7 @@
 
 	mq->name[sizeof(mq->name) - 1] = '\0';
 
+#if 0
 	if (IS_REMOTE_FID(mq->pfg.fg_fid)) {
 		mp->rc = slm_rmm_forward_namespace(SLM_FORWARD_CREATE,
 		    &mq->pfg, NULL, mq->name, NULL, mq->mode,
@@ -499,11 +581,12 @@
 		}
 		goto out;
 	}
+#endif
 
 	DEBUG_FCMH(PLL_DEBUG, p, "create op start for %s", mq->name);
 
 	mds_reserve_slot(1);
-	mp->rc = mdsio_opencreate(fcmh_2_mdsio_fid(p), &mq->creds,
+	mp->rc = mdsio_opencreate(vfsid, fcmh_2_mdsio_fid(p), &mq->creds,
 	    O_CREAT | O_EXCL | O_RDWR, mq->mode, mq->name, NULL,
 	    &mp->cattr, &mdsio_data, mdslog_namespace,
 	    slm_get_next_slashfid, 0);
@@ -522,7 +605,7 @@
 	 *   This release may be the sanest thing actually, unless EXCL is
 	 *   used.
 	 */
-	mdsio_release(&rootcreds, mdsio_data);
+	mdsio_release(vfsid, &rootcreds, mdsio_data);
 
 	DEBUG_FCMH(PLL_DEBUG, p, "mdsio_release() done for %s",
 	    mq->name);
@@ -531,7 +614,7 @@
 	if (mp->rc)
 		goto out;
 
-	slm_fcmh_endow_nolog(p, c);
+	slm_fcmh_endow_nolog(vfsid, p, c);
 
 	/* obtain lease for first bmap as optimization */
 	mp->flags = mq->flags;
@@ -553,6 +636,44 @@
 	return (0);
 }
 
+void
+slm_rmc_handle_readdir_roots(struct iovec *iov0, struct iovec *iov1, size_t nents)
+{
+	int error;
+	struct srt_stat tmpattr, *attr;
+	struct pscfs_dirent *dirent;
+	size_t i, entsize;
+	uint64_t fid;
+	struct rootNames *p;
+	mount_info_t *mountinfo;
+
+	attr = iov1->iov_base;
+	dirent = iov0->iov_base;
+	for (i = 0; i < nents; i++) {
+
+		p = slm_rmc_search_roots(dirent->pfd_name);
+		if (p) {
+			mountinfo = &zfsMount[p->rn_vfsid];
+			fid = SLFID_ROOT;
+			FID_SET_SITEID(fid, mountinfo->fsid);
+			dirent->pfd_ino = fid;
+
+			error = mdsio_getattr(p->rn_vfsid, mountinfo->rootid, 
+				mountinfo->rootinfo, &rootcreds, &tmpattr); 
+			if (!error) {
+				tmpattr.sst_fg.fg_fid = fid;
+				*attr = tmpattr;
+			} else
+				/* better than nothing */
+				attr->sst_fg.fg_fid = fid;
+		}
+		attr++;
+		entsize = PFL_DIRENT_SIZE(dirent->pfd_namelen);
+		dirent = PSC_AGP(dirent, entsize);
+
+	}
+}
+
 int
 slm_rmc_handle_readdir(struct pscrpc_request *rq)
 {
@@ -561,13 +682,18 @@
 	struct srm_readdir_rep *mp;
 	struct iovec iov[2];
 	size_t outsize, nents;
-	int niov;
+	int niov, vfsid;
 
 	iov[0].iov_base = NULL;
 	iov[1].iov_base = NULL;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
 
+	if (mdsio_fid_to_vfsid(mq->fg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+
 	mp->rc = slm_fcmh_get(&mq->fg, &fcmh);
 	if (mp->rc)
 		goto out;
@@ -591,19 +717,29 @@
 		iov[1].iov_base = NULL;
 	}
 
-	mp->rc = mdsio_readdir(&rootcreds, mq->size, mq->offset,
+	/* make sure things are populated under the root before readdir() */
+	if (mq->fg.fg_fid == SLFID_ROOT) 
+		psc_scan_filesystems();
+
+	mp->rc = mdsio_readdir(vfsid, &rootcreds, mq->size, mq->offset,
 	    iov[0].iov_base, &outsize, &nents, iov[1].iov_base,
 	    mq->nstbpref, fcmh_2_mdsio_data(fcmh));
-	mp->size = outsize;
-	mp->num = nents;
 
 	psclog_info("mdsio_readdir: rc=%d, data=%p", mp->rc,
 	    fcmh_2_mdsio_data(fcmh));
+	mp->size = outsize;
+	mp->num = nents;
 
 	if (mp->rc)
 		goto out;
 
-#if 0
+	/*
+	 * If this is the root, we fake part of readdir contents by
+	 * return the file system names here.
+	 */
+	if (mq->fg.fg_fid == SLFID_ROOT) 
+		slm_rmc_handle_readdir_roots(&iov[0], &iov[1], nents);
+#if 1
 	{
 		/* debugging only */
 		unsigned int i;
@@ -649,13 +785,20 @@
 	struct fidc_membh *fcmh;
 	struct iovec iov;
 	char buf[SL_PATH_MAX];
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->fg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+
 	mp->rc = slm_fcmh_get(&mq->fg, &fcmh);
+	mp->rc = slm_fcmh_get(&mq->fg, &fcmh);
 	if (mp->rc)
 		goto out;
 
-	mp->rc = mdsio_readlink(fcmh_2_mdsio_fid(fcmh), buf,
+	mp->rc = mdsio_readlink(vfsid, fcmh_2_mdsio_fid(fcmh), buf,
 	    &rootcreds);
 	if (mp->rc)
 		goto out;
@@ -687,10 +830,17 @@
 	struct srm_rename_rep *mp;
 	struct slash_fidgen chfg;
 	struct iovec iov[2];
+	int vfsid;
 
 	chfg.fg_fid = FID_ANY;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->opfg.fg_fid, &vfsid) < 0) 
+		return (EINVAL);
+
+	if (current_vfsid != vfsid)
+		return (EINVAL);
+
 	if (mq->fromlen == 0 || mq->tolen == 0 ||
 	    mq->fromlen > SL_NAME_MAX || mq->tolen > SL_NAME_MAX)
 		return (EINVAL);
@@ -726,16 +876,18 @@
 		goto out;
 	}
 
+#if 0
 	if (IS_REMOTE_FID(mq->opfg.fg_fid)) {
 		mp->rc = slm_rmm_forward_namespace(SLM_FORWARD_RENAME,
 		    &mq->opfg, &mq->npfg, from, to, 0, &rootcreds,
 		    &mp->srr_npattr, 0);
 		goto out;
 	}
+#endif
 
 	/* if we get here, op and np must be owned by the current MDS */
 	mds_reserve_slot(2);
-	mp->rc = mdsio_rename(fcmh_2_mdsio_fid(op), from,
+	mp->rc = mdsio_rename(vfsid, fcmh_2_mdsio_fid(op), from,
 	    fcmh_2_mdsio_fid(np), to, &rootcreds, mdslog_namespace,
 	    &chfg);
 	mds_unreserve_slot(2);
@@ -773,8 +925,17 @@
 	struct fidc_membh *fcmh = NULL;
 	struct srm_setattr_req *mq;
 	struct srm_setattr_rep *mp;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->attr.sst_fg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EACCES;
+		goto out;
+	}
 
 	mp->rc = slm_fcmh_get(&mq->attr.sst_fg, &fcmh);
 	if (mp->rc)
@@ -787,10 +948,12 @@
 	to_set = mq->to_set & SL_SETATTRF_CLI_ALL;
 
 	if (to_set & PSCFS_SETATTRF_DATASIZE) {
+#if 0
 		if (IS_REMOTE_FID(mq->attr.sst_fg.fg_fid)) {
 			mp->rc = -ENOSYS;
 			goto out;
 		}
+#endif
 		/* our client should really do this on its own */
 		if (!(to_set & PSCFS_SETATTRF_MTIME)) {
 			psclog_warn("setattr: missing MTIME flag in RPC request");
@@ -822,20 +985,24 @@
 	}
 
 	if (to_set) {
+#if 0
 		if (IS_REMOTE_FID(mq->attr.sst_fg.fg_fid)) {
 			mp->rc = slm_rmm_forward_namespace(
 			    SLM_FORWARD_SETATTR, &mq->attr.sst_fg, NULL,
 			    NULL, NULL, 0, NULL, &mq->attr, to_set);
 			mp->attr = mq->attr;
 		} else {
+#endif
 			/*
 			 * If the file is open, mdsio_data will be valid
 			 * and used.  Otherwise, it will be NULL, and
 			 * we'll use the mdsio_fid.
 			 */
-			mp->rc = mds_fcmh_setattr(fcmh, to_set,
+			mp->rc = mds_fcmh_setattr(vfsid, fcmh, to_set,
 			    &mq->attr);
+#if 0
 		}
+#endif
 	}
 
 	if (mp->rc) {
@@ -871,6 +1038,7 @@
 	struct srm_set_newreplpol_req *mq;
 	struct srm_set_newreplpol_rep *mp;
 	struct fidc_membh *fcmh;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
 
@@ -878,6 +1046,14 @@
 		mp->rc = -EINVAL;
 		return (0);
 	}
+	if (mdsio_fid_to_vfsid(mq->fg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EINVAL;
+		goto out;
+	}
 
 	mp->rc = slm_fcmh_get(&mq->fg, &fcmh);
 	if (mp->rc)
@@ -885,7 +1061,7 @@
 
 	FCMH_LOCK(fcmh);
 	fcmh_2_replpol(fcmh) = mq->pol;
-	mp->rc = mds_inode_write(fcmh_2_inoh(fcmh), mdslog_ino_repls,
+	mp->rc = mds_inode_write(vfsid, fcmh_2_inoh(fcmh), mdslog_ino_repls,
 	    fcmh);
 
  out:
@@ -940,11 +1116,15 @@
 	struct srm_statfs_rep *mp;
 	struct sl_mds_iosinfo *si;
 	struct statvfs sfb;
-	int j = 0, single = 0;
+	int j = 0, single = 0, vfsid;
 	double adj;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
-	mp->rc = mdsio_statfs(&sfb);
+	if (mdsio_fid_to_vfsid(mq->fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		return (0);
+	}
+	mp->rc = mdsio_statfs(vfsid, &sfb);
 	sl_externalize_statfs(&sfb, &mp->ssfb);
 	r = libsl_id2res(mq->iosid);
 	if (r == NULL) {
@@ -986,7 +1166,13 @@
 	struct fidc_membh *p = NULL;
 	struct slash_creds cr;
 	struct iovec iov;
+	int vfsid;
 
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0)
+		return (-EINVAL);
+	if (vfsid != current_vfsid)
+		return (-EACCES);
+
 	mq->name[sizeof(mq->name) - 1] = '\0';
 	if (mq->linklen == 0 || mq->linklen >= SL_PATH_MAX)
 		return (EINVAL);
@@ -1007,7 +1193,7 @@
 	cr.scr_gid = mq->sstb.sst_gid;
 
 	mds_reserve_slot(1);
-	mp->rc = mdsio_symlink(linkname, fcmh_2_mdsio_fid(p), mq->name,
+	mp->rc = mdsio_symlink(vfsid, linkname, fcmh_2_mdsio_fid(p), mq->name,
 	    &cr, &mp->cattr, NULL, slm_get_next_slashfid,
 	    mdslog_namespace);
 	mds_unreserve_slot(1);
@@ -1037,10 +1223,19 @@
 	struct fidc_membh *p = NULL;
 	struct srm_unlink_req *mq;
 	struct srm_unlink_rep *mp;
+	int vfsid;
 
 	chfg.fg_fid = FID_ANY;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->pfid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EACCES; 
+		goto out;
+	}
 
 	fg.fg_fid = mq->pfid;
 	fg.fg_gen = FGEN_ANY;
@@ -1049,19 +1244,21 @@
 	if (mp->rc)
 		goto out;
 
+#if 0
 	if (IS_REMOTE_FID(mq->pfid)) {
 		mp->rc = slm_rmm_forward_namespace(isfile ?
 		    SLM_FORWARD_UNLINK : SLM_FORWARD_RMDIR, &fg, NULL,
 		    mq->name, NULL, 0, NULL, NULL, 0);
 		goto out;
 	}
+#endif
 
 	mds_reserve_slot(1);
 	if (isfile)
-		mp->rc = mdsio_unlink(fcmh_2_mdsio_fid(p), NULL,
+		mp->rc = mdsio_unlink(vfsid, fcmh_2_mdsio_fid(p), NULL,
 		    mq->name, &rootcreds, mdslog_namespace, &chfg);
 	else
-		mp->rc = mdsio_rmdir(fcmh_2_mdsio_fid(p), NULL,
+		mp->rc = mdsio_rmdir(vfsid, fcmh_2_mdsio_fid(p), NULL,
 		    mq->name, &rootcreds, mdslog_namespace);
 	mds_unreserve_slot(1);
 
Index: slash_nara/slashd/mdslog.c
===================================================================
--- slash_nara/slashd/mdslog.c	(revision 19179)
+++ slash_nara/slashd/mdslog.c	(working copy)
@@ -176,23 +176,23 @@
 	mdsio_fid_t mf;
 	int rc;
 
-	rc = mdsio_lookup(mds_metadir_inum, fn, &mf, &rootcreds, NULL);
+	rc = mdsio_lookup(current_vfsid, mds_metadir_inum[current_vfsid], fn, &mf, &rootcreds, NULL);
 	if (rc == ENOENT && (flags & O_CREAT)) {
-		rc = mdsio_opencreatef(mds_metadir_inum, &rootcreds,
+		rc = mdsio_opencreatef(current_vfsid, mds_metadir_inum[current_vfsid], &rootcreds,
 		    flags, MDSIO_OPENCRF_NOLINK, 0600, fn, NULL, NULL,
 		    handle, NULL, NULL, 0);
 	} else if (!rc) {
-		rc = mdsio_opencreate(mf, &rootcreds, flags, 0, NULL,
+		rc = mdsio_opencreate(current_vfsid, mf, &rootcreds, flags, 0, NULL,
 		    NULL, NULL, handle, NULL, NULL, 0);
 	}
 	return (rc);
 }
 
 #define mds_read_file(h, buf, size, nb, off)				\
-	mdsio_read(&rootcreds, (buf), (size), (nb), (off), (h))
+	mdsio_read(current_vfsid, &rootcreds, (buf), (size), (nb), (off), (h))
 
 #define mds_write_file(h, buf, size, nb, off)				\
-	mdsio_write(&rootcreds, (buf), (size), (nb), (off), 0, (h), NULL, NULL)
+	mdsio_write(current_vfsid, &rootcreds, (buf), (size), (nb), (off), 0, (h), NULL, NULL)
 
 static void
 mds_record_update_prog(void)
@@ -260,8 +260,8 @@
 		xmkfn(logfn, "%s.%d", SL_FN_UPDATELOG, batchno);
 	else
 		xmkfn(logfn, "%s.%d", SL_FN_RECLAIMLOG, batchno);
-	rc = mdsio_unlink(mds_metadir_inum, NULL, logfn, &rootcreds, NULL,
-	    NULL);
+	rc = mdsio_unlink(current_vfsid, mds_metadir_inum[current_vfsid], NULL, 
+		logfn, &rootcreds, NULL, NULL);
 	psclog_warnx("Removing log file %s, rc = %d\n", logfn, rc);
 }
 
@@ -375,7 +375,7 @@
 		rc = mds_open_logfile(current_reclaim_batchno, 0, 0, &reclaim_logfile_handle);
 		psc_assert(rc == 0);
 
-		rc = mdsio_getattr(0, reclaim_logfile_handle, &rootcreds, &sstb);
+		rc = mdsio_getattr(current_vfsid, 0, reclaim_logfile_handle, &rootcreds, &sstb);
 		psc_assert(rc == 0);
 
 		reclaim_logfile_offset = 0;
@@ -464,7 +464,7 @@
 	if (reclaim_logfile_offset ==
 	    SLM_RECLAIM_BATCH * (off_t)current_reclaim_entrysize) {
 
-		mdsio_release(&rootcreds, reclaim_logfile_handle);
+		mdsio_release(current_vfsid, &rootcreds, reclaim_logfile_handle);
 
 		reclaim_logfile_handle = NULL;
 		current_reclaim_batchno++;
@@ -574,7 +574,7 @@
 	if (update_logfile_offset ==
 	    SLM_UPDATE_BATCH * sizeof(struct srt_update_entry)) {
 
-		mdsio_release(&rootcreds, update_logfile_handle);
+		mdsio_release(current_vfsid, &rootcreds, update_logfile_handle);
 
 		update_logfile_handle = NULL;
 		current_update_batchno++;
@@ -872,7 +872,7 @@
 	}
 	rc = mds_read_file(handle, updatebuf,
 	    SLM_UPDATE_BATCH * sizeof(struct srt_update_entry), &size, 0);
-	mdsio_release(&rootcreds, handle);
+	mdsio_release(current_vfsid, &rootcreds, handle);
 
 	if (size == 0)
 		return (didwork);
@@ -1082,7 +1082,7 @@
 	int rc;
 
 	while (pscthr_run()) {
-		rc = mdsio_write_cursor(&mds_cursor, sizeof(mds_cursor),
+		rc = mdsio_write_cursor(current_vfsid, &mds_cursor, sizeof(mds_cursor),
 			mds_cursor_handle, mds_update_cursor);
 		if (rc)
 			psclog_warnx("failed to update cursor, rc=%d", rc);
@@ -1105,15 +1105,15 @@
 	size_t nb;
 	int rc;
 
-	rc = mdsio_lookup(mds_metadir_inum, SL_FN_CURSOR, &mf,
+	rc = mdsio_lookup(current_vfsid, mds_metadir_inum[current_vfsid], SL_FN_CURSOR, &mf,
 	    &rootcreds, NULL);
 	psc_assert(rc == 0);
 
-	rc = mdsio_opencreate(mf, &rootcreds, O_RDWR, 0, NULL, NULL,
+	rc = mdsio_opencreate(current_vfsid, mf, &rootcreds, O_RDWR, 0, NULL, NULL,
 	    NULL, &mds_cursor_handle, NULL, NULL, 0);
 	psc_assert(!rc && mds_cursor_handle);
 
-	rc = mdsio_read(&rootcreds, &mds_cursor,
+	rc = mdsio_read(current_vfsid, &rootcreds, &mds_cursor,
 	    sizeof(struct psc_journal_cursor), &nb, 0, mds_cursor_handle);
 	psc_assert(rc == 0 && nb == sizeof(struct psc_journal_cursor));
 
@@ -1121,13 +1121,26 @@
 	psc_assert(mds_cursor.pjc_version == PJRNL_CURSOR_VERSION);
 	psc_assert(mds_cursor.pjc_fid >= SLFID_MIN);
 
+#if 0
 	if (FID_GET_SITEID(mds_cursor.pjc_fid) == 0)
 		mds_cursor.pjc_fid |= (uint64_t)nodeSite->site_id <<
 		    SLASH_FID_SITE_SHFT;
 	if (FID_GET_SITEID(mds_cursor.pjc_fid) != nodeSite->site_id)
 		psc_fatal("Mismatched site ID in the FID, expected %d",
 		    nodeSite->site_id);
+#endif
+	/* old utility does not set fsid, so we fill it here */
+	if (FID_GET_SITEID(mds_cursor.pjc_fid) == 0)
+		FID_SET_SITEID(mds_cursor.pjc_fid, zfsMount[current_vfsid].fsid);
 
+#if 0
+	/* backward compatibility */
+	if (mount_index == 1) {
+		psc_assert(current_vfsid == 0);
+		zfsMount[current_vfsid].fsid = FID_GET_SITEID(mds_cursor.pjc_fid);
+	}
+#endif
+
 	slm_set_curr_slashfid(mds_cursor.pjc_fid);
 	psclog_notice("File system was formatted on %"PRIu64" seconds "
 	    "since the Epoch", mds_cursor.pjc_timestamp);
@@ -1209,18 +1222,18 @@
 			    batchno, slstrerror(rc));
 		return (didwork);
 	}
-	rc = mdsio_getattr(0, handle, &rootcreds, &sstb);
+	rc = mdsio_getattr(current_vfsid, 0, handle, &rootcreds, &sstb);
 	psc_assert(rc == 0);
 
 	if (sstb.sst_size == 0) {
-		mdsio_release(&rootcreds, handle);
+		mdsio_release(current_vfsid, &rootcreds, handle);
 		return (didwork);
 	}
 	reclaimbuf = PSCALLOC(sstb.sst_size);
 
 	rc = mds_read_file(handle, reclaimbuf, sstb.sst_size, &size, 0);
 	psc_assert(rc == 0 && sstb.sst_size == size);
-	mdsio_release(&rootcreds, handle);
+	mdsio_release(current_vfsid, &rootcreds, handle);
 
 	version = 0;
 	entrysize = RECLAIM_ENTRY_SIZE;
@@ -1759,14 +1772,14 @@
 			}
 			break;
 		}
-		mdsio_release(&rootcreds, handle);
+		mdsio_release(current_vfsid, &rootcreds, handle);
 		batchno++;
 	}
 	if (rc)
 		psc_fatalx("failed to open reclaim log file, "
 		    "batchno=%"PRId64": %s", batchno, slstrerror(rc));
 
-	rc = mdsio_getattr(0, handle, &rootcreds, &sstb);
+	rc = mdsio_getattr(current_vfsid, 0, handle, &rootcreds, &sstb);
 	psc_assert(rc == 0);
 
 	current_reclaim_batchno = batchno;
@@ -1811,7 +1824,7 @@
 
 	last_distill_xid = last_reclaim_xid;
 
-	mdsio_release(&rootcreds, handle);
+	mdsio_release(current_vfsid, &rootcreds, handle);
 
 	/* search for newly-added I/O servers */
 	SITE_FOREACH_RES(nodeSite, res, ri) {
@@ -1888,7 +1901,7 @@
 
 	rc = mds_read_file(handle, updatebuf,
 	    SLM_UPDATE_BATCH * sizeof(struct srt_update_entry), &size, 0);
-	mdsio_release(&rootcreds, handle);
+	mdsio_release(current_vfsid, &rootcreds, handle);
 
 	psc_assert(rc == 0);
 	psc_assert((size % sizeof(struct srt_update_entry)) == 0);
Index: slash_nara/slashd/rmi.c
===================================================================
--- slash_nara/slashd/rmi.c	(revision 19179)
+++ slash_nara/slashd/rmi.c	(working copy)
@@ -46,6 +46,10 @@
 #include "slerr.h"
 #include "up_sched_res.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
+extern int current_vfsid;
+
 /**
  * slm_rmi_handle_bmap_getcrcs - Handle a BMAPGETCRCS request from ION,
  *	so the ION can load the CRCs for a bmap and verify them against
@@ -214,7 +218,7 @@
 	if (dst_resm == NULL)
 		PFL_GOTOERR(out, mp->rc = -SLERR_ION_UNKNOWN);
 
-	iosidx = mds_repl_ios_lookup(USWI_INOH(wk),
+	iosidx = mds_repl_ios_lookup(current_vfsid, USWI_INOH(wk),
 	    dst_resm->resm_res->res_id);
 	if (iosidx < 0) {
 		DEBUG_USWI(PLL_ERROR, wk,
@@ -245,7 +249,7 @@
 			 * Bad CRC, media error perhaps.
 			 * Check if other replicas exist.
 			 */
-			src_iosidx = mds_repl_ios_lookup(USWI_INOH(wk),
+			src_iosidx = mds_repl_ios_lookup(current_vfsid, USWI_INOH(wk),
 			    src_res->res_id);
 			if (src_iosidx < 0)
 				goto out;
@@ -342,7 +346,7 @@
 	if (mp->rc)
 		return (0);
 
-	iosidx = mds_repl_ios_lookup(fcmh_2_inoh(b->bcm_fcmh),
+	iosidx = mds_repl_ios_lookup(current_vfsid, fcmh_2_inoh(b->bcm_fcmh),
 	    libsl_nid2resm(rq->rq_export->exp_connection->
 	    c_peer.nid)->resm_res_id);
 
@@ -399,8 +403,17 @@
 	sl_bmapno_t bno;
 	int64_t fsiz;
 	uint32_t i;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EINVAL;
+		goto out;
+	}
 
 	m = libsl_try_nid2resm(rq->rq_export->exp_connection->c_peer.nid);
 	if (m == NULL)
@@ -417,7 +430,7 @@
 	mq->cpn[sizeof(mq->cpn) - 1] = '\0';
 
 	mds_reserve_slot(1);
-	rc = mdsio_opencreatef(fcmh_2_mdsio_fid(p), &rootcreds,
+	rc = mdsio_opencreatef(current_vfsid, fcmh_2_mdsio_fid(p), &rootcreds,
 	    O_CREAT | O_EXCL | O_RDWR, MDSIO_OPENCRF_NOMTIM,
 	    mq->sstb.sst_mode, mq->cpn, NULL, &sstb, &mdsio_data,
 	    mdslog_namespace, slm_get_next_slashfid, 0);
@@ -428,7 +441,7 @@
 		PFL_GOTOERR(out, mp->rc);
 
 	if (rc == EEXIST) {
-		rc2 = mdsio_lookup(fcmh_2_mdsio_fid(p), mq->cpn,
+		rc2 = mdsio_lookup(current_vfsid, fcmh_2_mdsio_fid(p), mq->cpn,
 		    NULL, &rootcreds, &sstb);
 		if (rc2)
 			PFL_GOTOERR(out, mp->rc = -rc2);
@@ -436,7 +449,7 @@
 		if (IS_REMOTE_FID(sstb.sst_fid))
 			PFL_GOTOERR(out, mp->rc = -ENOTSUP);
 	} else
-		mdsio_release(&cr, mdsio_data);
+		mdsio_release(current_vfsid, &cr, mdsio_data);
 
 	mp->fg = sstb.sst_fg;
 	if (S_ISDIR(sstb.sst_mode))
@@ -467,19 +480,19 @@
 			for (i = 0; i < fcmh_2_nrepls(c); i++)
 				fcmh_set_repl_nblks(c, i, 0);
 			/* XXX does this update mtim? */
-			rc = mds_fcmh_setattr(c,
+			rc = mds_fcmh_setattr(vfsid, c,
 			    PSCFS_SETATTRF_DATASIZE | SL_SETATTRF_GEN |
 			    SL_SETATTRF_NBLKS, &sstb);
-			mds_inodes_odsync(c, NULL); /* journal repl_nblks */
+			mds_inodes_odsync(vfsid, c, NULL); /* journal repl_nblks */
 			FCMH_ULOCK(c);
 
 			if (rc)
 				PFL_GOTOERR(out, mp->rc = -rc);
 		}
 	} else
-		slm_fcmh_endow_nolog(p, c);
+		slm_fcmh_endow_nolog(vfsid, p, c);
 
-	idx = mds_repl_ios_lookup_add(fcmh_2_inoh(c), m->resm_res_id,
+	idx = mds_repl_ios_lookup_add(vfsid, fcmh_2_inoh(c), m->resm_res_id,
 	    1);
 	if (idx < 0)
 		PFL_GOTOERR(out, mp->rc = rc);
@@ -529,11 +542,11 @@
 		    PSCFS_SETATTRF_CTIME | PSCFS_SETATTRF_ATIME |
 		    PSCFS_SETATTRF_UID | PSCFS_SETATTRF_GID;
 	}
-	rc = mds_fcmh_setattr(c, fl, &mq->sstb);
+	rc = mds_fcmh_setattr(vfsid, c, fl, &mq->sstb);
 	if (rc)
 		PFL_GOTOERR(out, mp->rc = -rc);
 
-	rc = mds_inodes_odsync(c, NULL); /* journal repl_nblks */
+	rc = mds_inodes_odsync(vfsid, c, NULL); /* journal repl_nblks */
 	if (rc)
 		mp->rc = rc;
 
@@ -560,13 +573,22 @@
 	struct srm_mkdir_rep *mp;
 	struct fidc_membh *d;
 	struct srt_stat sstb;
-	int rc;
+	int rc, vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		return (0);
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EINVAL;
+		return (0);
+	}
+
 	sstb = mq->sstb;
 	mq->sstb.sst_uid = 0;
 	mq->sstb.sst_gid = 0;
-	rc = slm_mkdir(mq, mp, MDSIO_OPENCRF_NOMTIM, &d);
+	rc = slm_mkdir(vfsid, mq, mp, MDSIO_OPENCRF_NOMTIM, &d);
 	if (rc)
 		return (rc);
 	if (mp->rc && mp->rc != -EEXIST)
@@ -577,7 +599,7 @@
 	 * XXX if mp->rc == -EEXIST, only update attrs if target isn't
 	 * newer
 	 */
-	rc = -mds_fcmh_setattr(d,
+	rc = -mds_fcmh_setattr(vfsid, d,
 	    PSCFS_SETATTRF_UID | PSCFS_SETATTRF_GID |
 	    PSCFS_SETATTRF_ATIME | PSCFS_SETATTRF_MTIME |
 	    PSCFS_SETATTRF_CTIME, &sstb);
Index: slash_nara/slashd/main_mds.c
===================================================================
--- slash_nara/slashd/main_mds.c	(revision 19179)
+++ slash_nara/slashd/main_mds.c	(working copy)
@@ -55,18 +55,24 @@
 
 #include "zfs-fuse/zfs_slashlib.h"
 
+
+/* this table is immutable, at least for now */
+struct psc_hashtbl		 rootHtable;
+
 GCRY_THREAD_OPTION_PTHREAD_IMPL;
 
 int			 allow_root_uid = 1;
 int			 disable_propagation = 0;
 
+int			 current_vfsid;
+
 const char		*progname;
 
 struct psc_poolmaster	 upsched_poolmaster;
 
 struct slash_creds	 rootcreds = { 0, 0 };
 struct pscfs		 pscfs;
-uint64_t		 slm_fsuuid;
+uint64_t		 slm_fsuuid[MAX_FILESYSTEMS];
 struct psc_thread	*slmconnthr;
 uint32_t		 sys_upnonce;
 
@@ -156,14 +162,224 @@
 	exit(1);
 }
 
+/*
+ * Note: The root file system must have fsid of zero, so that a client can
+ * see all the file systems in the pool.
+ */
 int
+read_vfsid(int vfsid, char *fn, uint64_t *id)
+{
+	int rc;
+	void *h;
+	char *endp;
+	size_t nb;
+	mdsio_fid_t mf;
+	char buf[30];
+	
+	rc = mdsio_lookup(vfsid, mds_metadir_inum[vfsid], fn, &mf,
+	    &rootcreds, NULL);
+
+	/* backward compatibility */
+	if (rc == ENOENT && !strcmp(fn, SL_FN_FSID)) {
+		*id = 0;
+		return (0);
+	}
+
+	if (rc) {
+		psclog_errorx("lookup %s/%s: %s", SL_RPATH_META_DIR,
+		    fn, slstrerror(rc));
+		goto out;
+	}
+	rc = mdsio_opencreate(vfsid, mf, &rootcreds, O_RDONLY, 0, NULL,
+	    NULL, NULL, &h, NULL, NULL, 0);
+	if (rc) {
+		psclog_errorx("open %s/%s: %s", SL_RPATH_META_DIR,
+		    fn, slstrerror(rc));
+		goto out;
+	}
+	rc = mdsio_read(vfsid, &rootcreds, buf, sizeof(buf), &nb, 0, h);
+	mdsio_release(vfsid, &rootcreds, h);
+
+	if (rc) {
+		psclog_errorx("read %s/%s: %s", SL_RPATH_META_DIR,
+		    fn, slstrerror(rc));
+		goto out;
+	}
+
+	buf[nb - 1] = '\0';
+	* id = strtoull(buf, &endp, 16);
+	if (*endp || endp == buf) {
+		rc = EINVAL;
+		psclog_errorx("read %s/%s: %s", SL_RPATH_META_DIR,
+		    fn, slstrerror(rc));
+	}
+out:
+	return (rc);
+}
+
+
+/*
+ * XXX Allow an empty file system to register and fill in contents later.
+ *     Or use slmctl to register a new file system when it is ready.
+ */
+void
+psc_register_filesystem(int vfsid)
+{
+	int i, rc, found1, found2;
+	uint64_t fsid;
+	uint64_t uuid;
+	struct psc_hashbkt *b;
+	struct rootNames *entry;
+	int root_vfsid;
+	char *fsname;
+    	mdsio_fid_t mfp;
+	struct srt_stat sstb;
+
+	psclog_warnx("Checking file system %s\n", zfsMount[vfsid].name);
+	if (zfsMount[vfsid].name[0] != '/') {
+		psclog_warnx("Bogus file system name: %s", zfsMount[vfsid].name);
+		return;
+	}
+
+	/*
+ 	 * Mimic the behaviour of lib/libzfs/libzfs_mount.c.  Because we are not
+ 	 * fuse mounted, we can't rely on the zfs utility to do this for us.
+ 	 *
+ 	 * libzfs_mount.c actually does a mkdirp().  Since we only do one mkdir,
+ 	 * any new file system must mount directly under the root.
+ 	 */
+	fsname = strchr(&zfsMount[vfsid].name[1], '/');
+	if (!(zfsMount[vfsid].flag & ZFS_SLASH2_MKDIR) && fsname) {
+		fsname++;
+		/* make sure that the newly mounted file system has an entry */
+		mdsio_fid_to_vfsid(SLFID_ROOT, &root_vfsid);
+		rc = mdsio_lookup(root_vfsid, MDSIO_FID_ROOT, fsname,
+		        &mfp, &rootcreds, NULL);
+		if (rc == ENOENT) {
+			sstb.sst_mode = 0755;
+			sstb.sst_uid = rootcreds.scr_uid;
+			sstb.sst_gid = rootcreds.scr_gid;
+			rc = mdsio_mkdir(root_vfsid, MDSIO_FID_ROOT, fsname, &sstb,
+	    			0, MDSIO_OPENCRF_NOLINK, NULL, NULL, NULL, NULL, 0);
+		}
+		if (rc) {
+			psclog_warnx("Verify %s entry: %s", fsname, slstrerror(rc));
+			goto out;
+		}
+	}
+	zfsMount[vfsid].flag |= ZFS_SLASH2_MKDIR;
+
+	rc = mdsio_lookup(vfsid, MDSIO_FID_ROOT, SL_RPATH_META_DIR,
+	    &mds_metadir_inum[vfsid], &rootcreds, NULL);
+	if (rc) {
+		psclog_warnx("lookup .slmd metadir: %s", slstrerror(rc));
+		goto out;
+	}
+
+	rc = mdsio_lookup(vfsid, mds_metadir_inum[vfsid], SL_RPATH_UPSCH_DIR,
+	    &mds_upschdir_inum[vfsid], &rootcreds, NULL);
+	if (rc) {
+		psclog_warnx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
+			SL_RPATH_UPSCH_DIR, slstrerror(rc));
+		goto out;
+	}
+
+	rc = mdsio_lookup(vfsid, mds_metadir_inum[vfsid], SL_RPATH_FIDNS_DIR,
+		&mds_fidnsdir_inum[vfsid], &rootcreds, NULL);
+	if (rc) {
+		psclog_warnx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
+			SL_RPATH_FIDNS_DIR, slstrerror(rc));
+		goto out;
+	}
+
+	rc = mdsio_lookup(vfsid, mds_metadir_inum[vfsid], SL_RPATH_TMP_DIR,
+		&mds_tmpdir_inum[vfsid], &rootcreds, NULL);
+	if (rc) {
+		psclog_warnx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
+			SL_RPATH_TMP_DIR, slstrerror(rc));
+		goto out;
+	}
+
+	rc = read_vfsid(vfsid, SL_FN_FSID, &zfsMount[vfsid].fsid);
+	if (rc)
+		goto out;
+	rc = read_vfsid(vfsid, SL_FN_FSUUID, &zfsMount[vfsid].uuid);
+	if (rc)
+		goto out;
+
+	found1 = 0;
+	found2 = 0;
+	fsid = zfsMount[vfsid].fsid;
+	uuid = zfsMount[vfsid].uuid;
+	for (i = 0; i < mount_index; i++) {
+		if (i == vfsid)
+			continue;
+		if (zfsMount[i].fsid == fsid)
+			found1++;
+		if (zfsMount[i].uuid == uuid)
+			found2++;
+	}
+	if (found1) {
+		psclog_warnx("Duplicate FSID found: %"PRIx64"\n", fsid);
+		goto out;
+	}
+	if (found2) {
+		psclog_warnx("Duplicate UUID found: %"PRIx64"\n", uuid);
+		goto out;
+	}
+	rc = zfsslash2_build_immns_cache(vfsid);
+	if (rc) {
+		psclog_warnx("Fail to create cache for file system %s\n", 
+			basename(zfsMount[vfsid].name));
+		goto out;
+	}
+
+	entry = PSCALLOC(sizeof(struct rootNames));
+	if (!entry) {
+		psclog_warnx("Fail to allocate memory to register %s\n", 
+			basename(zfsMount[vfsid].name));
+		goto out;
+	}
+
+	strcpy(entry->rn_name, basename(zfsMount[vfsid].name));
+	entry->rn_vfsid = vfsid;
+	psc_hashent_init(&rootHtable, entry);
+	b = psc_hashbkt_get(&rootHtable, entry->rn_name);
+	psc_hashbkt_add_item(&rootHtable, b, entry);
+
+	zfsMount[vfsid].flag |= ZFS_SLASH2_READY;
+	psclog_warnx("File system %s registered (%"PRIx64":%"PRIx64").\n", 
+		basename(zfsMount[vfsid].name), fsid, uuid);
+ out:
+	return;
+}
+
+psc_spinlock_t  scan_lock = SPINLOCK_INIT;
+
+/*
+ * Scan for newly added file systems in the pool
+ */
+void
+psc_scan_filesystems(void)
+{
+	int i;
+	spinlock(&scan_lock);
+	for (i = 0; i < mount_index; i++) {
+		if (!(zfsMount[i].flag & ZFS_SLASH2_READY))
+			psc_register_filesystem(i);
+	}
+	freelock(&scan_lock);
+}
+
+int
 main(int argc, char *argv[])
 {
 	char *zpcachefn = NULL, *zpname;
 	const char *cfn, *sfn, *p;
-	int rc, c, nofsuuid = 0;
-	mdsio_fid_t mf;
+	int c, found, nofsuuid = 0;
 
+	int vfsid;
+
 	/* gcrypt must be initialized very early on */
 	gcry_control(GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);
 	if (!gcry_check_version(GCRYPT_VERSION))
@@ -241,6 +457,15 @@
 	fidc_init(sizeof(struct fcmh_mds_info), FIDC_MDS_DEFSZ);
 	bmap_cache_init(sizeof(struct bmap_mds_info));
 
+	authbuf_createkeyfile();
+	authbuf_readkeyfile();
+
+	sl_drop_privs(allow_root_uid);
+
+	libsl_init(2 * (SLM_RMM_NBUFS + SLM_RMI_NBUFS + SLM_RMC_NBUFS));
+
+	slm_workq_init();
+
 	/*
 	 * Initialize the mdsio layer.  There is where ZFS threads
 	 * are started and the given ZFS pool is imported.
@@ -248,76 +473,29 @@
 	mdsio_init();
 	import_zpool(zpname, zpcachefn);
 
-	rc = mdsio_lookup(MDSIO_FID_ROOT, SL_RPATH_META_DIR,
-	    &mds_metadir_inum, &rootcreds, NULL);
-	if (rc)
-		psc_fatalx("lookup .slmd metadir: %s", slstrerror(rc));
+	psc_hashtbl_init(&rootHtable, PHTF_STR, struct rootNames,
+		rn_name, rn_hentry, 1024, NULL, "rootnames");
 
-	rc = mdsio_lookup(mds_metadir_inum, SL_RPATH_UPSCH_DIR,
-	    &mds_upschdir_inum, &rootcreds, NULL);
-	if (rc)
-		psc_fatalx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
-		    SL_RPATH_UPSCH_DIR, slstrerror(rc));
+	for (vfsid = 0; vfsid < mount_index; vfsid++)
+		psc_register_filesystem(vfsid);
 
-	rc = mdsio_lookup(mds_metadir_inum, SL_RPATH_FIDNS_DIR,
-	    &mds_fidnsdir_inum, &rootcreds, NULL);
-	if (rc)
-		psc_fatalx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
-		    SL_RPATH_FIDNS_DIR, slstrerror(rc));
-
-	rc = mdsio_lookup(mds_metadir_inum, SL_RPATH_TMP_DIR,
-	    &mds_tmpdir_inum, &rootcreds, NULL);
-	if (rc)
-		psc_fatalx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
-		    SL_RPATH_TMP_DIR, slstrerror(rc));
-
-	rc = mdsio_lookup(mds_metadir_inum, SL_FN_FSUUID, &mf,
-	    &rootcreds, NULL);
-	if (rc)
-		psclog_errorx("lookup %s/%s: %s", SL_RPATH_META_DIR,
-		    SL_FN_FSUUID, slstrerror(rc));
-	else {
-		char *endp, buf[17] = "";
-		size_t nb;
-		void *h;
-
-		rc = mdsio_opencreate(mf, &rootcreds, O_RDONLY, 0, NULL,
-		    NULL, NULL, &h, NULL, NULL, 0);
-		if (rc)
-			PFL_GOTOERR(skipfsuuid, rc);
-		rc = mdsio_read(&rootcreds, buf, sizeof(buf), &nb, 0,
-		    h);
-		mdsio_release(&rootcreds, h);
-
-		if (rc)
-			goto skipfsuuid;
-		if (nb != sizeof(buf))
-			PFL_GOTOERR(skipfsuuid, rc = SLERR_SHORTIO);
-		buf[sizeof(buf) - 1] = '\0';
-		slm_fsuuid = strtoull(buf, &endp, 16);
-		if (*endp || endp == buf)
-			PFL_GOTOERR(skipfsuuid, rc = EINVAL);
-
-		if (0) {
- skipfsuuid:
-			psclog_errorx("%s/%s: %s %s",
-			    SL_RPATH_META_DIR, SL_FN_FSUUID,
-			    buf, slstrerror(rc));
-			slm_fsuuid = 0;
+	found = 0;
+	for (vfsid = 0; vfsid < mount_index; vfsid++) {
+		if (globalConfig.gconf_fsuuid == zfsMount[vfsid].uuid) {
+			psc_assert(!found);
+			found = 1;
+			current_vfsid = vfsid;
+			psclog_warnx("File system %s (id = %d) matches UUID %"PRIx64,
+			    zfsMount[vfsid].name, vfsid, globalConfig.gconf_fsuuid);
 		}
 	}
+	if (!found)
+		psc_fatalx("config UUID=%"PRIx64" doesn't match any file system",
+		    globalConfig.gconf_fsuuid);
 
-	zfsslash2_build_immns_cache();
+	/* using hook can cause layer violation */
+	zfsslash2_register_hook(psc_register_filesystem);
 
-	authbuf_createkeyfile();
-	authbuf_readkeyfile();
-
-	sl_drop_privs(allow_root_uid);
-
-	libsl_init(2 * (SLM_RMM_NBUFS + SLM_RMI_NBUFS + SLM_RMC_NBUFS));
-
-	slm_workq_init();
-
 	psc_poolmaster_init(&upsched_poolmaster,
 	    struct up_sched_work_item, uswi_lentry, PPMF_AUTO, 256, 256,
 	    0, NULL, NULL, NULL, "upschwk");
@@ -334,19 +512,10 @@
 	sl_nbrqset = pscrpc_nbreqset_init(NULL, NULL);
 	pscrpc_nbreapthr_spawn(sl_nbrqset, SLMTHRT_NBRQ, "slmnbrqthr");
 
-	if (!nofsuuid) {
-		if (globalConfig.gconf_fsuuid != slm_fsuuid)
-			psc_fatalx("config UUID=%"PRIx64" doesn't match "
-			    "FS UUID=%"PRIx64,
-			    globalConfig.gconf_fsuuid, slm_fsuuid);
-	} else
-		psclog_warnx("config UUID=%"PRIx64" doesn't match FS "
-		    "UUID=%"PRIx64, globalConfig.gconf_fsuuid, slm_fsuuid);
-
 	psclog_info("SLASH2 metadata daemon (mds) revision is %d",
 	    SL_STK_VERSION);
+	mds_journal_init(disable_propagation, zfsMount[current_vfsid].uuid);
 
-	mds_journal_init(disable_propagation, (nofsuuid ? 0 : slm_fsuuid));
 	mds_odtable_load(&mdsBmapAssignTable, SL_FN_BMAP_ODTAB,
 	    "bmapassign");
 	mds_bmap_timeotbl_init();
Index: slash_nara/slashd/rmm.c
===================================================================
--- slash_nara/slashd/rmm.c	(revision 19179)
+++ slash_nara/slashd/rmm.c	(working copy)
@@ -164,6 +164,7 @@
 	struct srt_stat sstb;
 	void *mdsio_data;
 	char *from, *to;
+	int vfsid;
 
 	p = op = np = NULL;
 	SL_RSX_ALLOCREP(rq, mq, mp);
@@ -181,6 +182,11 @@
 	psclog_info("op=%d, fid="SLPRI_FID", name=%s", mq->op, mq->fid,
 	    mq->req.name);
 
+	if (mdsio_fid_to_vfsid(mq->fg.fg_fid, &vfsid)) {
+		mp->rc = EINVAL;
+		return (0);
+	}
+
 	mds_reserve_slot(1);
 	switch (mq->op) {
 	    case SLM_FORWARD_MKDIR:
@@ -190,7 +196,7 @@
 		sstb.sst_mode = mq->mode;
 		sstb.sst_uid = mq->creds.scr_uid;
 		sstb.sst_gid = mq->creds.scr_gid;
-		mp->rc = mdsio_mkdir(fcmh_2_mdsio_fid(p), mq->req.name,
+		mp->rc = mdsio_mkdir(vfsid, fcmh_2_mdsio_fid(p), mq->req.name,
 		    &sstb, 0, 0, &mp->cattr, NULL, mdslog_namespace,
 		    NULL, mq->fid);
 		break;
@@ -198,25 +204,25 @@
 		mp->rc = slm_fcmh_get(&mq->fg, &p);
 		if (mp->rc)
 			break;
-		mp->rc = mdsio_opencreate(fcmh_2_mdsio_fid(p),
+		mp->rc = mdsio_opencreate(vfsid, fcmh_2_mdsio_fid(p),
 		    &mq->creds, O_CREAT | O_EXCL | O_RDWR, mq->mode,
 		    mq->req.name, NULL, &mp->cattr, &mdsio_data,
 		    mdslog_namespace, NULL, mq->fid);
 		if (!mp->rc)
-			mdsio_release(&rootcreds, mdsio_data);
+			mdsio_release(vfsid, &rootcreds, mdsio_data);
 		break;
 	    case SLM_FORWARD_RMDIR:
 		mp->rc = slm_fcmh_get(&mq->fg, &p);
 		if (mp->rc)
 			break;
-		mp->rc = mdsio_rmdir(fcmh_2_mdsio_fid(p), &mp->fid,
+		mp->rc = mdsio_rmdir(vfsid, fcmh_2_mdsio_fid(p), &mp->fid,
 		    mq->req.name, &rootcreds, mdslog_namespace);
 		break;
 	    case SLM_FORWARD_UNLINK:
 		mp->rc = slm_fcmh_get(&mq->fg, &p);
 		if (mp->rc)
 			break;
-		mp->rc = mdsio_unlink(fcmh_2_mdsio_fid(p), &mp->fid,
+		mp->rc = mdsio_unlink(vfsid, fcmh_2_mdsio_fid(p), &mp->fid,
 		    mq->req.name, &rootcreds, mdslog_namespace,
 		    &mp->cattr);
 		break;
@@ -229,7 +235,7 @@
 			break;
 		from = mq->req.name;
 		to = mq->req.name + strlen(mq->req.name) + 1;
-		mp->rc = mdsio_rename(fcmh_2_mdsio_fid(op), from,
+		mp->rc = mdsio_rename(vfsid, fcmh_2_mdsio_fid(op), from,
 		    fcmh_2_mdsio_fid(np), to, &rootcreds,
 		    mdslog_namespace, &mp->cattr);
 		break;
@@ -242,7 +248,7 @@
 		mp->rc = slm_fcmh_get(&mq->fg, &p);
 		if (mp->rc)
 			break;
-		mp->rc = mdsio_setattr(fcmh_2_mdsio_fid(p),
+		mp->rc = mdsio_setattr(vfsid, fcmh_2_mdsio_fid(p),
 		    &mq->req.sstb, mq->to_set, &rootcreds, &mp->cattr,
 		    fcmh_2_mdsio_data(p), mdslog_namespace);
 		break;
@@ -366,6 +372,11 @@
 	if (rc)
 		goto out;
 
+#if 0
+	/*
+ 	 * We don't replicate namespace in a piecemeal fashion any more.
+ 	 * Instead, the plan is to use snapshot.
+ 	 */
 	switch (op) {
 	    case SLM_FORWARD_MKDIR:
 		rc = mdsio_redo_mkdir(mq->fg.fg_fid, name, &mp->cattr);
@@ -401,6 +412,7 @@
 	}
 	psclog_errorx("replay failed: op=%d fid="SLPRI_FID" name=%s rc=%d",
 	    op, mq->fg.fg_fid, name, rc);
+#endif
 
  out:
 	if (rq)
Index: slash_nara/slashd/replay.c
===================================================================
--- slash_nara/slashd/replay.c	(revision 19179)
+++ slash_nara/slashd/replay.c	(working copy)
@@ -29,12 +29,24 @@
 #include "pathnames.h"
 #include "repl_mds.h"
 #include "slerr.h"
+#include "zfs-fuse/zfs_slashlib.h"
 
 #define B_REPLAY_OP_CRC		0
 #define B_REPLAY_OP_REPLS	1
 
 #define I_REPLAY_OP_REPLS	0
 
+/*
+ * Alternatively, we could add vfsid to each log entry in the journal.  But doing
+ * so can break backward compatibility. It also reduces the space of each log
+ * entry.  We could infer vfsid from the fid stored in a log entry.  But some 
+ * entries such as bmap assignment log entries do not have one.
+ * 
+ * Actually, we can use the FSUUID stored in the log header to do the matching.
+ */
+
+extern int current_vfsid;
+
 /**
  * mds_replay_bmap - Replay an operation on a bmap.
  */
@@ -78,7 +90,7 @@
 
 		FCMH_LOCK(f);
 		ih = fcmh_2_inoh(f);
-		idx = mds_repl_ios_lookup(ih, sjbc->sjbc_iosid);
+		idx = mds_repl_ios_lookup(current_vfsid, ih, sjbc->sjbc_iosid);
 		if (idx < 0) {
 			psclog_errorx("iosid %d not found in repl "
 			    "table", sjbc->sjbc_iosid);
@@ -87,9 +99,9 @@
 		sstb.sst_blocks = sjbc->sjbc_aggr_nblks;
 		fcmh_set_repl_nblks(f, idx, sjbc->sjbc_repl_nblks);
 		if (idx >= SL_DEF_REPLICAS)
-			rc = mds_inox_write(ih, NULL, NULL);
+			rc = mds_inox_write(current_vfsid, ih, NULL, NULL);
 		else
-			rc = mds_inode_write(ih, NULL, NULL);
+			rc = mds_inode_write(current_vfsid, ih, NULL, NULL);
 		if (rc)
 			goto out;
 
@@ -101,7 +113,7 @@
 			sstb.sst_size = sjbc->sjbc_fsize;
 			fl |= PSCFS_SETATTRF_DATASIZE;
 		}
-		rc = mds_fcmh_setattr_nolog(f, fl, &sstb);
+		rc = mds_fcmh_setattr_nolog(current_vfsid, f, fl, &sstb);
 		if (rc)
 			goto out;
 
@@ -215,7 +227,7 @@
 			memcpy(ih->inoh_extras->inox_repls,
 			    &sjir->sjir_repls[SL_DEF_REPLICAS],
 			    sizeof(ih->inoh_extras->inox_repls));
-			rc = mds_inox_write(ih, NULL, NULL);
+			rc = mds_inox_write(current_vfsid, ih, NULL, NULL);
 			if (rc)
 				goto out;
 
@@ -231,7 +243,7 @@
 		psc_fatalx("unknown op");
 	}
 
-	rc = mds_inode_write(ih, NULL, NULL);
+	rc = mds_inode_write(current_vfsid, ih, NULL, NULL);
 
  out:
 	if (ih)
@@ -250,7 +262,7 @@
 	int rc;
 
 	sjir = PJE_DATA(pje);
-	rc = mdsio_redo_fidlink(sjir->sjir_fid, &rootcreds);
+	rc = mdsio_redo_fidlink(current_vfsid, sjir->sjir_fid, &rootcreds);
 	if (!rc)
 	    rc = mds_replay_ino(sjir, I_REPLAY_OP_REPLS);
 	return (rc);
@@ -287,15 +299,15 @@
 	if (logentry->sjar_flags & SLJ_ASSIGN_REP_REP)
 		mds_replay_bmap(&logentry->sjar_rep,
 		    B_REPLAY_OP_REPLS);
-	rc = mdsio_lookup(mds_metadir_inum, SL_FN_BMAP_ODTAB, &mf,
+	rc = mdsio_lookup(current_vfsid, mds_metadir_inum[current_vfsid], SL_FN_BMAP_ODTAB, &mf,
 	    &rootcreds, NULL);
 	psc_assert(rc == 0);
 
-	rc = mdsio_opencreate(mf, &rootcreds, O_RDWR, 0, NULL, NULL,
+	rc = mdsio_opencreate(current_vfsid, mf, &rootcreds, O_RDWR, 0, NULL, NULL,
 	    NULL, &handle, NULL, NULL, 0);
 	psc_assert(!rc && handle);
 
-	rc = mdsio_read(&rootcreds, &odth, sizeof(odth), &nb, 0,
+	rc = mdsio_read(current_vfsid, &rootcreds, &odth, sizeof(odth), &nb, 0,
 	    handle);
 	psc_assert(rc == 0 && nb == sizeof(odth));
 
@@ -331,13 +343,13 @@
 	if (logentry->sjar_flags & SLJ_ASSIGN_REP_FREE)
 		odtf->odtf_inuse = ODTBL_FREE;
 
-	rc = mdsio_write(&rootcreds, p, odth.odth_slotsz,
+	rc = mdsio_write(current_vfsid, &rootcreds, p, odth.odth_slotsz,
 	   &nb, odth.odth_start + elem * odth.odth_slotsz,
 	   0, handle, NULL, NULL);
 	psc_assert(!rc && nb == odth.odth_slotsz);
 
 	PSCFREE(p);
-	mdsio_release(&rootcreds, handle);
+	mdsio_release(current_vfsid, &rootcreds, handle);
 	return (0);
 }
 
@@ -400,31 +412,31 @@
 		rc = 0;
 		break;
 	    case NS_OP_CREATE:
-		rc = mdsio_redo_create(sjnm->sjnm_parent_fid, name,
+		rc = mdsio_redo_create(current_vfsid, sjnm->sjnm_parent_fid, name,
 		    &sstb);
 		break;
 	    case NS_OP_MKDIR:
-		rc = mdsio_redo_mkdir(sjnm->sjnm_parent_fid, name,
+		rc = mdsio_redo_mkdir(current_vfsid, sjnm->sjnm_parent_fid, name,
 		    &sstb);
 		break;
 	    case NS_OP_LINK:
-		rc = mdsio_redo_link(sjnm->sjnm_parent_fid,
+		rc = mdsio_redo_link(current_vfsid, sjnm->sjnm_parent_fid,
 		    sjnm->sjnm_target_fid, name, &sstb);
 		break;
 	    case NS_OP_SYMLINK:
-		rc = mdsio_redo_symlink(sjnm->sjnm_parent_fid,
+		rc = mdsio_redo_symlink(current_vfsid, sjnm->sjnm_parent_fid,
 		    sjnm->sjnm_target_fid, name, newname, &sstb);
 		break;
 	    case NS_OP_RENAME:
-		rc = mdsio_redo_rename(sjnm->sjnm_parent_fid, name,
+		rc = mdsio_redo_rename(current_vfsid, sjnm->sjnm_parent_fid, name,
 		    sjnm->sjnm_new_parent_fid, newname, &sstb);
 		break;
 	    case NS_OP_UNLINK:
-		rc = mdsio_redo_unlink(sjnm->sjnm_parent_fid,
+		rc = mdsio_redo_unlink(current_vfsid, sjnm->sjnm_parent_fid,
 		    sjnm->sjnm_target_fid, name);
 		break;
 	    case NS_OP_RMDIR:
-		rc = mdsio_redo_rmdir(sjnm->sjnm_parent_fid,
+		rc = mdsio_redo_rmdir(current_vfsid, sjnm->sjnm_parent_fid,
 		    sjnm->sjnm_target_fid, name);
 		break;
 	    case NS_OP_SETSIZE:
@@ -439,7 +451,7 @@
 			if (fcmh)
 				FCMH_LOCK(fcmh);
 		}
-		rc = mdsio_redo_setattr(sjnm->sjnm_target_fid,
+		rc = mdsio_redo_setattr(current_vfsid, sjnm->sjnm_target_fid,
 		    sjnm->sjnm_mask, &sstb);
 		slm_setattr_core(fcmh, &sstb,
 		    mdsio_setattrmask_2_slflags(sjnm->sjnm_mask));
