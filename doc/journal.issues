06/24/2010
----------

Recently, I have removed the tiling code and instead use the pending transaction
list to hold data for log entires that need to be distilled.

Today, I have uncovered two issues with our journaling code.

(1) Right now MDS accepts updates to inode replication info and bmap CRCs
    to its private cache described as journal flush items (JFI).  They are
    flushed by the mdsfssyncthr. After flush, we close the trasaction.

    The problem is that when we close the transaction, the bmap updates
    probably have not reached the disk yet. That is controlled by ZFS.  
    mdsfssyncthr only tells ZFS that they are dirty.  The risk here is 
    that we could reclaim log space prematurely.

    We could make mdsfssyncthr do synchronous writes, but that's not good 
    for performance.

(2) Right now, we don't enforce a transaction with lower XID to be
    written earlier.  It could happen that a slot reserved by a
    trasaction is never written.   When we replay, we can find a stale
    entry in the slot.  But if we order transactions before replaying
    them.  This should be fine, assuming updates are idempotent.

    Well, life is more complicated than that. If you decide to replay XID 
    X on an item.  Then you must replay ALL transactions affecting the
    item starting from X, some of them may or may not have been overwritten.
    In other words, the history must be complete.

    The solution is easy.  Don't reserve any specific slot (remember
    traditional journal file systems reserve space amount, not specific
    location within the log area).  The idea is to consume journal space
    sequentially.  No need to reserve, just write at the current log
    tail.

(1) and (2) prompt me into thinking more on our journal code.  We already
put transaction group numbers (txn) of ZFS into our namespace log entries.  
Perhaps we should include txn into all our log entries.

If so, we can use txg to do the following:

(i) Decide whether we can reclaim log space at run time.

(ii) Decide whether we need to replay a log entry at replay time.

The possibility of unifying the way to handle both is attractive
to me.

06/25/2010
----------

Also, there will be no need to write a close log entry to mark the
closure of a transaction.  That should save us some log bandwidth.

One potential problem is that we rely on ZFS to flush its transactions
to reclaim log space.

I am thinking about invoking the log function from within ZFS, which
I can get the txg easily (like I did with the namespace).  However,
I probably have to pass in both func and data pointers so that I can
log only the changes I have made, not the entire block.


06/30/2010
----------

Here is a bit of estimate of log space consumption.  The ZFS
times out a transaction group every 30 seconds (see txg.c). Assuming
that we perform 10000 operations / second, we would need:

	30 * 10000 * 2 * 512 = 307,200,000

of log space (times 2 because each operation such as create also
needs to log bmap etc).  So this should not be a problem if we use
big enough log space.

Also, I need to call log function after dmu_tx_commit() to avoid
potential deadlock when log space is very small.  To do so, I need
to make a copy of the txg.

There used to be only one sync thread (see file mdsfssync.c) 
that commits all logs into ZFS.  Now any threads can write into ZFS 
directly.

07/07/2010
----------

Revert myself: I should do a log upcall after dmu_tx_commit() because
I want any operation to appear in our system journal first.  To
avoid deadlock with a small log file, I am going to use a reservation
system.
