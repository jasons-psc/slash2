03/13/2012
----------

Right now, we support only one file system in the pool. In the furture:

 * More than one file system per pool is allowed.

 * The contents of all file systems are accessible from a slash2 client.

 * Only one file system can be made writable per mds, all other file systems 
   are strictly read-only.

The idea is that the pool layout will be the same across MDS.  Only one MDS
can write a file system, and we will use snapshot mechanism to propagate
the updates to other MDs.

The root file system is a place holder now, not really used by any MDS.  We
need to fake the contents of the root to allow access to other file systems.
Presumably, we can put private stuff to the root file system that will not
be shared by other MDS in any way.

We will use site id bits in the fid for each file systems.  The ID of the 
root file system is 0.   

There could be compatibility issue.  Right under root, we can have existing
files and directories that do not represent a file system.


03/14/2012
----------

We need to come up with the attributes of roots of these file systems for
readdir() purpose.  Looks like I can borrow some code from zfs_root().
            
03/27/2012
----------

If the pool is created with old utility:

	- there is no fsid file in the default file system
	- new slashd should be able to read and write it
	- we can go back and forth between new and old slashd at will.

If the pool is created with new utility:

	- there is a fsid file in the default file system
	- there is NO going back

To choose a different file system, we must

	- reformat the journal with the matching uuid
	- change the uuid in the slash2 config file to match the uuid in the journal.

The uuid is used to select a file system in a pool.

04/09/2012
----------

Save patch with: svn diff --diff-cmd=diff -x -U10.

Client patch:

Index: slash_nara/mount_slash/fidc_cli.c
===================================================================
--- slash_nara/mount_slash/fidc_cli.c	(revision 19014)
+++ slash_nara/mount_slash/fidc_cli.c	(working copy)
@@ -98,47 +98,52 @@
 		fcmh->fcmh_flags |= FCMH_CLI_INITDCI;
 	}
 
 	FCMH_URLOCK(fcmh, locked);
 }
 
 int
 slc_fcmh_ctor(struct fidc_membh *fcmh)
 {
 	struct fcmh_cli_info *fci;
+#if 0
 	struct sl_resource *res;
 	struct sl_site *s;
 	sl_siteid_t siteid;
 	int i;
+#endif
 
 	fci = fcmh_get_pri(fcmh);
 	slc_fcmh_refresh_age(fcmh);
+#if 0
+	/* We may need similar code if we want to talk to a remote mds */
 	siteid = FID_GET_SITEID(fcmh_2_fid(fcmh));
 	if (fcmh_2_fid(fcmh) >= SLFID_MIN &&
 	    siteid != slc_rmc_resm->resm_siteid) {
 		s = libsl_siteid2site(siteid);
 		if (s == NULL) {
 			psclog_errorx("fid "SLPRI_FID" has "
 			    "invalid site ID %d",
 			    fcmh_2_fid(fcmh), siteid);
 			return (ESTALE);
 		}
 		SITE_FOREACH_RES(s, res, i)
 			if (res->res_type == SLREST_MDS) {
 				fci->fci_resm = psc_dynarray_getpos(
 				    &res->res_members, 0);
 				return (0);
 			}
 		psclog_errorx("fid "SLPRI_FID" has invalid site ID %d",
 		    fcmh_2_fid(fcmh), siteid);
 		return (ESTALE);
 	}
+#endif
 	fci->fci_resm = slc_rmc_resm;
 	INIT_PSC_LISTENTRY(&fci->fci_lentry);
 	return (0);
 }
 
 void
 slc_fcmh_dtor(struct fidc_membh *fcmh)
 {
 	if (fcmh_isdir(fcmh) && DIRCACHE_INITIALIZED(fcmh)) {
 		struct fcmh_cli_info *fci;


IOS patch:


Index: slash_nara/sliod/rpc_iod.c
===================================================================
--- slash_nara/sliod/rpc_iod.c	(revision 19014)
+++ slash_nara/sliod/rpc_iod.c	(working copy)
@@ -173,24 +173,27 @@
 		      globalConfig.gconf_fsroot, SL_RPATH_META_DIR,
 		      fsuuid, SL_RPATH_FIDNS_DIR);
 		
 		if (stat(fn, &stb) || !S_ISDIR(stb.st_mode))
 			psc_fatalx("sliod directories have not been created "
 			   "(uuid=%"PRIx64")", fsuuid);
 
 		globalConfig.gconf_fsuuid = sli_fsuuid = fsuuid;
 	}
 	
+#if 0
+	/* make it read-only if mismatch? */
 	if (globalConfig.gconf_fsuuid != fsuuid)
 		psc_fatalx("Mismatching UUIDs detected!  "
 		   "gconf_fsuuid=%"PRIx64" mds_fsuuid=%"PRIx64, 
 		   globalConfig.gconf_fsuuid, fsuuid);
+#endif
 
 	return;
 
  error:
 	psclog_errorx("no message; msg=%p opc=%d bufc=%d",
 	    m, m ? (int)m->opc : -1, m ? (int)m->bufcount : -1);
 }
 
 void
 sli_rpc_mds_pack_statfs(struct pscrpc_msg *m)


MDS patch:


Index: zfs/src/zfs-fuse/util.c
===================================================================
--- zfs/src/zfs-fuse/util.c	(revision 19015)
+++ zfs/src/zfs-fuse/util.c	(working copy)
@@ -28,47 +28,56 @@
 #include <sys/types.h>
 #include <sys/cred.h>
 #include <sys/cmn_err.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <pthread.h>
 #include <syslog.h>
 #include <signal.h>
 
+#include "sys/zfs_znode.h"
+
 #include "libsolkerncompat.h"
 #include "zfs_ioctl.h"
 #include "zfsfuse_socket.h"
 
 #include "cmd_listener.h"
 
 #ifdef ZFS_SLASHLIB
 #include "zfs_slashlib.h"
 #else
 #include "fuse_listener.h"
 
 #include "fuse.h"
 #include "zfs_operations.h"
 #endif
 #include "util.h"
 
+#include "zfs_slashlib.h"
+
 static int ioctl_fd = -1;
 static int lock_fd = -1;
 
 #define LOCKDIR "/var/lock/zfs"
 #define LOCKFILE LOCKDIR "/zfs_lock"
 
 boolean_t listener_thread_started = B_FALSE;
 pthread_t listener_thread;
 
 int num_filesystems;
 
+int		mount_index;
+mount_info_t	zfsMount[MAX_FILESYSTEMS];
+
+void (*zfsslash2_hook_func)(int) = NULL;
+
 char * fuse_mount_options;
 char * zfs_lock_file;
 
 extern vfsops_t *zfs_vfsops;
 extern int zfs_vfsinit(int fstype, char *name);
 
 static int zfsfuse_do_locking(int in_child)
 {
 	/* Ignores errors since the directory might already exist */
 	mkdir(LOCKDIR, 0700);
@@ -306,49 +315,47 @@
 
 #ifdef DEBUG
 uint32_t t_mounted = 0;
 #endif
 
 int do_mount(char *spec, char *dir, int mflag, char *opt)
 {
 	static int mounted=0;
 	extern void *zfsVfs;
 
+	int error;
+	znode_t *rootzp;
+	zfsvfs_t *zfsvfs;
+	file_info_t *finfo;
+
 	VERIFY(mflag == 0);
 
 	vfs_t *vfs = kmem_zalloc(sizeof(vfs_t), KM_SLEEP);
 	if(vfs == NULL)
 		return ENOMEM;
 
-#if 0
-	if (mounted) 
-		return EALREADY;
-#endif
-
 	VFS_INIT(vfs, zfs_vfsops, 0);
 	VFS_HOLD(vfs);
 
-	zfsVfs = vfs;
-
 	struct mounta uap = {
 	.spec = spec,
 	.dir = dir,
 	.flags = mflag | MS_SYSSPACE,
 	.fstype = "zfs-fuse",
 	.dataptr = "",
 	.datalen = 0,
 	.optptr = opt,
 	.optlen = strlen(opt)
 	};
 
 	int ret;
-	if ((ret = VFS_MOUNT(vfs, rootdir, &uap, kcred)) != 0) {
+	if ((ret = VFS_MOUNT(vfs, rootdir, &uap, kcred)) != 0) {	/* zfs_mount */
 		kmem_free(vfs, sizeof(vfs_t));
 		return ret;
 	} else
 		mounted = 1;
 	/* Actually, optptr is totally ignored by VFS_MOUNT.
 	 * So we are going to pass this with fuse_mount_options if possible */
 	char real_opts[1024];
 	*real_opts = 0;
 	if (*fuse_mount_options)
 		strcat(real_opts,fuse_mount_options); // comes with a starting ,
@@ -407,20 +414,51 @@
 	}
 
 	fuse_session_add_chan(se, ch);
 
 	if(zfsfuse_newfs(dir, ch) != 0) {
 		fuse_session_destroy(se);
 		fuse_unmount(dir,ch);
 		return EIO;
 	}
 #endif
+
+#ifdef ZFS_SLASHLIB
+	if (mount_index >= MAX_FILESYSTEMS - 1)
+		return ENOMEM;
+
+	zfsvfs = vfs->vfs_data;
+	ASSERT(zfsvfs->z_root == 3);
+	zfsMount[mount_index].rootid = zfsvfs->z_root; 
+
+	error = zfs_zget(zfsvfs, zfsvfs->z_root, &rootzp, B_FALSE);
+	ASSERT(!error);
+
+	finfo = kmem_cache_alloc(file_info_cache, KM_NOSLEEP);
+	ASSERT(finfo);
+
+	finfo->vp = ZTOV(rootzp);
+	finfo->flags = 0;
+
+	zfsMount[mount_index].rootinfo = finfo;
+
+	zfsMount[mount_index].vfs = vfs;
+	zfsMount[mount_index].fsid = -1;
+	zfsMount[mount_index].uuid = -1; 
+	strcpy(zfsMount[mount_index].name, dir);
+
+	if (zfsslash2_hook_func)
+		zfsslash2_hook_func(mount_index);
+
+	mount_index++;
+#endif
+
 	return 0;
 }
 
 int do_umount(vfs_t *vfs, boolean_t force)
 {
 	VFS_SYNC(vfs, 0, kcred);
 
 	int ret = VFS_UNMOUNT(vfs, force ? MS_FORCE : 0, kcred);
 	if(ret != 0)
 		return ret;
Index: zfs/src/zfs-fuse/zfs_slashlib.h
===================================================================
--- zfs/src/zfs-fuse/zfs_slashlib.h	(revision 19015)
+++ zfs/src/zfs-fuse/zfs_slashlib.h	(working copy)
@@ -12,66 +12,94 @@
 
 struct statvfs;
 
 #ifdef ZFS_SLASHLIB
 typedef struct file_info {
 	vnode_t *vp;
 	int flags;
 } file_info_t;
 #endif
 
+#define MAX_FILESYSTEMS		1000
+
+typedef struct mount_info {
+	uint64_t	 fsid;
+	uint64_t	 uuid;
+	uint64_t	 rootid;
+	char		 name[MAXPATHLEN];
+	void		*vfs;
+	void		*rootinfo;
+} mount_info_t;
+
+extern int		mount_index;
+extern mount_info_t	zfsMount[MAX_FILESYSTEMS];
+
+extern int		current_vfsid;
+
+extern void (*zfsslash2_hook_func)(int);
+
 //XXX shouldn't this be a single bit???
 #define SLASH2_CURSOR_FLAG	0x12345678	/* overload the ioflag of zfs_write() */
 
-int	zfsslash2_access(mdsio_fid_t, int, const struct slash_creds *);
-int	zfsslash2_fsync(const struct slash_creds *, int, void *);
-int	zfsslash2_getattr(mdsio_fid_t, void *finfo, const struct slash_creds *, struct srt_stat *);
-int	zfsslash2_link(mdsio_fid_t, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, sl_log_update_t);
-int	zfsslash2_lookup(mdsio_fid_t, const char *, mdsio_fid_t *, const struct slash_creds *, struct srt_stat *);
-int	zfsslash2_lookup_slfid(slfid_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *);
-int	zfsslash2_mkdir(mdsio_fid_t, const char *, const struct srt_stat *, int, int, struct srt_stat *, mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
-int	zfsslash2_mknod(mdsio_fid_t, const char *, mode_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t);
-int	zfsslash2_opencreate(mdsio_fid_t, const struct slash_creds *, int, int, mode_t, const char *, mdsio_fid_t *, struct srt_stat *, void *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
-int	zfsslash2_opendir(mdsio_fid_t, const struct slash_creds *, struct slash_fidgen *, void *);
-int	zfsslash2_preadv(const struct slash_creds *, struct iovec *, int, size_t *, off_t, void *);
-int	zfsslash2_pwritev(const struct slash_creds *, const struct iovec *, int, size_t *, off_t, int, void *, sl_log_write_t, void *);
-int	zfsslash2_read(const struct slash_creds *, void *, size_t, size_t *, off_t, void *);
-int	zfsslash2_readdir(const struct slash_creds *, size_t, off_t, void *, size_t *, size_t *, void  *, int, void *);
-int	zfsslash2_readlink(mdsio_fid_t, char *, const struct slash_creds *);
-int	zfsslash2_release(const struct slash_creds *, void *);
-int	zfsslash2_rename(mdsio_fid_t, const char *, mdsio_fid_t, const char *, const struct slash_creds *, sl_log_update_t, void *);
-int	zfsslash2_rmdir(mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t);
-int	zfsslash2_setattr(mdsio_fid_t, const struct srt_stat *, int, const struct slash_creds *, struct srt_stat *, void *, sl_log_update_t);
-int	zfsslash2_statfs(struct statvfs *);
-int	zfsslash2_symlink(const char *, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *, sl_getslfid_cb_t, sl_log_update_t);
-int	zfsslash2_unlink(mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t, void *);
-int	zfsslash2_write(const struct slash_creds *, const void *, size_t, size_t *, off_t, int, void *, sl_log_write_t, void *);
+int	zfsslash2_access(int, mdsio_fid_t, int, const struct slash_creds *);
+int	zfsslash2_fsync(int, const struct slash_creds *, int, void *);
+int	zfsslash2_getattr(int, mdsio_fid_t, void *finfo, const struct slash_creds *, struct srt_stat *);
+int	zfsslash2_link(int, mdsio_fid_t, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, sl_log_update_t);
+int	zfsslash2_lookup(int, mdsio_fid_t, const char *, mdsio_fid_t *, const struct slash_creds *, struct srt_stat *);
+int	zfsslash2_lookup_slfid(int, slfid_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *);
+int	zfsslash2_mkdir(int, mdsio_fid_t, const char *, const struct srt_stat *, int, int, struct srt_stat *, \
+			mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
+int	zfsslash2_mknod(int, mdsio_fid_t, const char *, mode_t, const struct slash_creds *, struct srt_stat *, \
+			mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t);
+int	zfsslash2_opencreate(int, mdsio_fid_t, const struct slash_creds *, int, int, mode_t, const char *, mdsio_fid_t *, \
+			     struct srt_stat *, void *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
+int	zfsslash2_opendir(int, mdsio_fid_t, const struct slash_creds *, struct slash_fidgen *, void *);
+int	zfsslash2_preadv(int, const struct slash_creds *, struct iovec *, int, size_t *, off_t, void *);
+int	zfsslash2_pwritev(int, const struct slash_creds *, const struct iovec *, int, size_t *, off_t, int, \
+			  void *, sl_log_write_t, void *);
+int	zfsslash2_read(int, const struct slash_creds *, void *, size_t, size_t *, off_t, void *);
+int	zfsslash2_readdir(int, const struct slash_creds *, size_t, off_t, void *, size_t *, size_t *, void  *, int, void *);
+int	zfsslash2_readlink(int, mdsio_fid_t, char *, const struct slash_creds *);
+int	zfsslash2_release(int, const struct slash_creds *, void *);
+int	zfsslash2_rename(int, mdsio_fid_t, const char *, mdsio_fid_t, const char *, const struct slash_creds *, \
+			 sl_log_update_t, void *);
+int	zfsslash2_rmdir(int, mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t);
+int	zfsslash2_setattr(int, mdsio_fid_t, const struct srt_stat *, int, const struct slash_creds *, \
+			  struct srt_stat *, void *, sl_log_update_t);
+int	zfsslash2_statfs(int, struct statvfs *);
+int	zfsslash2_symlink(int, const char *, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, \
+			  mdsio_fid_t *, sl_getslfid_cb_t, sl_log_update_t);
+int	zfsslash2_unlink(int, mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t, void *);
+int	zfsslash2_write(int, const struct slash_creds *, const void *, size_t, size_t *, off_t, int, void *, sl_log_write_t, void *);
 
-int	zfsslash2_write_cursor(void *, size_t, void *, sl_log_write_t);
+int	zfsslash2_write_cursor(int, void *, size_t, void *, sl_log_write_t);
 
 int	do_init_fusesocket(void);
 int	do_init(void);
 void	do_exit(void);
 
 #define libzfs_init_fusesocket	do_init_fusesocket
 #define libzfs_init		do_init
 #define libzfs_exit		do_exit
 
-void	zfsslash2_build_immns_cache(void);
+void	zfsslash2_register_hook(void *);
+int	zfsslash2_build_immns_cache(int);
 int	zfsslash2_setattrmask_2_slflags(uint);
 uint	zfsslash2_slflags_2_setattrmask(int);
 
-int	zfsslash2_replay_create(slfid_t, char *, struct srt_stat *stat);
-int	zfsslash2_replay_fidlink(slfid_t, const struct slash_creds *);
-int	zfsslash2_replay_link(slfid_t, slfid_t, char *, struct srt_stat *stat);
-int	zfsslash2_replay_mkdir(slfid_t, char *, struct srt_stat *stat);
-int	zfsslash2_replay_rename(slfid_t, const char *, slfid_t, const char *, struct srt_stat *);
-int	zfsslash2_replay_rmdir(slfid_t, slfid_t, char *);
-int	zfsslash2_replay_setattr(slfid_t, uint, struct srt_stat *);
-int	zfsslash2_replay_symlink(slfid_t, slfid_t, char *, char *, struct srt_stat *stat);
-int	zfsslash2_replay_unlink(slfid_t, slfid_t, char *);
+int	zfsslash2_replay_create(int, slfid_t, char *, struct srt_stat *stat);
+int	zfsslash2_replay_fidlink(int, slfid_t, const struct slash_creds *);
+int	zfsslash2_replay_link(int, slfid_t, slfid_t, char *, struct srt_stat *stat);
+int	zfsslash2_replay_mkdir(int, slfid_t, char *, struct srt_stat *stat);
+int	zfsslash2_replay_rename(int, slfid_t, const char *, slfid_t, const char *, struct srt_stat *);
+int	zfsslash2_replay_rmdir(int, slfid_t, slfid_t, char *);
+int	zfsslash2_replay_setattr(int, slfid_t, uint, struct srt_stat *);
+int	zfsslash2_replay_symlink(int, slfid_t, slfid_t, char *, char *, struct srt_stat *stat);
+int	zfsslash2_replay_unlink(int, slfid_t, slfid_t, char *);
 
 uint64_t	zfsslash2_last_synced_txg(void);
 uint64_t	zfsslash2_return_synced(void);
 void		zfsslash2_wait_synced(uint64_t);
 
+int		mdsio_fid_to_vfsid(slfid_t, int *);
+
 #endif /* _ZFS_SLASHLIB_H_ */
Index: zfs/src/zfs-fuse/zfs_operations_slash.c
===================================================================
--- zfs/src/zfs-fuse/zfs_operations_slash.c	(revision 19015)
+++ zfs/src/zfs-fuse/zfs_operations_slash.c	(working copy)
@@ -60,43 +60,44 @@
 #include "pathnames.h"
 #include "slashrpc.h"
 #include "slerr.h"
 #include "sltypes.h"
 
 #include "slashd/inode.h"
 #include "slashd/mdsio.h"
 
 kmem_cache_t	*file_info_cache;
 cred_t		 zrootcreds;
-vfs_t		*zfsVfs;			/* initialized by do_mount() */
 int		 stack_size;
 
-uint64_t        *immnsIdCache;
+uint64_t        *immnsIdCache[MAX_FILESYSTEMS];
 uint64_t         immnsIdMask;
 
 /* flags for zfsslash2_fidlink() */
 #define	FIDLINK_CREATE		(1 << 0)
 #define	FIDLINK_LOOKUP		(1 << 1)
 #define	FIDLINK_REMOVE		(1 << 2)
 #define	FIDLINK_DIR		(1 << 3)
 
 /**
  * get_vnode_fids - Get SLASH FID + generation (external) and the
  *	ZFS/MDSIO layer inum "fid" (internal) for a vnode.
  */
 static __inline void
-get_vnode_fids(const vnode_t *vp, struct slash_fidgen *fgp, mdsio_fid_t *mfp)
+get_vnode_fids(int vfsid, const vnode_t *vp, struct slash_fidgen *fgp, mdsio_fid_t *mfp)
 {
 	if (fgp) {
-		if (VTOZ(vp)->z_id == MDSIO_FID_ROOT)
+		if (VTOZ(vp)->z_id == MDSIO_FID_ROOT) {
 			fgp->fg_fid = SLFID_ROOT;
-		else
+			if (vfsid != current_vfsid)
+				FID_SET_SITEID(fgp->fg_fid, zfsMount[vfsid].fsid);
+		} else
 			fgp->fg_fid = VTOZ(vp)->z_phys->zp_s2fid;
 		fgp->fg_gen = VTOZ(vp)->z_phys->zp_s2gen;
 	}
 	if (mfp)
 		*mfp = VTOZ(vp)->z_id;
 }
 
 #define ZFS_INIT_CREDS(slcrp)	{ (slcrp)->scr_uid, (slcrp)->scr_gid, NULL }
 
 static size_t
@@ -178,47 +179,51 @@
 	if (to_set & PSCFS_SETATTRF_CTIME)
 		mask |= AT_SLASH2CTIME;
 	if (to_set & SL_SETATTRF_GEN)
 		mask |= AT_SLASH2GEN;
 	return (mask);
 }
 
 void
 zfsslash2_destroy(void)
 {
+	int i;
 #ifdef DEBUG
 	extern int pscfs_exit_fuse_listener;
 
 	fprintf(stderr, "Calling do_umount()... force %d\n",
 	    pscfs_exit_fuse_listener);
 #endif
 	/*
 	 * If exit_fuse_listener is true, then we received a signal
 	 * and we're terminating the process.  Therefore we need to
 	 * force unmount since there could still be open files.
 	 */
 	sync();
-	while (do_umount(zfsVfs, 0) != 0)
-		sync();
+	for (i = 0; i < mount_index; i++) {
+		while (do_umount(zfsMount[i].vfs, 0) != 0)
+			sync();
+	}
 #ifdef DEBUG
 	fprintf(stderr, "do_umount() done\n");
 #endif
 }
 
 int
-zfsslash2_statfs(struct statvfs *sfb)
+zfsslash2_statfs(int vfsid, struct statvfs *sfb)
 {
 	struct statvfs64 zsfb;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
 
 	memset(sfb, 0, sizeof(*sfb));
 	memset(&zsfb, 0, sizeof(zsfb));
-	int ret = VFS_STATVFS(zfsVfs, &zsfb);
+	int ret = VFS_STATVFS(vfs, &zsfb);
 	if (ret != 0)
 		return (ret);
 
 	/* There's a bug somewhere in FUSE, in the kernel or in df(1) where
 	   f_bsize is being used to calculate filesystem size instead of
 	   f_frsize, so we must use that instead */
 	/* Still there with fuse 2.7.4 apparently (you get a size in To so it shows a lot !) */
 	sfb->f_bsize	= zsfb.f_frsize;
 	sfb->f_frsize	= zsfb.f_frsize;
 	sfb->f_blocks	= zsfb.f_blocks;
@@ -228,29 +233,29 @@
 	sfb->f_ffree	= zsfb.f_ffree;
 	sfb->f_favail	= zsfb.f_favail;
 	sfb->f_fsid	= zsfb.f_fsid;
 	sfb->f_flag	= zsfb.f_flag;
 	sfb->f_namemax	= zsfb.f_namemax;
 
 	return (0);
 }
 
 static int
-fill_sstb(vnode_t *vp, mdsio_fid_t *mfp, struct srt_stat *sstb,
+fill_sstb(int vfsid, vnode_t *vp, mdsio_fid_t *mfp, struct srt_stat *sstb,
     cred_t *cred)
 {
 	struct slash_fidgen fg;
 	vattr_t vattr;
 	int error;
 
 	ASSERT(vp);
-	get_vnode_fids(vp, &fg, mfp);
+	get_vnode_fids(vfsid, vp, &fg, mfp);
 
 	if (sstb == NULL)
 		return (0);
 
 	memset(&vattr, 0, sizeof(vattr));
 	error = VOP_GETATTR(vp, &vattr, 0, cred, NULL);	/* zfs_getattr() */
 	if (error)
 		return (error);
 
 	if (sstb->sst_fid != fg.fg_fid)
@@ -301,25 +306,26 @@
 	sstb->sst_atime_ns = vattr.va_s2atime.tv_nsec;
 	sstb->sst_mtime = vattr.va_s2mtime.tv_sec;
 	sstb->sst_mtime_ns = vattr.va_s2mtime.tv_nsec;
 	sstb->sst_ctime = vattr.va_ctime.tv_sec;
 	sstb->sst_ctime_ns = vattr.va_ctime.tv_nsec;
 
 	return (0);
 }
 
 int
-zfsslash2_getattr(mdsio_fid_t ino, void *finfo,
+zfsslash2_getattr(int vfsid, mdsio_fid_t ino, void *finfo,
     const struct slash_creds *slcrp, struct srt_stat *sstb)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 	file_info_t *info = finfo;
 	vnode_t *vp;
 	int error;
 	boolean_t release;
 
 	ZFS_ENTER(zfsvfs);
 
 	if (!info) {
 		znode_t *znode;
 
@@ -333,21 +339,21 @@
 		ASSERT(znode);
 		vp = ZTOV(znode);
 		release = B_TRUE;
 
 	} else {
 		vp = info->vp;
 		release = B_FALSE;
 	}
 	ASSERT(vp);
 
-	error = fill_sstb(vp, NULL, sstb, &cred);
+	error = fill_sstb(vfsid, vp, NULL, sstb, &cred);
 
 	if (release)
 		VN_RELE(vp);
 
 	ZFS_EXIT(zfsvfs);
 
 	return error;
 }
 
 /* This macro makes the lookup for the xattr directory, necessary for listxattr
@@ -601,26 +607,28 @@
 	if (vp)
 		VN_RELE(vp);
 	VN_RELE(dvp);
 	ZFS_EXIT(zfsvfs);
 	if (error == ENOENT)
 		error = ENOATTR;
 	return (error);
 }
 
 int
-zfsslash2_lookup(mdsio_fid_t parent, const char *name,
+zfsslash2_lookup(int vfsid, mdsio_fid_t parent, const char *name,
     mdsio_fid_t *mfp, const struct slash_creds *slcrp,
     struct srt_stat *sstb)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	if (strlen(name) > MAXNAMELEN)
 		return ENAMETOOLONG;
 
 	znode_t *znode;
 
 	int error = zfs_zget(zfsvfs, parent, &znode, B_TRUE);
 	if (error) {
@@ -640,40 +648,41 @@
 	    NULL, NULL, NULL);
 	if (error)
 		goto out;
 
 	if (vp == NULL) {
 		error = ENOENT;
 		goto out;
 	}
 
 	if (sstb || mfp)
-		error = fill_sstb(vp, mfp, sstb, &cred);
+		error = fill_sstb(vfsid, vp, mfp, sstb, &cred);
 
  out:
 	if (vp)
 		VN_RELE(vp);
 	VN_RELE(dvp);
 	ZFS_EXIT(zfsvfs);
 
 	return error;
 }
 
 /*
  * XXX replace finfop with something meaningful for slash d_ino cache
  */
 int
-zfsslash2_opendir(mdsio_fid_t ino, const struct slash_creds *slcrp,
+zfsslash2_opendir(int vfsid, mdsio_fid_t ino, const struct slash_creds *slcrp,
     struct slash_fidgen *fgp, void *finfop)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
 	int error = zfs_zget(zfsvfs, ino, &znode, B_TRUE);
 	if (error) {
 		ZFS_EXIT(zfsvfs);
 		/* If the inode we are trying to get was recently deleted
 		   dnode_hold_impl will return EEXIST instead of ENOENT */
@@ -684,147 +693,155 @@
 	vnode_t *vp = ZTOV(znode);
 	ASSERT(vp);
 
 	if (vp->v_type != VDIR) {
 		error = ENOTDIR;
 		goto out;
 	}
 	/*
 	 * Check permissions.
 	 */
-	if (!(zfsVfs->fuse_attribute & FUSE_VFS_HAS_DEFAULT_PERM)) {
+	if (!(vfs->fuse_attribute & FUSE_VFS_HAS_DEFAULT_PERM)) {
 		error = VOP_ACCESS(vp, VREAD | VEXEC, 0, &cred, NULL);
 		if (error)
 			goto out;
 	}
 
 	/* XXX convert to the slash d_ino cache */
 	file_info_t *finfo = kmem_cache_alloc(file_info_cache, KM_NOSLEEP);
 	if (finfo == NULL) {
 		error = ENOMEM;
 		goto out;
 	}
 	*(void **)finfop = finfo;
 
 	finfo->vp = vp;
 	finfo->flags = FREAD;
 
-	get_vnode_fids(vp, fgp, NULL);
+	get_vnode_fids(vfsid, vp, fgp, NULL);
 
  out:
 	if (error)
 		VN_RELE(vp);
 	ZFS_EXIT(zfsvfs);
 
 	return error;
 }
 
 /*
  * XXX convert to the slash d_ino cache .. same as above
  */
 int
-zfsslash2_release(__unusedx const struct slash_creds *slcrp, void
+zfsslash2_release(int vfsid, __unusedx const struct slash_creds *slcrp, void
     *finfo)
 {
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 	file_info_t *info = finfo;
 
 	ZFS_ENTER(zfsvfs);
 
 	ASSERT(info->vp);
 	ASSERT(VTOZ(info->vp));
 
 	VN_RELE(info->vp);
 
 	kmem_cache_free(file_info_cache, info);
 
 	ZFS_EXIT(zfsvfs);
 
 	return 0;
 }
 
-void
-zfsslash2_build_immns_cache_helper(vnode_t *root, int curdepth,
+int
+zfsslash2_build_immns_cache_helper(int vfsid, vnode_t *root, int curdepth,
     int maxdepth, int *cnt)
 {
 	vnode_t         *vp;
-	int              i;
+	int              i, error = 0;
 	char		 id_name[2];
 
 	for (i = 0; i < 16; i++) {
 		snprintf(id_name, 2, "%x", i);
 
-		if (VOP_LOOKUP(root, id_name, &vp, NULL, 0, NULL,
-		    &zrootcreds, NULL, NULL, NULL))
-			abort();
+		error = VOP_LOOKUP(root, id_name, &vp, NULL, 0, NULL,
+		    &zrootcreds, NULL, NULL, NULL);
+		if (error)
+			break;
 
-		if (curdepth < maxdepth)
-			zfsslash2_build_immns_cache_helper(vp,
+		if (curdepth < maxdepth) {
+			error = zfsslash2_build_immns_cache_helper(vfsid, vp,
 			    curdepth + 1, maxdepth, cnt);
-		else {
-			immnsIdCache[(*cnt)++] = VTOZ(vp)->z_id;
+			if (error)
+				break;
+		} else {
+			immnsIdCache[vfsid][(*cnt)++] = VTOZ(vp)->z_id;
 			psclog_debug("depth=%d cnt=%d zfid=%#"PRIx64,
 			    curdepth, *cnt, VTOZ(vp)->z_id);
 		}
 
 		VN_RELE(vp);
 	}
+	return (error);
 }
 
-void
-zfsslash2_build_immns_cache(void)
+int
+zfsslash2_build_immns_cache(int vfsid)
 {
 	znode_t         *znode;
 	vnode_t		*dvp;
 	int		 error, cnt=0;
-	zfsvfs_t	*zfsvfs = zfsVfs->vfs_data;
+	struct vfs	*vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t	*zfsvfs = vfs->vfs_data;
 	uint64_t ndirs;
 
 	/* the number of directories at the lowest level */
 	ndirs = 1 << (BPHXC * FID_PATH_DEPTH);
-	immnsIdCache = malloc(sizeof(uint64_t) * ndirs);
+	immnsIdCache[vfsid] = malloc(sizeof(uint64_t) * ndirs);
 	immnsIdMask = (ndirs - 1) << (BPHXC * FID_PATH_START);
 
-	error = zfs_zget(zfsvfs, mds_fidnsdir_inum, &znode, B_TRUE);
+	error = zfs_zget(zfsvfs, mds_fidnsdir_inum[vfsid], &znode, B_TRUE);
 	if (error)
-		psc_fatal("error=%d", error);
+		return (error);
 
 	ASSERT(znode);
 	dvp = ZTOV(znode);
 	ASSERT(dvp);
 
-	zfsslash2_build_immns_cache_helper(dvp, 1, FID_PATH_DEPTH,
-	    &cnt);
+	error = zfsslash2_build_immns_cache_helper(vfsid, dvp, 1, 
+			FID_PATH_DEPTH, &cnt);
 	VN_RELE(dvp);
+	return (error);
 }
 
 /*
  * At most two buffers are passed in by our callers: outbuf points to the
  * readdir result, attrs points to prefetched attributes.
  */
 int
-zfsslash2_readdir(const struct slash_creds *slcrp, size_t size,
+zfsslash2_readdir(int vfsid, const struct slash_creds *slcrp, size_t size,
     off_t off, void *outbuf, size_t *outbuf_len, size_t *nents,
     void *attrs, int nstbprefetch, void *finfo)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
 	vnode_t *vp = ((file_info_t *)finfo)->vp;
 
 	struct timespec ts_zget_start, ts_end;
 
 	ASSERT(vp);
 	ASSERT(VTOZ(vp));
 
 	if (vp->v_type != VDIR)
 		return ENOTDIR;
 
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	union {
 		char buf[DIRENT64_RECLEN(MAXNAMELEN + 1)];
 		struct dirent64 dirent;
 	} entry;
 
 	struct stat fstat;
 	memset(&fstat, 0, sizeof(fstat));
@@ -903,21 +920,21 @@
 		/*
 		 * Skip internal SLASH meta-structure.
 		 * This check should be pushed out to mount_slash once
 		 * we move the pscfs_dirent packing there.
 		 */
 		if (hide_vnode(vp, tvp, entry.dirent.d_name))
 			goto next_entry;
 
 		if (nstbprefetch) {
 			/* XXX look at fidcache first */
-			if (fill_sstb(tvp, NULL, attr, &cred))
+			if (fill_sstb(vfsid, tvp, NULL, attr, &cred))
 				attr->sst_fid = FID_ANY;
 			nstbprefetch--;
 			attr++;
 		}
 		if (VTOZ(tvp)->z_id == MDSIO_FID_ROOT)
 			fstat.st_ino = SLFID_ROOT;
 		else
 			fstat.st_ino = VTOZ(tvp)->z_phys->zp_s2fid;
 
 		fstat.st_mode = 0;
@@ -961,48 +978,49 @@
 		next = entry.dirent.d_off;
 	}
 
  out:
 	ZFS_EXIT(zfsvfs);
 	*outbuf_len = outbuf_off;
 
 	return error;
 }
 
-#define zfsslash2_fidlink(fid, flags, svp, vpp)				\
-	_zfsslash2_fidlink(PFL_CALLERINFOSS(SLMSS_ZFS), (fid), (flags), (svp), (vpp))
+#define zfsslash2_fidlink(vfsid, fid, flags, svp, vpp)				\
+	_zfsslash2_fidlink(PFL_CALLERINFOSS(SLMSS_ZFS), (vfsid), (fid), (flags), (svp), (vpp))
 
 /**
  * zfsslash2_fidlink - Construct the by-id namespace for our internal
  *	use.  This will add an extra link to all files AND directories.
  *	Normally, a user accesses a file or a directory by its name and
  *	that is done in the by-name namespace.
  *
  * Note that this function assumes that the upper layers of the by-id
  * namespace have already been created.  We do this when we format the
  * file system.
  */
 int
-_zfsslash2_fidlink(const struct pfl_callerinfo *pci, slfid_t fid,
+_zfsslash2_fidlink(const struct pfl_callerinfo *pci, int vfsid, slfid_t fid,
     int flags, vnode_t *svp, vnode_t **vpp)
 {
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 	vnode_t *vp, *dvp;
 	znode_t *znode;
 	char id_name[20];
 	uint64_t slot;
 	int i, error;
 
 	/*
 	 * Map the root of SLASH2 metadir to the root of the underlying ZFS.
 	 */
-	if ((flags & FIDLINK_LOOKUP) && fid == SLFID_ROOT) {
+	if ((flags & FIDLINK_LOOKUP) && FID_GET_INUM(fid) == SLFID_ROOT) {
 #if 0
 /*
  * I have found a place in zfs_mknode() where I can write SLASH FID 1 into the
  * root node.  This function is called by dsl_pool_create() twice, once by
  * zfs_create_fs(), once by zfs_create_share_dir().  Both time I see the
  * IS_ROOT_NODE flag is used.  I don't know why ZFS seems to create two root
  * nodes.  But the change seems to fix my problem and make the hack here
  * unneeded.  I discovered this with gdb while creating a zpool.
  */
 		VTOZ(dvp)->z_phys->zp_s2fid = 1;
@@ -1013,21 +1031,21 @@
 
 		ASSERT(znode);
 		dvp = ZTOV(znode);
 		ASSERT(dvp);
 
 		*vpp = dvp;
 		return 0;
 	}
 
 	error = zfs_zget(zfsvfs,
-	    immnsIdCache[(fid & immnsIdMask) >> (BPHXC * FID_PATH_START)],
+	    immnsIdCache[vfsid][(fid & immnsIdMask) >> (BPHXC * FID_PATH_START)],
 	    &znode, B_TRUE);
 	if (error)
 		return error == EEXIST ? ENOENT : error;
 
 	ASSERT(znode);
 	dvp = ZTOV(znode);
 	ASSERT(dvp);
 
 	snprintf(id_name, sizeof(id_name), "%016"PRIx64, fid);
 
@@ -1076,33 +1094,33 @@
  out:
 	psclog_debug("id_name=%s parent=%#"PRIx64" fid="SLPRI_FID" "
 	    "flags=%x error=%d",
 	    id_name, VTOZ(dvp)->z_id, fid, flags, error);
 
 	VN_RELE(dvp);
 	return (error);
 }
 
 int
-zfsslash2_lookup_slfid(slfid_t fid, const struct slash_creds *slcrp,
+zfsslash2_lookup_slfid(int vfsid, slfid_t fid, const struct slash_creds *slcrp,
     struct srt_stat *sstb, mdsio_fid_t *mfp)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
 	vnode_t *vp;
 	int error;
 
 	vp = NULL;
-	error = zfsslash2_fidlink(fid, FIDLINK_LOOKUP, NULL, &vp);
+	error = zfsslash2_fidlink(vfsid, fid, FIDLINK_LOOKUP, NULL, &vp);
 	if (error)
 		return (error);
 	if (sstb || mfp)
-		error = fill_sstb(vp, mfp, sstb, &cred);
+		error = fill_sstb(vfsid, vp, mfp, sstb, &cred);
 
 	VN_RELE(vp);
 	return (error);
 }
 
 /**
  * zfsslash2_opencreate - Open a file (create if necessary).
  * @ino: parent inode if O_CREAT is specified; otherwise, the ZFS inum
  *	of file to open.
  * @slcrp: credentials with which to perform access.
@@ -1114,27 +1132,28 @@
  * @sstb: value-result stat buffer of file.
  * @finfo: value-result handle to ZFS structure; used as a descriptor to
  *	all other mdsio routines.
  * @logfunc: callback for logging create operation.
  * @getslfid: callback for retrieving a unique SLASH FID.
  *
  * Note that ino is the target inode if this is an open; otherwise it is
  * the inode of the parent.
  */
 int
-zfsslash2_opencreate(mdsio_fid_t ino, const struct slash_creds *slcrp,
+zfsslash2_opencreate(int vfsid, mdsio_fid_t ino, const struct slash_creds *slcrp,
     int fflags, int opflags, mode_t createmode, const char *name,
     mdsio_fid_t *mfp, struct srt_stat *sstb, void *finfop,
     sl_log_update_t logfunc, sl_getslfid_cb_t getslfid, slfid_t fid)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	/* Map flags */
 	int mode, flags;
 
 	if (fflags & O_WRONLY) {
 		mode = VWRITE;
 		flags = FWRITE;
 	} else if (fflags & O_RDWR) {
@@ -1216,20 +1235,21 @@
 		    &new_vp, &cred, opflags & MDSIO_OPENCRF_NOMTIM ?
 		    SLASH2_IGNORE_MTIME : 0, NULL, NULL, logfunc); /* zfs_create() */
 
 		if (error)
 			goto out;
 
 		VN_RELE(vp);
 		vp = new_vp;
 		if ((opflags & MDSIO_OPENCRF_NOLINK) == 0) {
 			error = zfsslash2_fidlink(
+			    vfsid,
 			    VTOZ(vp)->z_phys->zp_s2fid,
 			    FIDLINK_CREATE, vp, NULL);
 #if 0
 			fprintf(stderr, "create: name = %s, fid = 0x%lx, txg = %lx, errno = %d\n",
 				name, vattr.va_fid, zfsslash2_return_synced(), errno);
 #endif
 			if (error)
 				goto out;
 		}
 	} else {
@@ -1251,34 +1271,34 @@
 				 * if FOFFMAX flag is set in file mode
 				 */
 				error = EOVERFLOW;
 				goto out;
 			}
 		}
 
 		/*
 		 * Check permissions.
 		 */
-		if (!(zfsVfs->fuse_attribute & FUSE_VFS_HAS_DEFAULT_PERM)) {
+		if (!(vfs->fuse_attribute & FUSE_VFS_HAS_DEFAULT_PERM)) {
 			error = VOP_ACCESS(vp, mode, 0, &cred, NULL);
 			if (error)
 				goto out;
 		}
 	}
 
 	if ((flags & FNOFOLLOW) && vp->v_type == VLNK) {
 		error = ELOOP;
 		goto out;
 	}
 
 	if (sstb || mfp) {
-		error = fill_sstb(vp, mfp, sstb, &cred);
+		error = fill_sstb(vfsid, vp, mfp, sstb, &cred);
 		if (error)
 			goto out;
 	}
 
 	/* XXX it should not be an error if we can't cache the vnode */
 	file_info_t *finfo = kmem_cache_alloc(file_info_cache, KM_NOSLEEP);
 	if (finfo == NULL) {
 		error = ENOMEM;
 		goto out;
 	}
@@ -1292,25 +1312,26 @@
 		ASSERT(vp->v_count > 0);
 		VN_RELE(vp);
 	}
 
 	ZFS_EXIT(zfsvfs);
 
 	return error;
 }
 
 int
-zfsslash2_readlink(mdsio_fid_t ino, char *buf,
+zfsslash2_readlink(int vfsid, mdsio_fid_t ino, char *buf,
     const struct slash_creds *slcrp)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
 	int error = zfs_zget(zfsvfs, ino, &znode, B_FALSE);
 	if (error) {
 		ZFS_EXIT(zfsvfs);
 		/* If the inode we are trying to get was recently deleted
 		   dnode_hold_impl will return EEXIST instead of ENOENT */
@@ -1347,31 +1368,32 @@
 		buf[uio.uio_loffset] = '\0';
 	}
 
 	return error;
 }
 
 /*
  * Returns errno on failure, 0 on success.
  */
 int
-zfsslash2_preadv(const struct slash_creds *slcrp, struct iovec *iovs,
+zfsslash2_preadv(int vfsid, const struct slash_creds *slcrp, struct iovec *iovs,
     int niov, size_t *nb, off_t off, void *finfo)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
 	file_info_t *info = finfo;
 	vnode_t *vp = info->vp;
 
 	ASSERT(vp);
 	ASSERT(VTOZ(vp));
 
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	uio_t uio;
 	uio.uio_iov = iovs;
 	uio.uio_iovcnt = niov;
 	uio.uio_segflg = UIO_SYSSPACE;
 	uio.uio_fmode = 0;
 	uio.uio_llimit = RLIM64_INFINITY;
 
@@ -1384,38 +1406,39 @@
 	int error = VOP_READ(vp, &uio, info->flags, &cred, NULL);
 
 	ZFS_EXIT(zfsvfs);
 
 	if (error == 0)
 		*nb = uio.uio_loffset - off;
 	return (error);
 }
 
 int
-zfsslash2_read(const struct slash_creds *slcrp, void *buf, size_t size,
+zfsslash2_read(int vfsid, const struct slash_creds *slcrp, void *buf, size_t size,
     size_t *nb, off_t off, void *finfo)
 {
 	struct iovec iov;
 
 	iov.iov_base = buf;
 	iov.iov_len = size;
-	return (zfsslash2_preadv(slcrp, &iov, 1, nb, off, finfo));
+	return (zfsslash2_preadv(vfsid, slcrp, &iov, 1, nb, off, finfo));
 }
 
 int
-zfsslash2_mkdir(mdsio_fid_t parent, const char *name,
+zfsslash2_mkdir(int vfsid, mdsio_fid_t parent, const char *name,
     const struct srt_stat *sstb_in, int atflag, int opflags,
     struct srt_stat *sstb_out, mdsio_fid_t *mfp,
     sl_log_update_t logfunc, sl_getslfid_cb_t getslfid, slfid_t fid)
 {
 	cred_t cred = { sstb_in->sst_uid, sstb_in->sst_gid };
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
 	if (strlen(name) > MAXNAMELEN)
 		return ENAMETOOLONG;
 
 	int error = zfs_zget(zfsvfs, parent, &znode, B_FALSE);
 	if (error) {
@@ -1448,47 +1471,49 @@
 		vattr.va_fid = fid;
 
 	error = VOP_MKDIR(dvp, (char *)name, &vattr, &vp, &cred, NULL,
 	    opflags & MDSIO_OPENCRF_NOMTIM ? SLASH2_IGNORE_MTIME : 0,
 	    NULL, logfunc); /* zfs_mkdir() */
 	if (error)
 		goto out;
 
 	ASSERT(vp);
 
-	error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+	error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 	    FIDLINK_CREATE, vp, NULL);
 	if (error)
 		goto out;
 
 	if (sstb_out || mfp)
-		error = fill_sstb(vp, mfp, sstb_out, &zrootcreds);
+		error = fill_sstb(vfsid, vp, mfp, sstb_out, &zrootcreds);
 
 #if 0
 	fprintf(stderr, "mkdir: name=%s fid=0x%lx txg=%lx error=%d\n",
 	    name, vattr.va_fid, zfsslash2_return_synced(), errno);
 #endif
 
  out:
 	if (vp)
 		VN_RELE(vp);
 	VN_RELE(dvp);
 	ZFS_EXIT(zfsvfs);
 	return (error);
 }
 
 int
-zfsslash2_rmdir(mdsio_fid_t parent, slfid_t *fid, const char *name,
+zfsslash2_rmdir(int vfsid, mdsio_fid_t parent, slfid_t *fid, const char *name,
     const struct slash_creds *slcrp, sl_log_update_t logfunc)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
 	if (strlen(name) > MAXNAMELEN)
 		return ENAMETOOLONG;
 
 	int error = zfs_zget(zfsvfs, parent, &znode, B_FALSE);
 	if (error) {
@@ -1521,38 +1546,40 @@
 	error = VOP_RMDIR(dvp, (char *)name, NULL, &cred, NULL, 0,
 	    logfunc);	/* zfs_rmdir() */
 
 	/* Linux uses ENOTEMPTY when trying to remove a non-empty directory */
 	if (error == EEXIST)
 		error = ENOTEMPTY;
 
 	if (fid)
 		*fid = VTOZ(vp)->z_phys->zp_s2fid;
 	if (!error)
-		error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+		error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 		    FIDLINK_REMOVE|FIDLINK_DIR, NULL, NULL);
 
 	VN_RELE(vp);
 
  out:
 	VN_RELE(dvp);
 	ZFS_EXIT(zfsvfs);
 	return error;
 }
 
 int
-zfsslash2_setattr(mdsio_fid_t ino, const struct srt_stat *sstb_in,
+zfsslash2_setattr(int vfsid, mdsio_fid_t ino, const struct srt_stat *sstb_in,
     int to_set, const struct slash_creds *slcrp,
     struct srt_stat *sstb_out, void *finfo, sl_log_update_t logfunc)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 	file_info_t *info = finfo;
 	znode_t *znode;
 
 	ZFS_ENTER(zfsvfs);
 
 	vnode_t *vp;
 	boolean_t release;
 
 	int error;
 
@@ -1681,36 +1708,38 @@
 	}
 
 	int flags = (to_set & (PSCFS_SETATTRF_ATIME |
 	    PSCFS_SETATTRF_MTIME)) ? ATTR_S2UTIME : 0;
 	if (to_set)
 		error = VOP_SETATTR(vp, &vattr, flags, &cred, NULL,
 		    logfunc);	/* zfs_setattr() */
 
  out:
 	if (!error && sstb_out)
-		error = fill_sstb(vp, NULL, sstb_out, &cred);
+		error = fill_sstb(vfsid, vp, NULL, sstb_out, &cred);
 
 	if (release)
 		VN_RELE(vp);
 
 	ZFS_EXIT(zfsvfs);
 
 	return (error);
 }
 
 int
-zfsslash2_unlink(mdsio_fid_t parent, slfid_t *fid, const char *name,
+zfsslash2_unlink(int vfsid, mdsio_fid_t parent, slfid_t *fid, const char *name,
     const struct slash_creds *slcrp, sl_log_update_t logfunc, void *arg)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
 	if (strlen(name) > MAXNAMELEN)
 		return ENAMETOOLONG;
 
 	int error = zfs_zget(zfsvfs, parent, &znode, B_FALSE);
 	if (error) {
@@ -1744,48 +1773,49 @@
 		goto out;
 
 	if (fid)
 		*fid = VTOZ(vp)->z_phys->zp_s2fid;
 
 	/*
 	 * The last remaining link is our FID namespace one, so remove
 	 * the file.
 	 */
 	if (vattr.va_nlink == 1)
-		error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+		error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 		    FIDLINK_REMOVE, NULL, NULL);
 
  out:
 	if (vp)
 		VN_RELE(vp);
 	VN_RELE(dvp);
 	ZFS_EXIT(zfsvfs);
 
 	return error;
 }
 
 /*
  * Returns errno on failure, 0 on success.
  */
 int
-zfsslash2_pwritev(const struct slash_creds *slcrp,
+zfsslash2_pwritev(int vfsid, const struct slash_creds *slcrp,
     const struct iovec *iovs, int niov, size_t *nb, off_t off,
     int update_mtime, void *finfo, sl_log_write_t funcp, void *datap)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
 	file_info_t *info = finfo;
 
 	vnode_t *vp = info->vp;
 	ASSERT(vp);
 	ASSERT(VTOZ(vp));
 
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	size_t size = 0;
 	int i;
 	for (i = 0; i < niov; i++)
 		size += iovs[i].iov_len;
 
 	uio_t uio;
 	uio.uio_iov = (struct iovec *)iovs;
@@ -1805,40 +1835,41 @@
 	if (!error) {
 		/* When not using direct_io, we must always write 'size' bytes */
 		VERIFY(uio.uio_resid == 0);
 		*nb = size - uio.uio_resid;
 	}
 
 	return error;
 }
 
 __inline int
-zfsslash2_write(const struct slash_creds *slcrp, const void *buf,
+zfsslash2_write(int vfsid, const struct slash_creds *slcrp, const void *buf,
     size_t size, size_t *nb, off_t off, int update_mtime, void *finfo,
     sl_log_write_t funcp, void *datap)
 {
 	struct iovec iov;
 
 	iov.iov_base = (void *)buf;
 	iov.iov_len = size;
-	return (zfsslash2_pwritev(slcrp, &iov, 1, nb, off, update_mtime,
+	return (zfsslash2_pwritev(vfsid, slcrp, &iov, 1, nb, off, update_mtime,
 	    finfo, funcp, datap));
 }
 
 int
-zfsslash2_write_cursor(void *buf, size_t size, void *finfo,
+zfsslash2_write_cursor(int vfsid, void *buf, size_t size, void *finfo,
     sl_log_write_t funcp)
 {
 	file_info_t *info = finfo;
 
 	vnode_t *vp = info->vp;
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	iovec_t iovec;
 	uio_t uio;
 	uio.uio_iov = &iovec;
 	uio.uio_iovcnt = 1;
 	uio.uio_segflg = UIO_SYSSPACE;
 	uio.uio_fmode = 0;
 	uio.uio_llimit = RLIM64_INFINITY;
@@ -1851,26 +1882,28 @@
 	int error = VOP_WRITE(vp, &uio, SLASH2_CURSOR_FLAG, &zrootcreds,
 	    NULL, funcp, buf);	/* zfs_write() */
 
 	ZFS_EXIT(zfsvfs);
 
 	return (error);
 
 }
 
 int
-zfsslash2_mknod(mdsio_fid_t parent, const char *name, mode_t mode,
+zfsslash2_mknod(int vfsid, mdsio_fid_t parent, const char *name, mode_t mode,
     const struct slash_creds *slcrp, struct srt_stat *sstb,
     mdsio_fid_t *mfp, sl_log_update_t logfunc, sl_getslfid_cb_t getslfid)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
 	if (strlen(name) > MAXNAMELEN)
 		return ENAMETOOLONG;
 
 	if (!(mode & S_IFIFO))
 		return EOPNOTSUPP;
@@ -1901,45 +1934,47 @@
 
 	/* FIXME: check filesystem boundaries */
 	error = VOP_CREATE(dvp, (char *)name, &vattr, EXCL, 0, &vp,
 	    &cred, 0, NULL, NULL, logfunc);	/* zfs_create() */
 
 	if (error)
 		goto out;
 
 	ASSERT(vp);
 
-	error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+	error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 	    FIDLINK_CREATE, vp, NULL);
 	if (error)
 		goto out;
 
 	if (sstb || mfp)
-		error = fill_sstb(vp, mfp, sstb, &cred);
+		error = fill_sstb(vfsid, vp, mfp, sstb, &cred);
 
  out:
 	if (vp)
 		VN_RELE(vp);
 
 	VN_RELE(dvp);
 	ZFS_EXIT(zfsvfs);
 
 	return error;
 }
 
 int
-zfsslash2_symlink(const char *link, mdsio_fid_t parent, const char *name,
+zfsslash2_symlink(int vfsid, const char *link, mdsio_fid_t parent, const char *name,
     const struct slash_creds *slcrp, struct srt_stat *sstb,
     mdsio_fid_t *mfp, sl_getslfid_cb_t getslfid, sl_log_update_t logfunc)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
 	if (strlen(name) > MAXNAMELEN)
 		return ENAMETOOLONG;
 
 	if (strlen(name) + strlen(link) > SL_TWO_NAME_MAX)
 		return ENAMETOOLONG;
@@ -1972,47 +2007,49 @@
 	vnode_t *vp = NULL;
 
 	if (error)
 		goto out;
 
 	error = VOP_LOOKUP(dvp, (char *)name, &vp, NULL, 0, NULL, &cred,
 	    NULL, NULL, NULL);
 	if (error)
 		goto out;
 
-	error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+	error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 	    FIDLINK_CREATE, vp, NULL);
 	if (error)
 		goto out;
 
 	ASSERT(vp);
 
 	if (sstb || mfp)
-		error = fill_sstb(vp, mfp, sstb, &cred);
+		error = fill_sstb(vfsid, vp, mfp, sstb, &cred);
 
  out:
 	if (vp)
 		VN_RELE(vp);
 	VN_RELE(dvp);
 
 	ZFS_EXIT(zfsvfs);
 
 	return error;
 }
 
 int
-zfsslash2_rename(mdsio_fid_t oldparent, const char *oldname,
+zfsslash2_rename(int vfsid, mdsio_fid_t oldparent, const char *oldname,
     mdsio_fid_t newparent, const char *newname,
     const struct slash_creds *slcrp, sl_log_update_t logfunc, void *arg)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *op_znode, *np_znode;
 
 	if (strlen(oldname) > MAXNAMELEN)
 		return ENAMETOOLONG;
 	if (strlen(newname) > MAXNAMELEN)
 		return ENAMETOOLONG;
 	if (strlen(oldname) + strlen(newname) > SL_TWO_NAME_MAX)
@@ -2048,49 +2085,53 @@
 
 	VN_RELE(op_vp);
 	VN_RELE(np_vp);
 
 	ZFS_EXIT(zfsvfs);
 
 	return error;
 }
 
 int
-zfsslash2_fsync(const struct slash_creds *slcrp, int datasync,
+zfsslash2_fsync(int vfsid, const struct slash_creds *slcrp, int datasync,
     void *finfo)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	file_info_t *info = finfo;
 	ASSERT(info->vp);
 	ASSERT(VTOZ(info->vp));
 
 	vnode_t *vp = info->vp;
 
 	int error = VOP_FSYNC(vp, datasync ? FDSYNC : FSYNC, &cred,
 	    NULL);	/* zfs_fsync() */
 
 	ZFS_EXIT(zfsvfs);
 
 	return error;
 }
 
 int
-zfsslash2_link(mdsio_fid_t ino, mdsio_fid_t newparent,
+zfsslash2_link(int vfsid, mdsio_fid_t ino, mdsio_fid_t newparent,
     const char *newname, const struct slash_creds *slcrp,
     struct srt_stat *sstb, sl_log_update_t logfunc)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *td_znode, *s_znode;
 
 	if (strlen(newname) > MAXNAMELEN)
 		return ENAMETOOLONG;
 
 	int error = zfs_zget(zfsvfs, ino, &s_znode, B_FALSE);
 	if (error) {
@@ -2124,38 +2165,40 @@
 		goto out;
 
 	error = VOP_LOOKUP(tdvp, (char *)newname, &vp, NULL, 0, NULL,
 	    &cred, NULL, NULL, NULL);
 	if (error)
 		goto out;
 
 	ASSERT(vp);
 
 	if (sstb)
-		error = fill_sstb(vp, NULL, sstb, &cred);
+		error = fill_sstb(vfsid, vp, NULL, sstb, &cred);
 
  out:
 	if (vp)
 		VN_RELE(vp);
 	VN_RELE(tdvp);
 	VN_RELE(svp);
 
 	ZFS_EXIT(zfsvfs);
 
 	return error;
 }
 
 int
-zfsslash2_access(mdsio_fid_t ino, int mask, const struct slash_creds *slcrp)
+zfsslash2_access(int vfsid, mdsio_fid_t ino, int mask, const struct slash_creds *slcrp)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
+
+	struct vfs *vfs = zfsMount[vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
 	ZFS_ENTER(zfsvfs);
 
 	znode_t *znode;
 
 	int error = zfs_zget(zfsvfs, ino, &znode, B_TRUE);
 	if (error) {
 		ZFS_EXIT(zfsvfs);
 		/* If the inode we are trying to get was recently deleted
 		   dnode_hold_impl will return EEXIST instead of ENOENT */
@@ -2208,33 +2251,35 @@
  * XXX these should be merged with the routines above.
  *
  * XXX There are still some uses of zrootcreds in replay operations.
  *     We may want to replace them all with real creds.
  */
 
 void
 zfsslash2_wait_synced(uint64_t txg)
 {
 	dsl_pool_t *dp;
+	struct vfs *vfs = zfsMount[current_vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 	dp = spa_get_dsl(zfsvfs->z_os->os_spa);
 	txg_wait_synced(dp, txg);
 }
 
 uint64_t
 zfsslash2_return_synced(void)
 {
 	dsl_pool_t *dp;
 	uint64_t txg;
+	struct vfs *vfs = zfsMount[current_vfsid].vfs;
+	zfsvfs_t *zfsvfs = vfs->vfs_data;
 
-	zfsvfs_t *zfsvfs = zfsVfs->vfs_data;
 	dp = spa_get_dsl(zfsvfs->z_os->os_spa);
 	txg = txg_return_synced(dp);
 	return (txg);
 }
 
 static void
 sstb2vattr(const struct srt_stat *sstb, vattr_t *vap)
 {
 	memset(vap, 0, sizeof(*vap));
 
@@ -2263,34 +2308,34 @@
 
 	vap->va_ctime.tv_sec	= sstb->sst_ctime;
 	vap->va_ctime.tv_nsec	= sstb->sst_ctime_ns;
 	vap->va_atime.tv_sec	= sstb->sst_atime;
 	vap->va_atime.tv_nsec	= sstb->sst_atime_ns;
 	vap->va_mtime.tv_sec	= sstb->sst_mtime;
 	vap->va_mtime.tv_nsec	= sstb->sst_mtime_ns;
 }
 
 int
-zfsslash2_replay_symlink(slfid_t pfid, slfid_t fid, char *name,
+zfsslash2_replay_symlink(int vfsid, slfid_t pfid, slfid_t fid, char *name,
     char *link, struct srt_stat *sstb)
 {
 	vnode_t *vp, *pvp;
 	vattr_t vattr;
 	cred_t cred;
 	int error;
 
 	vp = pvp = NULL;
 
 	/*
 	 * Make sure the parent exists, at least in the by-id namespace.
 	 */
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP | FIDLINK_CREATE,
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP | FIDLINK_CREATE,
 	    NULL, &pvp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    fid, slstrerror(error));
 		goto out;
 	}
 
 	sstb2vattr(sstb, &vattr);
 	vattr.va_type = VLNK;
 	vattr.va_mask = AT_TYPE | AT_MODE | AT_ATIME | AT_MTIME |
@@ -2303,52 +2348,52 @@
 	error = VOP_SYMLINK(pvp, name, &vattr, link, &cred, NULL,
 	    0, NULL); /* zfs_symlink() */
 	if (error)
 		goto out;
 
 	error = VOP_LOOKUP(pvp, name, &vp, NULL, 0, NULL, &zrootcreds,
 	    NULL, NULL, NULL);
 	if (error)
 		goto out;
 
-	error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+	error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 	    FIDLINK_CREATE, vp, NULL);
 
  out:
 	if (vp)
 		VN_RELE(vp);
 	if (pvp)
 		VN_RELE(pvp);
 	return (error);
 }
 
 int
-zfsslash2_replay_link(slfid_t pfid, slfid_t fid, char *name,
+zfsslash2_replay_link(int vfsid, slfid_t pfid, slfid_t fid, char *name,
     struct srt_stat *sstb)
 {
 	vnode_t *pvp, *svp;
 	cred_t cred;
 	int error;
 
 	pvp = svp = NULL;
 
 	/*
 	 * Make sure the parent exists, at least in the by-id namespace.
 	 */
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP | FIDLINK_CREATE,
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP | FIDLINK_CREATE,
 	    NULL, &pvp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    fid, slstrerror(error));
 		goto out;
 	}
-	error = zfsslash2_fidlink(fid, FIDLINK_LOOKUP | FIDLINK_CREATE,
+	error = zfsslash2_fidlink(vfsid, fid, FIDLINK_LOOKUP | FIDLINK_CREATE,
 	    NULL, &svp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    fid, slstrerror(error));
 		goto out;
 	}
 
 	cred.req = NULL;
 	cred.cr_uid = sstb->sst_uid;
 	cred.cr_gid = sstb->sst_gid;
@@ -2357,33 +2402,33 @@
 
  out:
 	if (svp)
 		VN_RELE(svp);
 	if (pvp)
 		VN_RELE(pvp);
 	return (error);
 }
 
 int
-zfsslash2_replay_mkdir(slfid_t pfid, char *name, struct srt_stat *sstb)
+zfsslash2_replay_mkdir(int vfsid, slfid_t pfid, char *name, struct srt_stat *sstb)
 {
 	vnode_t *pvp, *tvp;
 	vattr_t vattr;
 	cred_t cred;
 	int error;
 
 	tvp = pvp = NULL;
 
 	/*
 	 * Make sure the parent exists, at least in the by-id namespace.
 	 */
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP,
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP,
 	    NULL, &pvp);
 	if (error) {
 		psclog_errorx("failed to look up parent fid "SLPRI_FID": %s",
 		    pfid, slstrerror(error));
 		goto out;
 	}
 
 	sstb2vattr(sstb, &vattr);
 	vattr.va_type = VDIR;
 	vattr.va_mask = AT_TYPE | AT_MODE | AT_ATIME | AT_MTIME |
@@ -2395,47 +2440,47 @@
 
 	/* pass opflags */
 	error = VOP_MKDIR(pvp, name, &vattr, &tvp, &cred, NULL, 0, NULL,
 	    NULL); /* zfs_mkdir() */
 	if (error) {
 		psclog_errorx("failed to mkdir "SLPRI_FID": %s",
 		    sstb->sst_fid, slstrerror(error));
 		goto out;
 	}
 
-	error = zfsslash2_fidlink(sstb->sst_fid, FIDLINK_CREATE, tvp, NULL);
+	error = zfsslash2_fidlink(vfsid, sstb->sst_fid, FIDLINK_CREATE, tvp, NULL);
 	if (error)
 		psclog_errorx("failed to create fidlink "SLPRI_FID": %s",
 		    sstb->sst_fid, slstrerror(error));
 
  out:
 	if (pvp)
 		VN_RELE(pvp);
 	if (tvp)
 		VN_RELE(tvp);
 	return (error);
 }
 
 int
-zfsslash2_replay_create(slfid_t pfid, char *name, struct srt_stat *sstb)
+zfsslash2_replay_create(int vfsid, slfid_t pfid, char *name, struct srt_stat *sstb)
 {
 	vnode_t *pvp, *tvp;
 	vattr_t vattr;
 	cred_t cred;
 	int error;
 
 	tvp = pvp = NULL;
 
 	/*
 	 * Make sure the parent exists, at least in the by-id namespace.
 	 */
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP,
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP,
 	    NULL, &pvp);
 	if (error) {
 		psclog_errorx("failed to look up parent fid "SLPRI_FID": %s",
 		    pfid, slstrerror(error));
 		goto out;
 	}
 
 	sstb2vattr(sstb, &vattr);
 	vattr.va_type = VREG;
 	vattr.va_mask = AT_TYPE | AT_MODE | AT_ATIME | AT_MTIME |
@@ -2444,42 +2489,42 @@
 	cred.req = NULL;
 	cred.cr_uid = sstb->sst_uid;
 	cred.cr_gid = sstb->sst_gid;
 
 	/* pass opflags */
 	error = VOP_CREATE(pvp, name, &vattr, EXCL, 0, &tvp, &cred, 0,
 	    NULL, NULL, NULL); /* zfs_create() */
 	if (error)
 		goto out;
 
-	error = zfsslash2_fidlink(sstb->sst_fid, FIDLINK_CREATE, tvp,
+	error = zfsslash2_fidlink(vfsid, sstb->sst_fid, FIDLINK_CREATE, tvp,
 	    NULL);
 	if (error)
 		psclog_errorx("failed to create fidlink "SLPRI_FID": %s",
 		    sstb->sst_fid, slstrerror(error));
  out:
 	if (tvp)
 		VN_RELE(tvp);
 	if (pvp)
 		VN_RELE(pvp);
 	return (error);
 }
 
 int
-zfsslash2_replay_rmdir(slfid_t pfid, slfid_t fid, char *name)
+zfsslash2_replay_rmdir(int vfsid, slfid_t pfid, slfid_t fid, char *name)
 {
 	vnode_t *dvp, *vp;
 	int error;
 
 	vp = NULL;
 	dvp = NULL;
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP, NULL, &dvp);
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP, NULL, &dvp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    fid, slstrerror(error));
 		goto out;
 	}
 
 	error = VOP_LOOKUP(dvp, name, &vp, NULL, 0, NULL, &zrootcreds,
 	    NULL, NULL, NULL);
 	if (error)
 		goto out;
@@ -2491,46 +2536,46 @@
 		goto out;
 	}
 
 	error = VOP_RMDIR(dvp, name, NULL, &zrootcreds, NULL, 0, NULL);		/* zfs_rmdir() */
 
 	/* Linux uses ENOTEMPTY when trying to remove a non-empty directory */
 	if (error == EEXIST)
 		error = ENOTEMPTY;
 
 	if (!error) {
-		error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+		error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 		    FIDLINK_REMOVE | FIDLINK_DIR, NULL, NULL);
 		if (!error)
 			/*
 			 * The vnode is still there, but its underlying
 			 * link count is zero.
 			 */
 			assert(VTOZ(vp)->z_phys->zp_links == 0);
 	}
 
  out:
 	if (vp)
 		VN_RELE(vp);
 	if (dvp)
 		VN_RELE(dvp);
 	return (error);
 }
 
 int
-zfsslash2_replay_unlink(slfid_t pfid, slfid_t fid, char *name)
+zfsslash2_replay_unlink(int vfsid, slfid_t pfid, slfid_t fid, char *name)
 {
 	vnode_t *vp, *dvp;
 	int error;
 
 	vp = dvp = NULL;
-	error = zfsslash2_fidlink(pfid, FIDLINK_LOOKUP, NULL, &dvp);
+	error = zfsslash2_fidlink(vfsid, pfid, FIDLINK_LOOKUP, NULL, &dvp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    fid, slstrerror(errno));
 		goto out;
 	}
 	error = VOP_LOOKUP(dvp, name, &vp, NULL, 0, NULL, &zrootcreds,
 	    NULL, NULL, NULL);
 	if (error)
 		goto out;
 	if (VTOZ(vp)->z_phys->zp_s2fid != fid) {
@@ -2549,108 +2594,114 @@
 	memset(&vattr, 0, sizeof(vattr));
 	error = VOP_GETATTR(vp, &vattr, 0, &zrootcreds, NULL);
 	if (error)
 		goto out;
 
 	/*
 	 * The last remaining link is our FID namespace one,
 	 * so remove the file.
 	 */
 	if (vattr.va_nlink == 1)
-		error = zfsslash2_fidlink(VTOZ(vp)->z_phys->zp_s2fid,
+		error = zfsslash2_fidlink(vfsid, VTOZ(vp)->z_phys->zp_s2fid,
 		    FIDLINK_REMOVE, NULL, NULL);
 
  out:
 	if (vp)
 		VN_RELE(vp);
 	if (dvp)
 		VN_RELE(dvp);
 	return (error);
 }
 
 int
-zfsslash2_replay_setattr(slfid_t fid, uint mask, struct srt_stat *sstb)
+zfsslash2_replay_setattr(int vfsid, slfid_t fid, uint mask, struct srt_stat *sstb)
 {
 	int error, flag;
 	vattr_t vattr;
 	vnode_t *vp;
 
 	vp = NULL;
-	error = zfsslash2_fidlink(fid, FIDLINK_LOOKUP, NULL, &vp);
+	error = zfsslash2_fidlink(vfsid, fid, FIDLINK_LOOKUP, NULL, &vp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID, fid);
 		goto out;
 	}
 
 	sstb2vattr(sstb, &vattr);
 	vattr.va_mask = mask;
 
 	flag = (mask & (AT_ATIME | AT_MTIME)) ? ATTR_UTIME : 0;
 	if (vattr.va_mask & AT_SLASH2SIZE) {
 		if (vattr.va_s2size == 0) {
 			/* full truncate - zero all old bmaps */
 			vattr.va_mask |= AT_SIZE;
 			vattr.va_size = SL_BMAP_START_OFF;
 		}
 	}
 	/* Note: not using zrootcreds will return EPERM (1) */
 	error = VOP_SETATTR(vp, &vattr, flag, &zrootcreds, NULL, NULL);		/* zfs_setattr() */
 	if (!error)
-		error = fill_sstb(vp, NULL, sstb, &zrootcreds);
+		error = fill_sstb(vfsid, vp, NULL, sstb, &zrootcreds);
  out:
 	if (vp)
 		VN_RELE(vp);
 	return (error);
 }
 
 int
-zfsslash2_replay_rename(slfid_t parent, const char *name, slfid_t
+zfsslash2_replay_rename(int vfsid, slfid_t parent, const char *name, slfid_t
     newparent, const char *newname, __unusedx struct srt_stat *stat)
 {
 	vnode_t *p_vp, *np_vp;
 	int error;
 
 	p_vp = np_vp = NULL;
-	error = zfsslash2_fidlink(parent, FIDLINK_LOOKUP, NULL, &p_vp);
+	error = zfsslash2_fidlink(vfsid, parent, FIDLINK_LOOKUP, NULL, &p_vp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    parent, slstrerror(errno));
 		goto out;
 	}
-	error = zfsslash2_fidlink(newparent, FIDLINK_LOOKUP, NULL, &np_vp);
+	error = zfsslash2_fidlink(vfsid, newparent, FIDLINK_LOOKUP, NULL, &np_vp);
 	if (error) {
 		psclog_errorx("failed to look up fid "SLPRI_FID": %s",
 		    newparent, slstrerror(errno));
 		goto out;
 	}
 
 	error = VOP_RENAME(p_vp, (char *)name, np_vp, (char *)newname,
 	    &zrootcreds, NULL, 0, NULL, NULL);  /* zfs_rename() */
  out:
 	if (p_vp)
 		VN_RELE(p_vp);
 	if (np_vp)
 		VN_RELE(np_vp);
 	return (error);
 }
 
 int
-zfsslash2_replay_fidlink(slfid_t fid, const struct slash_creds *slcrp)
+zfsslash2_replay_fidlink(int vfsid, slfid_t fid, const struct slash_creds *slcrp)
 {
 	cred_t cred = ZFS_INIT_CREDS(slcrp);
 	vnode_t *vp;
 	int error;
 
 	/*
 	 * ZFS can put the creation of a file and its fidlink into two
 	 * different transaction groups.  We must allow this to happen
 	 * and create the fidlink if it is missing.
 	 */
 	vp = NULL;
-	error = zfsslash2_fidlink(fid, FIDLINK_LOOKUP | FIDLINK_CREATE,
+	error = zfsslash2_fidlink(vfsid, fid, FIDLINK_LOOKUP | FIDLINK_CREATE,
 	    NULL, &vp);
 	if (error)
 		return (error);
 
 	VN_RELE(vp);
 	return 0;
 }
+
+void
+zfsslash2_register_hook(void *funp)
+{
+	zfsslash2_hook_func = funp;
+}
Index: zfs/src/zfs-fuse/main.c
===================================================================
--- zfs/src/zfs-fuse/main.c	(revision 19015)
+++ zfs/src/zfs-fuse/main.c	(working copy)
@@ -37,21 +37,20 @@
 #include "format.h"
 
 extern uint64_t max_arc_size; // defined in arc.c
 static const char *cf_pidfile = NULL;
 static const char *cf_fuse_mount_options = NULL;
 static int cf_disable_block_cache = 0;
 static int cf_disable_page_cache = 0;
 extern void fuse_unmount_all(); // in fuse_listener.c
 static int cf_daemonize = 1;
 extern int no_kstat_mount; // kstat.c
-void *zfsVfs;
 
 static void exit_handler(int sig)
 {
     fuse_unmount_all();
     exit_fuse_listener = B_TRUE;
 }
 
 static int set_signal_handler(int sig, void (*handler)(int))
 {
 	struct sigaction sa;
Index: slash_nara/slimmns/slimmns_format.c
===================================================================
--- slash_nara/slimmns/slimmns_format.c	(revision 19015)
+++ slash_nara/slimmns/slimmns_format.c	(working copy)
@@ -45,20 +45,21 @@
 #include "mkfn.h"
 #include "pathnames.h"
 #include "slconfig.h"
 
 void wipefs(const char *);
 
 const char	*progname;
 int		 wipe;
 int		 ion;
 struct passwd	*pw;
+uint64_t         fsid = 0;
 uint64_t         fsUuid = 0;
 const char      *datadir = SL_PATH_DATA_DIR;
 
 struct psc_journal_cursor cursor;
 
 void
 slnewfs_mkdir(const char *fn)
 {
 	if (mkdir(fn, 0700) == -1 && errno != EEXIST)
 		psc_fatal("mkdir %s", fn);
@@ -194,39 +195,51 @@
 	slnewfs_mkdir(fn);
 
 	/* create the FSUUID file */
 	xmkfn(fn, "%s/%s", metadir, SL_FN_FSUUID);
 	fp = fopen(fn, "w");
 	if (fp == NULL)
 		psc_fatal("open %s", fn);
 
 	if (!fsUuid)
 		fsUuid = psc_random64();
-	fprintf(fp, "%16"PRIx64"\n", fsUuid);
+	fprintf(fp, "%18"PRIx64"\n", fsUuid);
 	if (!ion)
-		printf("The UUID of the pool is %#16"PRIx64"\n", fsUuid);
+		printf("The UUID of the file system is %#18"PRIx64"\n", fsUuid);
+
+	fclose(fp);
+
+	/* create the FSID file */
+	xmkfn(fn, "%s/%s", metadir, SL_FN_FSID);
+	fp = fopen(fn, "w");
+	if (fp == NULL)
+		psc_fatal("open %s", fn);
+	fprintf(fp, "%18"PRIx64"\n", fsid);
+	if (!ion)
+		printf("The FSID of the file system is %#18"PRIx64"\n", fsid);
 
 	fclose(fp);
 
 	/* create the journal cursor file */
 	xmkfn(fn, "%s/%s", metadir, SL_FN_CURSOR);
 	fd = open(fn, O_CREAT | O_TRUNC | O_WRONLY, 0600);
 	if (fd == -1)
 		psc_fatal("open %s", fn);
 	if (pw && fchown(fd, pw->pw_uid, pw->pw_gid) == -1)
 		psclog_warn("chown %u %s", pw->pw_uid, fn);
 
 	memset(&cursor, 0, sizeof(struct psc_journal_cursor));
 	cursor.pjc_magic = PJRNL_CURSOR_MAGIC;
 	cursor.pjc_version = PJRNL_CURSOR_VERSION;
 	cursor.pjc_timestamp = time(NULL);
 	cursor.pjc_fid = SLFID_MIN;
+	FID_SET_SITEID(cursor.pjc_fid, fsid);
 	if (pwrite(fd, &cursor, sizeof(cursor), 0) != sizeof(cursor))
 		psc_fatal("write %s", fn);
 	close(fd);
 
 	/* more journals */
 	slnewfs_touchfile("%s/%s.%d", metadir, SL_FN_UPDATELOG, 0);
 	slnewfs_touchfile("%s/%s", metadir, SL_FN_UPDATEPROG);
 	slnewfs_touchfile("%s/%s.%d", metadir, SL_FN_RECLAIMLOG, 0);
 	slnewfs_touchfile("%s/%s", metadir, SL_FN_RECLAIMPROG);
 
@@ -286,37 +299,45 @@
 }
 
 int
 main(int argc, char *argv[])
 {
 	char *cfgfn = NULL, *endp;
 	int c;
 
 	pfl_init();
 	progname = argv[0];
-	while ((c = getopt(argc, argv, "c:D:iWu:")) != -1)
+	while ((c = getopt(argc, argv, "c:D:iI:Wu:")) != -1)
 		switch (c) {
 		case 'c':
 			cfgfn = optarg;
 			break;
 		case 'D':
 			datadir = optarg;
 			break;
 		case 'i':
 			ion = 1;
 			break;
 		case 'u':
 			endp = NULL;
 			fsUuid = strtoull(optarg, &endp, 16);
 			if (endp == optarg || *endp)
 				errx(1, "%s: invalid FSUUID", optarg);
 			break;
+		case 'I':
+			endp = NULL;
+			fsid = strtoull(optarg, &endp, 16);
+			if (endp == optarg || *endp)
+				errx(1, "%s: invalid FSID", optarg);
+			if (fsid >= (1 << SLASH_FID_SITE_BITS))
+				errx(1, "%lu: FSID too big", fsid);
+			break;
 		case 'W':
 			wipe = 1;
 			break;
 		default:
 			usage();
 		}
 	argc -= optind;
 	argv += optind;
 	if (argc != 1)
 		usage();
Index: slash_nara/include/pathnames.h
===================================================================
--- slash_nara/include/pathnames.h	(revision 19015)
+++ slash_nara/include/pathnames.h	(working copy)
@@ -58,14 +58,15 @@
 #define SL_FN_BMAP_ODTAB	"bmap.odtab"
 
 #define SL_FN_UPDATELOG		"op-update"
 #define SL_FN_UPDATEPROG	"op-update-prog"
 
 #define SL_FN_RECLAIMLOG	"op-reclaim"
 #define SL_FN_RECLAIMPROG	"op-reclaim-prog"
 
 #define SL_FN_CURSOR		"cursor"
 #define SL_FN_FSUUID		"fsuuid"
+#define SL_FN_FSID		"fsid"
 
 extern const char *sl_datadir;
 
 #endif /* _SLASH_PATHNAMES_H_ */
Index: slash_nara/slmkjrnl/slmkjrnl.c
===================================================================
--- slash_nara/slmkjrnl/slmkjrnl.c	(revision 19015)
+++ slash_nara/slmkjrnl/slmkjrnl.c	(working copy)
@@ -40,22 +40,20 @@
 #include "slashd/subsys_mds.h"
 
 int		 format;
 int		 query;
 int		 verbose;
 const char	*datadir = SL_PATH_DATA_DIR;
 const char	*progname;
 struct pscfs	 pscfs;
 struct mdsio_ops mdsio_ops;
 
-mdsio_fid_t	 mds_fidnsdir_inum;
-
 __dead void
 usage(void)
 {
 	fprintf(stderr,
 	    "usage: %s [-fqv] [-b block-device] [-D dir] [-n nentries] [-u uuid]\n",
 	    progname);
 	exit(1);
 }
 
 /**
Index: slash_nara/utils/typedump/typedump.c
===================================================================
--- slash_nara/utils/typedump/typedump.c	(revision 19015)
+++ slash_nara/utils/typedump/typedump.c	(working copy)
@@ -192,20 +192,21 @@
 	PRTYPE(struct msl_fhent);
 	PRTYPE(struct msl_fsrqinfo);
 	PRTYPE(struct msl_ra);
 	PRTYPE(struct msrci_thread);
 	PRTYPE(struct msrcm_thread);
 	PRTYPE(struct resm_cli_info);
 	PRTYPE(struct resm_iod_info);
 	PRTYPE(struct resm_mds_info);
 	PRTYPE(struct resprof_cli_info);
 	PRTYPE(struct resprof_mds_info);
+	PRTYPE(struct rootNames);
 	PRTYPE(struct site_mds_info);
 	PRTYPE(struct site_progress);
 	PRTYPE(struct sl_buffer);
 	PRTYPE(struct sl_buffer_iovref);
 	PRTYPE(struct sl_expcli_ops);
 	PRTYPE(struct sl_fcmh_ops);
 	PRTYPE(struct sl_gconf);
 	PRTYPE(struct sl_ino_compat);
 	PRTYPE(struct sl_lnetrt);
 	PRTYPE(struct sl_mds_crc_log);
Index: slash_nara/slashd/up_sched_res.c
===================================================================
--- slash_nara/slashd/up_sched_res.c	(revision 19015)
+++ slash_nara/slashd/up_sched_res.c	(working copy)
@@ -47,20 +47,22 @@
 #include "mdsio.h"
 #include "pathnames.h"
 #include "repl_mds.h"
 #include "rpc_mds.h"
 #include "slashd.h"
 #include "slconfig.h"
 #include "slerr.h"
 #include "slutil.h"
 #include "up_sched_res.h"
 
+extern int current_vfsid;
+
 struct upschedtree	 upsched_tree = SPLAY_INITIALIZER(&upsched_tree);
 struct psc_poolmgr	*upsched_pool;
 struct psc_lockedlist	 upsched_listhd =
     PLL_INIT(&upsched_listhd, struct up_sched_work_item,
 	uswi_lentry);
 
 /**
  * slmupschedthr_removeq - A file that required updates to be sent to
  *	I/O systems for a given site appears to be finished.  Do a quick
  *	run through the file ensuring there is truely nothing left to do
@@ -190,21 +192,21 @@
 	USWI_DECREF(wk, USWI_REFT_LOOKUP);
 	USWI_ULOCK(wk);
 	UPSCHED_MGR_ULOCK();
 
 	rc = snprintf(fn, sizeof(fn), SLPRI_FID, USWI_FID(wk));
 	if (rc == -1)
 		rc = errno;
 	else if (rc >= (int)sizeof(fn))
 		rc = ENAMETOOLONG;
 	else
-		rc = mdsio_unlink(mds_upschdir_inum, NULL, fn,
+		rc = mdsio_unlink(current_vfsid, mds_upschdir_inum[current_vfsid], NULL, fn,
 		    &rootcreds, NULL, NULL);
 	if (rc)
 		psclog_error("trying to remove upsch link: %s",
 		    slstrerror(rc));
 
 	UPSCHED_MGR_LOCK();
 	USWI_LOCK(wk);
 
 	while (psc_atomic32_read(&wk->uswi_refcnt) > 1) {
 		psc_multiwaitcond_wakeup(&wk->uswi_mwcond);
@@ -650,21 +652,21 @@
 			wk->uswi_flags &= ~USWIF_BUSY;
 			psc_mutex_unlock(&wk->uswi_mutex);
 
 			/* find a res in our site this uswi is destined for */
 			iosidx = -1;
 			FOREACH_RND(&dst_res_i,
 			    psc_dynarray_len(&site->site_resources)) {
 				dst_res = psc_dynarray_getpos(
 				    &site->site_resources,
 				    dst_res_i.ri_rnd_idx);
-				iosidx = mds_repl_ios_lookup(
+				iosidx = mds_repl_ios_lookup(current_vfsid,
 				    USWI_INOH(wk), dst_res->res_id);
 				if (iosidx < 0)
 					continue;
 				off = SL_BITS_PER_REPLICA * iosidx;
 
 				FCMH_LOCK(f);
 				if (f->fcmh_flags & FCMH_IN_PTRUNC) {
  try_ptrunc:
 					has_work = 1;
 
@@ -1088,31 +1090,31 @@
 	struct fidc_membh *fcmh;
 	struct slash_fidgen fg;
 	struct pscfs_dirent *d;
 	struct bmapc_memb *b;
 	char *buf, fn[NAME_MAX];
 	off64_t off, toff;
 	size_t siz, tsiz;
 	uint32_t j;
 	void *data;
 
-	rc = mdsio_opendir(mds_upschdir_inum, &rootcreds, NULL, &data);
+	rc = mdsio_opendir(current_vfsid, mds_upschdir_inum[current_vfsid], &rootcreds, NULL, &data);
 	if (rc)
 		psc_fatalx("mdsio_opendir %s: %s", SL_RPATH_UPSCH_DIR,
 		    slstrerror(rc));
 
 	off = 0;
 	siz = 8 * 1024;
 	buf = PSCALLOC(siz);
 
 	for (;;) {
-		rc = mdsio_readdir(&rootcreds, siz,
+		rc = mdsio_readdir(current_vfsid, &rootcreds, siz,
 			   off, buf, &tsiz, NULL, NULL, 0, data);
 		if (rc)
 			psc_fatalx("mdsio_readdir %s: %s",
 			    SL_RPATH_UPSCH_DIR, slstrerror(rc));
 		if (tsiz == 0)
 			break;
 		for (toff = 0; toff < (off64_t)tsiz;
 		    toff += PFL_DIRENT_SIZE(d->pfd_namelen)) {
 			d = (void *)(buf + toff);
 			off = d->pfd_off;
@@ -1128,21 +1130,21 @@
 
 			memset(&fg, 0, sizeof(fg));
 			fg.fg_fid = strtoll(fn, NULL, 16);
 			fg.fg_gen = FGEN_ANY;
 
 			rc = mds_repl_loadino(&fg, &fcmh);
 			if (rc) {
 				/* XXX if ENOENT, remove from repldir and continue */
 				psclog_errorx("mds_repl_loadino: %s",
 				    slstrerror(rc));
-				mdsio_unlink(mds_upschdir_inum, NULL, fn,
+				mdsio_unlink(current_vfsid, mds_upschdir_inum[current_vfsid], NULL, fn,
 				    &rootcreds, NULL, NULL);
 				continue;
 			}
 
 			rc = uswi_findoradd(&fg, &wk);
 			if (rc)
 				psc_fatal("uswi_findoradd: %s",
 				    slstrerror(rc));
 
 			psc_mutex_lock(&wk->uswi_mutex);
@@ -1182,21 +1184,21 @@
 			 * sites.  If there is no work to do, it will be
 			 * promptly removed by the slmupschedthr.
 			 */
 			for (j = 0; j < USWI_NREPLS(wk); j++)
 				iosv[j].bs_id = USWI_GETREPL(wk, j).bs_id;
 			uswi_enqueue_sites(wk, iosv, USWI_NREPLS(wk));
 			uswi_unref(wk);
 		}
 		off += tsiz;
 	}
-	rc = mdsio_release(&rootcreds, data);
+	rc = mdsio_release(current_vfsid, &rootcreds, data);
 	if (rc)
 		psc_fatalx("mdsio_release %s: %s", SL_RPATH_UPSCH_DIR,
 		    slstrerror(rc));
 
 	PSCFREE(buf);
 }
 
 int
 uswi_findoradd(const struct slash_fidgen *fgp,
     struct up_sched_work_item **wkp)
@@ -1224,26 +1226,26 @@
 	rc = snprintf(fn, sizeof(fn), SLPRI_FID, fgp->fg_fid);
 	if (rc == -1) {
 		rc = errno;
 		goto out;
 	}
 	if (rc >= (int)sizeof(fn)) {
 		rc = ENAMETOOLONG;
 		goto out;
 	}
 
-	rc = mdsio_opencreatef(mds_upschdir_inum, &rootcreds,
+	rc = mdsio_opencreatef(current_vfsid, mds_upschdir_inum[current_vfsid], &rootcreds,
 	    O_CREAT | O_WRONLY, MDSIO_OPENCRF_NOLINK, 0600, fn,
 	    NULL, NULL, &mdsio_data, NULL, uswi_getslfid, 0);
 	if (rc)
 		goto out;
-	mdsio_release(&rootcreds, mdsio_data);
+	mdsio_release(current_vfsid, &rootcreds, mdsio_data);
 
 	UPSCHED_MGR_LOCK();
 	*wkp = uswi_find(fgp);
 	if (*wkp) {
 		if (UPSCHED_MGR_HASLOCK())
 			UPSCHED_MGR_ULOCK();
 		fcmh_op_done_type(newrq->uswi_fcmh,
 		    FCMH_OPCNT_LOOKUP_FIDC);
 		goto out;
 	}
Index: slash_nara/slashd/repl_mds.c
===================================================================
--- slash_nara/slashd/repl_mds.c	(revision 19015)
+++ slash_nara/slashd/repl_mds.c	(working copy)
@@ -54,20 +54,22 @@
 #include "slashd.h"
 #include "slerr.h"
 #include "up_sched_res.h"
 
 struct psc_listcache	 slm_replst_workq;
 
 struct slm_resmlink	*repl_busytable;
 int			 repl_busytable_nents;
 psc_spinlock_t		 repl_busytable_lock = SPINLOCK_INIT;
 
+extern int current_vfsid;
+
 __static int
 iosidx_cmp(const void *a, const void *b)
 {
 	const int *x = a, *y = b;
 
 	return (CMP(*x, *y));
 }
 
 __static int
 iosid_cmp(const void *a, const void *b)
@@ -90,21 +92,21 @@
 uswi_cmp(const void *a, const void *b)
 {
 	const struct up_sched_work_item *x = a, *y = b;
 
 	return (CMP(USWI_FID(x), USWI_FID(y)));
 }
 
 SPLAY_GENERATE(upschedtree, up_sched_work_item, uswi_tentry, uswi_cmp);
 
 int
-_mds_repl_ios_lookup(struct slash_inode_handle *ih, sl_ios_id_t ios,
+_mds_repl_ios_lookup(int vfsid, struct slash_inode_handle *ih, sl_ios_id_t ios,
     int add, int log)
 {
 	int locked, rc = -ENOENT, inox_rc = 0;
 	struct sl_resource *res;
 	sl_replica_t *repl;
 	uint32_t j, k;
 
 	locked = INOH_RLOCK(ih);
 	/*
 	 * Search the existing replicas to see if the given IOS is
@@ -158,43 +160,43 @@
 			repl = ih->inoh_ino.ino_repls;
 			k = j;
 		}
 
 		repl[k].bs_id = ios;
 		ih->inoh_ino.ino_nrepls++;
 
 		DEBUG_INOH(PLL_INFO, ih, "add IOS(%u) to repls, index %d",
 		    ios, j);
 
-		mds_inodes_odsync(ih->inoh_fcmh, mdslog_ino_repls);
+		mds_inodes_odsync(vfsid, ih->inoh_fcmh, mdslog_ino_repls);
 
 		rc = j;
 	}
  out:
 	INOH_URLOCK(ih, locked);
 	return (inox_rc ? inox_rc : rc);
 }
 
-#define mds_repl_iosv_lookup(ih, ios, iosidx, nios)			\
-	_mds_repl_iosv_lookup((ih), (ios), (iosidx), (nios), 0)
+#define mds_repl_iosv_lookup(vfsid, ih, ios, iosidx, nios)			\
+	_mds_repl_iosv_lookup((vfsid), (ih), (ios), (iosidx), (nios), 0)
 
-#define mds_repl_iosv_lookup_add(ih, ios, iosidx, nios)			\
-	_mds_repl_iosv_lookup((ih), (ios), (iosidx), (nios), 1)
+#define mds_repl_iosv_lookup_add(vfsid, ih, ios, iosidx, nios)			\
+	_mds_repl_iosv_lookup((vfsid), (ih), (ios), (iosidx), (nios), 1)
 
 __static int
-_mds_repl_iosv_lookup(struct slash_inode_handle *ih,
+_mds_repl_iosv_lookup(int vfsid, struct slash_inode_handle *ih,
     const sl_replica_t iosv[], int iosidx[], int nios, int add)
 {
 	int k, last;
 
 	for (k = 0; k < nios; k++)
-		if ((iosidx[k] = _mds_repl_ios_lookup(ih,
+		if ((iosidx[k] = _mds_repl_ios_lookup(vfsid, ih,
 		    iosv[k].bs_id, add, add)) < 0)
 			return (-iosidx[k]);
 
 	qsort(iosidx, nios, sizeof(iosidx[0]), iosidx_cmp);
 	/* check for dups */
 	last = -1;
 	for (k = 0; k < nios; k++, last = iosidx[k])
 		if (iosidx[k] == last)
 			return (EINVAL);
 	return (0);
@@ -516,21 +518,21 @@
 	if (nios < 1 || nios > SL_MAX_REPLICAS)
 		return (-EINVAL);
 
 	rc = uswi_findoradd(fgp, &wk);
 	if (rc)
 		return (rc);
 
 	slm_iosv_setbusy(iosv, nios);
 
 	/* Find/add our replica's IOS ID */
-	rc = mds_repl_iosv_lookup_add(USWI_INOH(wk), iosv, iosidx,
+	rc = mds_repl_iosv_lookup_add(current_vfsid, USWI_INOH(wk), iosv, iosidx,
 	    nios);
 	if (rc)
 		goto out;
 
 	/*
 	 * Check inode's bmap state.  INVALID and VALID states become
 	 * OLD, signifying that replication needs to happen.
 	 */
 	brepls_init(tract, -1);
 	tract[BREPLST_INVALID] = BREPLST_REPL_QUEUED;
@@ -639,21 +641,21 @@
 	if (nios < 1 || nios > SL_MAX_REPLICAS)
 		return (-EINVAL);
 
 	rc = uswi_findoradd(fgp, &wk);
 	if (rc)
 		return (rc);
 
 	slm_iosv_setbusy(iosv, nios);
 
 	/* Find replica IOS indexes */
-	rc = mds_repl_iosv_lookup(USWI_INOH(wk), iosv, iosidx, nios);
+	rc = mds_repl_iosv_lookup(current_vfsid, USWI_INOH(wk), iosv, iosidx, nios);
 	if (rc)
 		goto out;
 
 	brepls_init(tract, -1);
 	tract[BREPLST_REPL_QUEUED] = BREPLST_GARBAGE;
 	tract[BREPLST_REPL_SCHED] = BREPLST_GARBAGE;
 	tract[BREPLST_VALID] = BREPLST_GARBAGE;
 
 	if (bmapno == (sl_bmapno_t)-1) {
 		brepls_init(retifset, 0);
@@ -846,21 +848,21 @@
 
 	slm_iosv_setbusy(&repl, 1);
 
 	PLL_LOCK(&upsched_listhd);
 	PLL_FOREACH(wk, &upsched_listhd) {
 		USWI_INCREF(wk, USWI_REFT_LOOKUP);
 		if (!uswi_access(wk))
 			continue;
 		PLL_ULOCK(&upsched_listhd);
 
-		iosidx = mds_repl_ios_lookup(USWI_INOH(wk), resid);
+		iosidx = mds_repl_ios_lookup(current_vfsid, USWI_INOH(wk), resid);
 		if (iosidx < 0)
 			goto end;
 
 		for (n = 0; n < fcmh_nvalidbmaps(wk->uswi_fcmh); n++) {
 			if (mds_bmap_load(wk->uswi_fcmh, n, &bcm))
 				continue;
 
 			if (mds_repl_bmap_walk(bcm, tract, retifset, 0,
 			    &iosidx, 1))
 				mds_bmap_write_repls_rel(bcm);
Index: slash_nara/slashd/repl_mds.h
===================================================================
--- slash_nara/slashd/repl_mds.h	(revision 19015)
+++ slash_nara/slashd/repl_mds.h	(working copy)
@@ -53,21 +53,21 @@
 };
 
 typedef void (*brepl_walkcb_t)(struct bmapc_memb *, int, int, void *);
 
 int	 mds_repl_addrq(const struct slash_fidgen *, sl_bmapno_t, sl_replica_t *, int);
 int	_mds_repl_bmap_apply(struct bmapc_memb *, const int *, const int *, int, int, int *, brepl_walkcb_t, void *);
 int	_mds_repl_bmap_walk(struct bmapc_memb *, const int *, const int *, int, const int *, int, brepl_walkcb_t, void *);
 int	 mds_repl_delrq(const struct slash_fidgen *, sl_bmapno_t, sl_replica_t *, int);
 void	 mds_repl_init(void);
 int	 mds_repl_inv_except(struct bmapc_memb *, int);
-int	_mds_repl_ios_lookup(struct slash_inode_handle *, sl_ios_id_t, int, int);
+int	_mds_repl_ios_lookup(int, struct slash_inode_handle *, sl_ios_id_t, int, int);
 int	 mds_repl_loadino(const struct slash_fidgen *, struct fidc_membh **);
 void	 mds_repl_node_clearallbusy(struct resm_mds_info *);
 int64_t mds_repl_nodes_adjbusy(struct resm_mds_info *, struct resm_mds_info *, int64_t);
 void	 mds_repl_reset_scheduled(sl_ios_id_t);
 
 void	 mds_brepls_check(uint8_t *, int);
 
 /* replication state walking flags */
 #define REPL_WALKF_SCIRCUIT	(1 << 0)	/* short circuit on return value set */
 #define REPL_WALKF_MODOTH	(1 << 1)	/* modify everyone except specified IOS */
@@ -110,19 +110,19 @@
 	_mds_repl_bmap_walk((b), (t), (r), (fl), (iv), (ni), NULL, NULL)
 
 #define mds_repl_bmap_walkcb(b, t, r, fl, cbf, arg)			\
 	_mds_repl_bmap_walk((b), (t), (r), (fl), NULL, 0, (cbf), (arg))
 
 #define mds_repl_bmap_apply(bcm, tract, retifset, off)			\
 	_mds_repl_bmap_apply((bcm), (tract), (retifset), 0, (off), NULL, NULL, NULL)
 
 #define mds_repl_nodes_clearbusy(a, b)		 mds_repl_nodes_adjbusy((a), (b), INT64_MIN)
 
-#define mds_repl_ios_lookup_add(ih, iosid, log)	_mds_repl_ios_lookup((ih), (iosid), 1, (log))
-#define mds_repl_ios_lookup(ih, iosid)		_mds_repl_ios_lookup((ih), (iosid), 0, 0)
+#define mds_repl_ios_lookup_add(vfsid, ih, iosid, log)	_mds_repl_ios_lookup((vfsid), (ih), (iosid), 1, (log))
+#define mds_repl_ios_lookup(vfsid, ih, iosid)		_mds_repl_ios_lookup((vfsid), (ih), (iosid), 0, 0)
 
 extern struct psc_listcache	 slm_replst_workq;
 
 extern struct slm_resmlink	*repl_busytable;
 extern psc_spinlock_t		 repl_busytable_lock;
 
 #endif /* _SL_MDS_REPL_H_ */
Index: slash_nara/slashd/odtable_mds.c
===================================================================
--- slash_nara/slashd/odtable_mds.c	(revision 19015)
+++ slash_nara/slashd/odtable_mds.c	(working copy)
@@ -28,20 +28,22 @@
 #include "pfl/str.h"
 #include "pfl/types.h"
 #include "psc_ds/lockedlist.h"
 #include "psc_util/alloc.h"
 #include "psc_util/lock.h"
 #include "psc_util/log.h"
 #include "psc_util/odtable.h"
 
 #include "odtable_mds.h"
 
+extern int current_vfsid;
+
 struct psc_lockedlist psc_odtables =
     PLL_INIT(&psc_odtables, struct odtable, odt_lentry);
 
 /**
  * odtable_putitem - Save a bmap I/O node assignment into the odtable.
  */
 struct odtable_receipt *
 mds_odtable_putitem(struct odtable *odt, void *data, size_t len)
 {
 	struct odtable_receipt *odtr;
@@ -56,21 +58,21 @@
 	spinlock(&odt->odt_lock);
 	if (psc_vbitmap_next(odt->odt_bitmap, &elem) <= 0) {
 		freelock(&odt->odt_lock);
 		return (NULL);
 	}
 	if (elem >= odt->odt_hdr->odth_nelems) {
 
 		/* XXX either trust the bitmap or initialize the footer of new items */
 
 		odt->odt_hdr->odth_nelems = psc_vbitmap_getsize(odt->odt_bitmap);
-		rc = mdsio_write(&rootcreds, &odt->odt_hdr,
+		rc = mdsio_write(current_vfsid, &rootcreds, &odt->odt_hdr,
 		    sizeof(struct odtable_hdr), &nb, 0, 0,
 		    odt->odt_handle, NULL, NULL);
 		psc_assert(!rc && nb == sizeof(struct odtable_hdr));
 
 		psclog_warn("On-disk table now has %zd elements (used to be %zd)",
 			odt->odt_hdr->odth_nelems, elem);
 	}
 
 	freelock(&odt->odt_lock);
 
@@ -90,21 +92,21 @@
 	odtf->odtf_slotno = elem;
 	odtf->odtf_magic = ODTBL_MAGIC;
 
 	/*
 	 * Setup and return the receipt.
 	 */
 	odtr = PSCALLOC(sizeof(*odtr));
 	odtr->odtr_elem = elem;
 	odtr->odtr_key = crc;
 
-	rc = mdsio_write(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_write(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + elem * odt->odt_hdr->odth_slotsz,
 	    0, odt->odt_handle, NULL, NULL);
 	psc_assert(!rc && nb == odt->odt_hdr->odth_slotsz);
 
 	PSCFREE(p);
 	return (odtr);
 }
 
 int
 mds_odtable_getitem(struct odtable *odt, const struct odtable_receipt *odtr,
@@ -113,21 +115,21 @@
 	struct odtable_entftr *odtf;
 	uint64_t crc;
 	size_t nb;
 	void *p;
 	int rc;
 
 	psc_assert(len <= odt->odt_hdr->odth_elemsz);
 	psc_assert(odtr->odtr_elem <= odt->odt_hdr->odth_nelems - 1);
 
 	p = PSCALLOC(odt->odt_hdr->odth_slotsz);
-	rc = mdsio_read(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_read(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + odtr->odtr_elem *
 	    odt->odt_hdr->odth_slotsz, odt->odt_handle);
 	if (nb != odt->odt_hdr->odth_slotsz) {
 		if (!rc)
 			rc = EIO;
 	}
 	if (rc)
 		goto out;
 
 	odtf = p + odt->odt_hdr->odth_elemsz;
@@ -160,37 +162,37 @@
 {
 	struct odtable_entftr *odtf;
 	uint64_t crc;
 	size_t nb;
 	void *p;
 	int rc;
 
 	psc_assert(len <= odt->odt_hdr->odth_elemsz);
 
 	p = PSCALLOC(odt->odt_hdr->odth_slotsz);
-	rc = mdsio_read(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_read(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + odtr->odtr_elem *
 	    odt->odt_hdr->odth_slotsz, odt->odt_handle);
 
 	odtf = p + odt->odt_hdr->odth_elemsz;
 	psc_assert(!odtable_footercheck(odtf, odtr, 1));
 
 	memcpy(p, data, len);
 	if (len < odt->odt_hdr->odth_elemsz)
 		memset(p + len, 0, odt->odt_hdr->odth_elemsz - len);
 	psc_crc64_calc(&crc, p, odt->odt_hdr->odth_elemsz);
 	odtr->odtr_key = crc;
 	odtf->odtf_crc = crc;
 
 	psclog_info("slot=%zd elemcrc=%"PSCPRIxCRC64, odtr->odtr_elem, crc);
 
-	rc = mdsio_write(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_write(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + odtr->odtr_elem *
 	    odt->odt_hdr->odth_slotsz, 0, odt->odt_handle, NULL, NULL);
 	psc_assert(!rc && nb == odt->odt_hdr->odth_slotsz);
 
 	PSCFREE(p);
 	return (odtr);
 }
 
 /**
  * odtable_freeitem - free the odtable slot which corresponds to the provided
@@ -199,33 +201,33 @@
  */
 int
 mds_odtable_freeitem(struct odtable *odt, struct odtable_receipt *odtr)
 {
 	int rc;
 	void *p;
 	size_t nb;
 	struct odtable_entftr *odtf;
 
 	p = PSCALLOC(odt->odt_hdr->odth_slotsz);
-	rc = mdsio_read(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_read(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + odtr->odtr_elem *
 	    odt->odt_hdr->odth_slotsz, odt->odt_handle);
 
 	odtf = p + odt->odt_hdr->odth_elemsz;
 	psc_assert(!odtable_footercheck(odtf, odtr, 1));
 
 	odtf->odtf_inuse = ODTBL_FREE;
 	spinlock(&odt->odt_lock);
 	psc_vbitmap_unset(odt->odt_bitmap, odtr->odtr_elem);
 	freelock(&odt->odt_lock);
 
-	rc = mdsio_write(&rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
+	rc = mdsio_write(current_vfsid, &rootcreds, p, odt->odt_hdr->odth_slotsz, &nb,
 	    odt->odt_hdr->odth_start + odtr->odtr_elem *
 	    odt->odt_hdr->odth_slotsz, 0, odt->odt_handle, NULL, NULL);
 	psc_assert(!rc && nb == odt->odt_hdr->odth_slotsz);
 
 	psclog_info("slot=%zd elemcrc=%"PSCPRIxCRC64, odtr->odtr_elem,
 	    odtf->odtf_crc);
 
 	PSCFREE(p);
 	PSCFREE(odtr);
 	return (rc);
@@ -242,48 +244,48 @@
 	size_t nb, i;
 	int rc, frc;
 	va_list ap;
 	void *p;
 
 	psc_assert(t);
 	*t = NULL;
 
 	INIT_SPINLOCK(&odt->odt_lock);
 
-	rc = mdsio_lookup(mds_metadir_inum, fn, &mf, &rootcreds, NULL);
+	rc = mdsio_lookup(current_vfsid, mds_metadir_inum[current_vfsid], fn, &mf, &rootcreds, NULL);
 	psc_assert(rc == 0);
 
-	rc = mdsio_opencreate(mf, &rootcreds, O_RDWR, 0, NULL, NULL,
+	rc = mdsio_opencreate(current_vfsid, mf, &rootcreds, O_RDWR, 0, NULL, NULL,
 	    NULL, &odt->odt_handle, NULL, NULL, 0);
 	psc_assert(!rc && odt->odt_handle);
 
 	odth = PSCALLOC(sizeof(*odth));
-	rc = mdsio_read(&rootcreds, odth, sizeof(*odth), &nb, 0,
+	rc = mdsio_read(current_vfsid, &rootcreds, odth, sizeof(*odth), &nb, 0,
 	    odt->odt_handle);
 	odt->odt_hdr = odth;
 	psc_assert(rc == 0 && nb == sizeof(*odth));
 
 	psc_assert((odth->odth_magic == ODTBL_MAGIC) &&
 		   (odth->odth_version == ODTBL_VERS));
 
 	/*
 	 * We used to do mmap() to allow easy indexing.  However, we now
 	 * support auto growth of the bitmap.  Plus, ZFS fuse does NOT
 	 * like mmap() either.
 	 */
 	odt->odt_bitmap = psc_vbitmap_newf(odth->odth_nelems,
 	    PVBF_AUTO);
 	psc_assert(odt->odt_bitmap);
 
 	p = PSCALLOC(odth->odth_slotsz);
 	for (i = 0; i < odth->odth_nelems; i++) {
-		rc = mdsio_read(&rootcreds, p,
+		rc = mdsio_read(current_vfsid, &rootcreds, p,
 		    odth->odth_slotsz, &nb,
 		    odth->odth_start + i *
 		    odth->odth_slotsz, odt->odt_handle);
 
 		odtr.odtr_elem = i;
 		odtf = p + odth->odth_elemsz;
 		frc = odtable_footercheck(odtf, &odtr, -1);
 
 		/* Sanity checks for debugging.
 		 */
@@ -331,22 +333,22 @@
 	pll_add(&psc_odtables, odt);
 }
 
 void
 mds_odtable_release(struct odtable *odt)
 {
 	psc_vbitmap_free(odt->odt_bitmap);
 	odt->odt_bitmap = NULL;
 
 	PSCFREE(odt->odt_hdr);
-	mdsio_fsync(&rootcreds, 0, odt->odt_handle);
-	mdsio_release(&rootcreds, odt->odt_handle);
+	mdsio_fsync(current_vfsid, &rootcreds, 0, odt->odt_handle);
+	mdsio_release(current_vfsid, &rootcreds, odt->odt_handle);
 	PSCFREE(odt);
 }
 
 void
 mds_odtable_scan(struct odtable *odt,
     void (*odt_handler)(void *, struct odtable_receipt *))
 {
 	int rc;
 	void *p;
 	size_t i, nb;
@@ -355,21 +357,21 @@
 
 	psc_assert(odt_handler != NULL);
 
 	odtr = NULL;
 	p = PSCALLOC(odt->odt_hdr->odth_slotsz);
 	for (i = 0; i < odt->odt_hdr->odth_nelems; i++) {
 		if (!odtr)
 			odtr = PSCALLOC(sizeof(*odtr));
 		if (!psc_vbitmap_get(odt->odt_bitmap, i))
 			continue;
-		rc = mdsio_read(&rootcreds, p,
+		rc = mdsio_read(current_vfsid, &rootcreds, p,
 		    odt->odt_hdr->odth_slotsz, &nb,
 		    odt->odt_hdr->odth_start + i *
 		    odt->odt_hdr->odth_slotsz, odt->odt_handle);
 		if (rc)
 			psclog_warnx("Fail to read slot=%zd, skipping", i);
 		odtf = p + odt->odt_hdr->odth_elemsz;
 
 		odtr->odtr_elem = i;
 		odtr->odtr_key = odtf->odtf_key;
 
Index: slash_nara/slashd/mdsio.h
===================================================================
--- slash_nara/slashd/mdsio.h	(revision 19015)
+++ slash_nara/slashd/mdsio.h	(working copy)
@@ -19,32 +19,34 @@
 
 #ifndef _SLASHD_MDSIO_H_
 #define _SLASHD_MDSIO_H_
 
 #include <sys/types.h>
 
 #include <stdint.h>
 
 #include "fid.h"
 #include "sltypes.h"
+#include "pfl/hashtbl.h"
 
 struct statvfs;
 struct iovec;
 
 struct bmapc_memb;
 struct fidc_membh;
 struct slash_creds;
 struct slash_inode_handle;
 struct srt_stat;
 
 typedef uint64_t mdsio_fid_t;
 
+
 struct mdsio_fh {
 	void *fh;
 };
 
 /* callback to get a SLASH2 FID */
 typedef int (*sl_getslfid_cb_t)(slfid_t *);
 
 /* callback to log writes to bmap */
 typedef void (*sl_log_write_t)(void *, uint64_t, int);
 
@@ -52,73 +54,81 @@
 typedef void (*sl_log_update_t)(int, uint64_t, uint64_t, uint64_t,
     const struct srt_stat *, int, const char *, const char *, void *);
 
 /* predefined mdsio layer "fids" */
 #define MDSIO_FID_ROOT		3		/* XXX FUSE_ROOT_ID? */
 
 /* opencreatef() flags */
 #define MDSIO_OPENCRF_NOLINK	(1 << 0)	/* do not create links in FID namespace */
 #define MDSIO_OPENCRF_NOMTIM	(1 << 1)	/* do not update st_mtim */
 
-#define mdsio_opencreate(pino, crp, fflags, mode, fn, mfp, sstb,	\
+#define mdsio_opencreate(vfs, pino, crp, fflags, mode, fn, mfp, sstb,	\
 	    mdsio_datap, logfunc, getslfid, slfid)			\
-	mdsio_opencreatef((pino), (crp), (fflags), 0, (mode), (fn),	\
+	mdsio_opencreatef((vfs), (pino), (crp), (fflags), 0, (mode), (fn),	\
 	    (mfp), (sstb), (mdsio_datap), (logfunc), (getslfid), (slfid))
 
 /* high-level interface */
 int	mdsio_fcmh_refreshattr(struct fidc_membh *, struct srt_stat *);
-int	mdsio_write_cursor(void *, size_t, void *, sl_log_write_t);
+int	mdsio_write_cursor(int, void *, size_t, void *, sl_log_write_t);
 
 struct mdsio_ops {
 	/* control interface */
 	int	(*mio_init)(void);
 	void	(*mio_exit)(void);
 
 	/* utility interface */
 	int	(*mio_setattrmask_2_slflags)(uint);
 	uint	(*mio_slflags_2_setattrmask)(int);
 
 	/* low-level file system interface */
-	int	(*mio_access)(mdsio_fid_t, int, const struct slash_creds *);
-	int	(*mio_fsync)(const struct slash_creds *, int, void *);
-	int	(*mio_getattr)(mdsio_fid_t, void *, const struct slash_creds *, struct srt_stat *);
-	int	(*mio_link)(mdsio_fid_t, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, sl_log_update_t);
-	int	(*mio_lookup)(mdsio_fid_t, const char *, mdsio_fid_t *, const struct slash_creds *, struct srt_stat *);
-	int	(*mio_lookup_slfid)(slfid_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *);
-	int	(*mio_mkdir)(mdsio_fid_t, const char *, const struct srt_stat *, int, int, struct srt_stat *, mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
-	int	(*mio_mknod)(mdsio_fid_t, const char *, mode_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *, sl_log_update_t, sl_getslfid_cb_t);
-	int	(*mio_opencreatef)(mdsio_fid_t, const struct slash_creds *, int, int, mode_t, const char *, mdsio_fid_t *, struct srt_stat *, void *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
-	int	(*mio_opendir)(mdsio_fid_t, const struct slash_creds *, struct slash_fidgen *, void *);
-	int	(*mio_preadv)(const struct slash_creds *, struct iovec *, int, size_t *, off_t, void *);
-	int	(*mio_pwritev)(const struct slash_creds *, const struct iovec *, int, size_t *, off_t, int, void *, sl_log_write_t, void *);
-	int	(*mio_read)(const struct slash_creds *, void *, size_t, size_t *, off_t, void *);
-	int	(*mio_readdir)(const struct slash_creds *, size_t, off_t, void *, size_t *, size_t *, void *, int, void *);
-	int	(*mio_readlink)(mdsio_fid_t, char *, const struct slash_creds *);
-	int	(*mio_release)(const struct slash_creds *, void *);
-	int	(*mio_rename)(mdsio_fid_t, const char *, mdsio_fid_t, const char *, const struct slash_creds *, sl_log_update_t, void *);
-	int	(*mio_rmdir)(mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t);
-	int	(*mio_setattr)(mdsio_fid_t, const struct srt_stat *, int, const struct slash_creds *, struct srt_stat *, void *, sl_log_update_t);
-	int	(*mio_statfs)(struct statvfs *);
-	int	(*mio_symlink)(const char *, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *, sl_getslfid_cb_t, sl_log_update_t);
-	int	(*mio_unlink)(mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t, void *);
-	int	(*mio_write)(const struct slash_creds *, const void *, size_t, size_t *, off_t, int, void *, sl_log_write_t, void *);
+	int	(*mio_access)(int, mdsio_fid_t, int, const struct slash_creds *);
+	int	(*mio_fsync)(int, const struct slash_creds *, int, void *);
+	int	(*mio_getattr)(int, mdsio_fid_t, void *, const struct slash_creds *, struct srt_stat *);
+	int	(*mio_link)(int, mdsio_fid_t, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, sl_log_update_t);
+	int	(*mio_lookup)(int, mdsio_fid_t, const char *, mdsio_fid_t *, const struct slash_creds *, struct srt_stat *);
+	int	(*mio_lookup_slfid)(int, slfid_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *);
+	int	(*mio_mkdir)(int, mdsio_fid_t, const char *, const struct srt_stat *, int, int, struct srt_stat *, mdsio_fid_t *, \
+			sl_log_update_t, sl_getslfid_cb_t, slfid_t);
+	int	(*mio_mknod)(int, mdsio_fid_t, const char *, mode_t, const struct slash_creds *, struct srt_stat *, mdsio_fid_t *, \
+			sl_log_update_t, sl_getslfid_cb_t);
+	int	(*mio_opencreatef)(int, mdsio_fid_t, const struct slash_creds *, int, int, mode_t, const char *, mdsio_fid_t *, \
+			struct srt_stat *, void *, sl_log_update_t, sl_getslfid_cb_t, slfid_t);
+	int	(*mio_opendir)(int, mdsio_fid_t, const struct slash_creds *, struct slash_fidgen *, void *);
+	int	(*mio_preadv)(int, const struct slash_creds *, struct iovec *, int, size_t *, off_t, void *);
+	int	(*mio_pwritev)(int, const struct slash_creds *, const struct iovec *, int, size_t *, off_t, int, void *, \
+			sl_log_write_t, void *);
+	int	(*mio_read)(int, const struct slash_creds *, void *, size_t, size_t *, off_t, void *);
+	int	(*mio_readdir)(int, const struct slash_creds *, size_t, off_t, void *, size_t *, size_t *, void *, int, void *);
+	int	(*mio_readlink)(int, mdsio_fid_t, char *, const struct slash_creds *);
+	int	(*mio_release)(int, const struct slash_creds *, void *);
+	int	(*mio_rename)(int, mdsio_fid_t, const char *, mdsio_fid_t, const char *, const struct slash_creds *, \
+			sl_log_update_t, void *);
+	int	(*mio_rmdir)(int, mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t);
+	int	(*mio_setattr)(int, mdsio_fid_t, const struct srt_stat *, int, const struct slash_creds *, struct srt_stat *, \
+			void *, sl_log_update_t);
+	int	(*mio_statfs)(int, struct statvfs *);
+	int	(*mio_symlink)(int, const char *, mdsio_fid_t, const char *, const struct slash_creds *, struct srt_stat *, \
+			mdsio_fid_t *, sl_getslfid_cb_t, sl_log_update_t);
+	int	(*mio_unlink)(int, mdsio_fid_t, slfid_t *, const char *, const struct slash_creds *, sl_log_update_t, void *);
+	int	(*mio_write)(int, const struct slash_creds *, const void *, size_t, size_t *, off_t, int, void *, \
+			sl_log_write_t, void *);
 
 	/* replay interface */
-	int	(*mio_redo_create)(slfid_t, char *, struct srt_stat *);
-	int	(*mio_redo_fidlink)(slfid_t, const struct slash_creds *);
-	int	(*mio_redo_link)(slfid_t, slfid_t, char *, struct srt_stat *);
-	int	(*mio_redo_mkdir)(slfid_t, char *, struct srt_stat *);
-	int	(*mio_redo_rename)(slfid_t, const char *, slfid_t, const char *, struct srt_stat *);
-	int	(*mio_redo_rmdir)(slfid_t, slfid_t, char *);
-	int	(*mio_redo_setattr)(slfid_t, uint, struct srt_stat *);
-	int	(*mio_redo_symlink)(slfid_t, slfid_t, char *, char *, struct srt_stat *);
-	int	(*mio_redo_unlink)(slfid_t, slfid_t, char *);
+	int	(*mio_redo_create)(int, slfid_t, char *, struct srt_stat *);
+	int	(*mio_redo_fidlink)(int,slfid_t, const struct slash_creds *);
+	int	(*mio_redo_link)(int, slfid_t, slfid_t, char *, struct srt_stat *);
+	int	(*mio_redo_mkdir)(int, slfid_t, char *, struct srt_stat *);
+	int	(*mio_redo_rename)(int, slfid_t, const char *, slfid_t, const char *, struct srt_stat *);
+	int	(*mio_redo_rmdir)(int, slfid_t, slfid_t, char *);
+	int	(*mio_redo_setattr)(int, slfid_t, uint, struct srt_stat *);
+	int	(*mio_redo_symlink)(int, slfid_t, slfid_t, char *, char *, struct srt_stat *);
+	int	(*mio_redo_unlink)(int, slfid_t, slfid_t, char *);
 };
 
 #define mdsio_init		mdsio_ops.mio_init			/* zfsslash2_init() */
 #define mdsio_exit		mdsio_ops.mio_exit			/* libzfs_exit() */
 
 #define mdsio_setattrmask_2_slflags mdsio_ops.mio_setattrmask_2_slflags	/* zfsslash2_setattrmask_2_slflags() */
 #define mdsio_slflags_2_setattrmask mdsio_ops.mio_slflags_2_setattrmask	/* zfsslash2_slflags_2_setattrmask() */
 
 #define mdsio_access		mdsio_ops.mio_access			/* zfsslash2_access() */
 #define mdsio_fsync		mdsio_ops.mio_fsync			/* zfsslash2_fsync() */
@@ -148,16 +158,22 @@
 #define mdsio_redo_fidlink	mdsio_ops.mio_redo_fidlink		/* zfsslash2_replay_fidlink() */
 #define mdsio_redo_link		mdsio_ops.mio_redo_link			/* zfsslash2_replay_link() */
 #define mdsio_redo_mkdir	mdsio_ops.mio_redo_mkdir		/* zfsslash2_replay_mkdir() */
 #define mdsio_redo_rename	mdsio_ops.mio_redo_rename		/* zfsslash2_replay_rename() */
 #define mdsio_redo_rmdir	mdsio_ops.mio_redo_rmdir		/* zfsslash2_replay_rmdir() */
 #define mdsio_redo_setattr	mdsio_ops.mio_redo_setattr		/* zfsslash2_replay_setattr() */
 #define mdsio_redo_symlink	mdsio_ops.mio_redo_symlink		/* zfsslash2_replay_symlink() */
 #define mdsio_redo_unlink	mdsio_ops.mio_redo_unlink		/* zfsslash2_replay_unlink() */
 
 extern struct mdsio_ops	mdsio_ops;
-extern mdsio_fid_t	mds_upschdir_inum;
-extern mdsio_fid_t	mds_metadir_inum;
-extern mdsio_fid_t	mds_fidnsdir_inum;
-extern mdsio_fid_t	mds_tmpdir_inum;
+extern mdsio_fid_t	mds_upschdir_inum[];
+extern mdsio_fid_t	mds_metadir_inum[];
+extern mdsio_fid_t	mds_fidnsdir_inum[];
+extern mdsio_fid_t	mds_tmpdir_inum[];
+
+struct rootNames {
+	char			 rn_name[MAXPATHLEN];
+	int			 rn_vfsid;
+	struct psc_hashent	 rn_hentry;
+};
 
 #endif
Index: slash_nara/slashd/bmap_mds.c
===================================================================
--- slash_nara/slashd/bmap_mds.c	(revision 19015)
+++ slash_nara/slashd/bmap_mds.c	(working copy)
@@ -23,20 +23,22 @@
 #include "pfl/cdefs.h"
 #include "pfl/fs.h"
 #include "psc_util/log.h"
 
 #include "bmap_mds.h"
 #include "fidc_mds.h"
 #include "mdsio.h"
 #include "repl_mds.h"
 #include "slerr.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 static __inline void *
 bmap_2_mdsio_data(struct bmapc_memb *b)
 {
 	struct fcmh_mds_info *fmi;
 
 	fmi = fcmh_2_fmi(b->bcm_fcmh);
 	psc_assert(fmi->fmi_mdsio_data);
 	return (fmi->fmi_mdsio_data);
 }
 
@@ -93,27 +95,31 @@
  * mds_bmap_read - Retrieve a bmap from the ondisk inode file.
  * @b: bmap.
  * Returns zero on success, negative errno code on failure.
  */
 int
 mds_bmap_read(struct bmapc_memb *b, __unusedx enum rw rw, int flags)
 {
 	uint64_t crc, od_crc = 0;
 	struct iovec iovs[2];
 	size_t nb;
-	int rc;
+	int rc, vfsid;
+	struct fidc_membh *fcmh;
 
 	iovs[0].iov_base = bmap_2_ondisk(b);
 	iovs[0].iov_len = BMAP_OD_CRCSZ;
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb,
+
+	fcmh = b->bcm_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb,
 	    (off_t)BMAP_OD_SZ * b->bcm_bmapno + SL_BMAP_START_OFF,
 	    bmap_2_mdsio_data(b));
 
 	if (rc == 0 && nb == 0 && (flags & BMAPGETF_NOAUTOINST))
 		return (SLERR_BMAP_INVALID);
 
 	/*
 	 * Check for a NULL CRC if we had a good read.  NULL CRC can
 	 * happen when bmaps are gaps that have not been written yet.
 	 * Note that a short read is tolerated as long as the bmap is
@@ -159,36 +165,40 @@
  * be removed after things are proven to be stablized.
  */
 int
 mds_bmap_write(struct bmapc_memb *b, int update_mtime, void *logf,
     void *logarg)
 {
 	struct iovec iovs[2];
 	int locked, rc, new;
 	uint64_t crc;
 	size_t nb;
+	struct fidc_membh *fcmh;
+	int vfsid;
 
 	BMAPOD_REQRDLOCK(bmap_2_bmi(b));
 	if (BMAP_HASLOCK(b))
 		BMAP_ULOCK(b);
 	mds_bmap_ensure_valid(b);
 
 	psc_crc64_calc(&crc, bmap_2_ondisk(b), BMAP_OD_CRCSZ);
 
 	iovs[0].iov_base = bmap_2_ondisk(b);
 	iovs[0].iov_len = BMAP_OD_CRCSZ;
 	iovs[1].iov_base = &crc;
 	iovs[1].iov_len = sizeof(crc);
 
 	if (logf)
 		mds_reserve_slot(1);
-	rc = mdsio_pwritev(&rootcreds, iovs, nitems(iovs), &nb,
+	fcmh = b->bcm_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_pwritev(vfsid, &rootcreds, iovs, nitems(iovs), &nb,
 	    (off_t)BMAP_OD_SZ * b->bcm_bmapno + SL_BMAP_START_OFF,
 	    update_mtime, bmap_2_mdsio_data(b), logf, logarg);
 	if (logf)
 		mds_unreserve_slot(1);
 
 	if (rc == 0 && nb != BMAP_OD_SZ)
 		rc = SLERR_SHORTIO;
 	if (rc)
 		DEBUG_BMAP(PLL_ERROR, b,
 		    "mdsio_write: error (rc=%d)", rc);
@@ -239,46 +249,51 @@
 mds_bmap_crc_update(struct bmapc_memb *bmap,
     struct srm_bmap_crcup *crcup)
 {
 	struct bmap_mds_info *bmi = bmap_2_bmi(bmap);
 	struct slash_inode_handle *ih;
 	struct sl_mds_crc_log crclog;
 	struct fidc_membh *f;
 	struct srt_stat sstb;
 	uint32_t i;
 	sl_ios_id_t iosid;
-	int fl, idx;
+	int fl, idx, vfsid;
 
 	psc_assert(bmap->bcm_flags & BMAP_MDS_CRC_UP);
 
 	f = bmap->bcm_fcmh;
 	ih = fcmh_2_inoh(f);
 
+	if (mdsio_fid_to_vfsid(fcmh_2_fid(f), &vfsid) < 0)
+		return (EINVAL);
+	if (vfsid != current_vfsid)
+		return (EINVAL);
+
 	FCMH_LOCK(f);
 	fcmh_wait_locked(f, f->fcmh_flags & FCMH_IN_SETATTR);
 
 	iosid = bmi->bmdsi_wr_ion->rmmi_resm->resm_res_id;
-	idx = mds_repl_ios_lookup(ih, iosid);
+	idx = mds_repl_ios_lookup(vfsid, ih, iosid);
 	if (idx < 0)
 		psc_fatal("not found");
 	sstb.sst_blocks = fcmh_2_nblks(f) + crcup->nblks -
 	    fcmh_2_repl_nblks(f, idx);
 	fl = SL_SETATTRF_NBLKS;
 
 	/* use nolog because mdslog_bmap_crc will cover this */
-	mds_fcmh_setattr_nolog(f, fl, &sstb);
+	mds_fcmh_setattr_nolog(vfsid, f, fl, &sstb);
 
 	fcmh_set_repl_nblks(f, idx, crcup->nblks);
 	if (idx >= SL_DEF_REPLICAS)
-		mds_inox_write(ih, NULL, NULL);
+		mds_inox_write(vfsid, ih, NULL, NULL);
 	else
-		mds_inode_write(ih, NULL, NULL);
+		mds_inode_write(vfsid, ih, NULL, NULL);
 
 	FCMH_ULOCK(f);
 
 	crclog.scl_bmap = bmap;
 	crclog.scl_crcup = crcup;
 
 	BMAPOD_REQWRLOCK(bmi);
 	for (i = 0; i < crcup->nups; i++) {
 		bmap_2_crcs(bmap, crcup->crcs[i].slot) =
 		    crcup->crcs[i].crc;
Index: slash_nara/slashd/mds.c
===================================================================
--- slash_nara/slashd/mds.c	(revision 19015)
+++ slash_nara/slashd/mds.c	(working copy)
@@ -39,20 +39,22 @@
 #include "mdsio.h"
 #include "mdslog.h"
 #include "odtable_mds.h"
 #include "repl_mds.h"
 #include "rpc_mds.h"
 #include "slashd.h"
 #include "slashrpc.h"
 #include "slerr.h"
 #include "up_sched_res.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 struct odtable	*mdsBmapAssignTable;
 uint64_t	 mdsBmapSequenceNo;
 
 int
 mds_bmap_exists(struct fidc_membh *f, sl_bmapno_t n)
 {
 	sl_bmapno_t nb;
 	int locked;
 
 	locked = FCMH_RLOCK(f);
@@ -447,21 +449,21 @@
 mds_bmap_add_repl(struct bmapc_memb *b, struct bmap_ios_assign *bia)
 {
 	struct slmds_jent_assign_rep *logentry;
 	struct slmds_jent_bmap_assign *sjba;
 	struct slash_inode_handle *ih = fcmh_2_inoh(b->bcm_fcmh);
 	int iosidx;
 	uint32_t nrepls = ih->inoh_ino.ino_nrepls;
 
 	psc_assert(b->bcm_flags & BMAP_IONASSIGN);
 
-	iosidx = mds_repl_ios_lookup_add(ih, bia->bia_ios, 0);
+	iosidx = mds_repl_ios_lookup_add(current_vfsid, ih, bia->bia_ios, 0);
 	if (iosidx < 0)
 		psc_fatalx("ios_lookup_add %d: %s", bia->bia_ios,
 		   slstrerror(iosidx));
 
 	if (mds_repl_inv_except(b, iosidx)) {
 		DEBUG_BMAP(PLL_ERROR, b, "mds_repl_inv_except() failed");
 		return (-1);
 	}
 	mds_reserve_slot(1);
 	logentry = pjournal_get_buf(mdsJournal, sizeof(*logentry));
@@ -1320,21 +1322,26 @@
  *	compared against the ID stored in the bml
  */
 int
 mds_bmap_crc_write(struct srm_bmap_crcup *c, sl_ios_id_t ios,
     const struct srm_bmap_crcwrt_req *mq)
 {
 	struct bmapc_memb *bmap = NULL;
 	struct bmap_mds_info *bmi;
 	struct fidc_membh *fcmh;
 	struct sl_resource *res = libsl_id2res(ios);
-	int rc;
+	int rc, vfsid;
+
+	if (mdsio_fid_to_vfsid(c->fg.fg_fid, &vfsid) < 0)
+		return (-EINVAL);
+	if (vfsid != current_vfsid)
+		return (-EINVAL);
 
 	rc = slm_fcmh_get(&c->fg, &fcmh);
 	if (rc) {
 		if (rc == ENOENT) {
 			psclog_warnx("fid="SLPRI_FID" appears to have "
 			    "been deleted", c->fg.fg_fid);
 			return (0);
 		}
 		psclog_errorx("fid="SLPRI_FID" slm_fcmh_get() rc=%d",
 		    c->fg.fg_fid, rc);
@@ -1418,21 +1425,21 @@
 	 */
 	mds_bmap_crc_update(bmap, c);
 
 	if (mq->flags & SRM_BMAPCRCWRT_PTRUNC) {
 		struct slash_inode_handle *ih;
 		int iosidx, tract[NBREPLST];
 		struct slm_workrq *wkrq;
 		uint32_t bpol;
 
 		ih = fcmh_2_inoh(fcmh);
-		iosidx = mds_repl_ios_lookup(ih,
+		iosidx = mds_repl_ios_lookup(vfsid, ih,
 		    bmi->bmdsi_wr_ion->rmmi_resm->resm_res_id);
 		if (iosidx < 0)
 			psclog_errorx("ios not found");
 		else {
 			BMAPOD_MODIFY_START(bmap);
 
 			brepls_init(tract, -1);
 			tract[BREPLST_TRUNCPNDG] = BREPLST_VALID;
 			tract[BREPLST_TRUNCPNDG_SCHED] = BREPLST_VALID;
 			mds_repl_bmap_apply(bmap, tract, NULL,
@@ -1473,21 +1480,21 @@
 	}
 
 	if (fcmh->fcmh_sstb.sst_mode & (S_ISGID | S_ISUID)) {
 		struct srt_stat sstb;
 
 		FCMH_LOCK(fcmh);
 		fcmh_wait_locked(fcmh, fcmh->fcmh_flags &
 		    FCMH_IN_SETATTR);
 		sstb.sst_mode = fcmh->fcmh_sstb.sst_mode &
 		    ~(S_ISGID | S_ISUID);
-		mds_fcmh_setattr_nolog(fcmh, PSCFS_SETATTRF_MODE,
+		mds_fcmh_setattr_nolog(vfsid, fcmh, PSCFS_SETATTRF_MODE,
 		    &sstb);
 		FCMH_ULOCK(fcmh);
 	}
 
  out:
 	/*
 	 * Mark that mds_bmap_crc_write() is done with this bmap
 	 *  - it was incref'd in fcmh_bmap_lookup().
 	 */
 	if (bmap)
@@ -1949,21 +1956,21 @@
 	/*
 	 * XXX bmaps issued in the wild not accounted for in fcmh_fsz
 	 * are skipped here.
 	 */
 	if (fmi->fmi_ptrunc_size >= fcmh_2_fsz(fcmh)) {
 		fcmh_wait_locked(fcmh, fcmh->fcmh_flags & FCMH_IN_SETATTR);
 		if (fmi->fmi_ptrunc_size > fcmh_2_fsz(fcmh)) {
 			struct srt_stat sstb;
 
 			sstb.sst_size = fmi->fmi_ptrunc_size;
-			mds_fcmh_setattr_nolog(fcmh,
+			mds_fcmh_setattr_nolog(current_vfsid, fcmh,
 			    PSCFS_SETATTRF_DATASIZE, &sstb);
 		}
 		fcmh->fcmh_flags &= ~FCMH_IN_PTRUNC;
 		fcmh_op_done_type(fcmh, FCMH_OPCNT_WORKER);
 		slm_ptrunc_wake_clients(wkrq);
 		return (0);
 	}
 
 	i = fmi->fmi_ptrunc_size / SLASH_BMAP_SIZE;
 	FCMH_ULOCK(fcmh);
@@ -2005,21 +2012,21 @@
 
 	/* all client leases have been relinquished */
 	/* XXX: wait for any CRC updates coming from sliods */
 
 	FCMH_LOCK(fcmh);
 	to_set = PSCFS_SETATTRF_DATASIZE | SL_SETATTRF_PTRUNCGEN;
 	fcmh_2_ptruncgen(fcmh)++;
 	fcmh->fcmh_sstb.sst_size = fmi->fmi_ptrunc_size;
 
 	mds_reserve_slot(1);
-	rc = mdsio_setattr(fcmh_2_mdsio_fid(fcmh), &fcmh->fcmh_sstb,
+	rc = mdsio_setattr(current_vfsid, fcmh_2_mdsio_fid(fcmh), &fcmh->fcmh_sstb,
 	    to_set, &rootcreds, &fcmh->fcmh_sstb,
 	    fcmh_2_mdsio_data(fcmh), mdslog_namespace);
 	mds_unreserve_slot(1);
 
 	if (rc)
 		psclog_error("setattr rc=%d", rc);
 
 	FCMH_ULOCK(fcmh);
 	slm_ptrunc_apply(wkrq);
 	return (0);
Index: slash_nara/slashd/slashd.h
===================================================================
--- slash_nara/slashd/slashd.h	(revision 19015)
+++ slash_nara/slashd/slashd.h	(working copy)
@@ -248,21 +248,21 @@
 void		 slm_setattr_core(struct fidc_membh *, struct srt_stat *, int);
 
 void		 slm_workq_init(void);
 void		 slm_workers_spawn(void);
 
 extern struct slash_creds	 rootcreds;
 extern struct odtable		*mdsBmapAssignTable;
 extern struct sl_mds_nsstats	 slm_nsstats_aggr;	/* aggregate namespace stats */
 extern struct sl_mds_peerinfo	*localinfo;
 
-extern uint64_t			 slm_fsuuid;
+extern uint64_t			 slm_fsuuid[];
 extern struct psc_poolmgr	*slm_workrq_pool;
 extern struct psc_listcache	 slm_workq;
 
 static __inline int
 slm_get_rpmi_idx(struct sl_resource *res)
 {
 	struct resprof_mds_info *rpmi;
 	int locked, n;
 
 	rpmi = res2rpmi(res);
Index: slash_nara/slashd/rpc_mds.c
===================================================================
--- slash_nara/slashd/rpc_mds.c	(revision 19015)
+++ slash_nara/slashd/rpc_mds.c	(working copy)
@@ -26,24 +26,28 @@
 #include "psc_rpc/rpc.h"
 #include "psc_rpc/rsx.h"
 #include "psc_rpc/service.h"
 
 #include "bmap_mds.h"
 #include "repl_mds.h"
 #include "rpc_mds.h"
 #include "slashd.h"
 #include "slashrpc.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 struct pscrpc_svc_handle slm_rmi_svc;
 struct pscrpc_svc_handle slm_rmm_svc;
 struct pscrpc_svc_handle slm_rmc_svc;
 
+extern int current_vfsid;
+
 void
 slmresmonthr_main(__unusedx struct psc_thread *thr)
 {
 	struct slashrpc_cservice *csvc;
 	struct sl_resource *r;
 	struct sl_resm *m;
 	int i;
 
 	while (pscthr_run()) {
 		sleep(30);
@@ -217,21 +221,21 @@
 		};
 
 		rc = RSX_NEWREQN(csvc->csvc_import, csvc->csvc_version,
 		    op, *rqp, nitems(qlens), qlens, nitems(plens),
 		    plens, *(void **)mqp);
 	} else
 		rc = slrpc_newgenreq(csvc, op, rqp, qlen, plen, mqp);
 	if (rc == 0 && op == SRMT_CONNECT) {
 		struct srm_connect_req *mq = *(void **)mqp;
 
-		mq->fsuuid = slm_fsuuid;
+		mq->fsuuid = zfsMount[current_vfsid].uuid;
 	}
 	return (rc);
 }
 
 int
 slrpc_waitrep(struct slashrpc_cservice *csvc,
     struct pscrpc_request *rq, int plen, void *mpp)
 {
 	int rc;
 
@@ -258,14 +262,14 @@
 
 		rc = slrpc_allocrepn(rq, mqp, qlen, mpp, nitems(plens),
 		    plens, rcoff);
 		slm_rpc_ion_unpack_statfs(rq, PSCRPC_MSG_REQUEST);
 		slm_rpc_ion_pack_bmapminseq(rq->rq_repmsg);
 	} else
 		rc = slrpc_allocgenrep(rq, mqp, qlen, mpp, plen, rcoff);
 	if (rc == 0 && rq->rq_reqmsg->opc == SRMT_CONNECT) {
 		struct srm_connect_rep *mp = *(void **)mpp;
 
-		mp->fsuuid = slm_fsuuid;
+		mp->fsuuid = zfsMount[current_vfsid].uuid;
 	}
 	return (rc);
 }
Index: slash_nara/slashd/ino_compat.c
===================================================================
--- slash_nara/slashd/ino_compat.c	(revision 19015)
+++ slash_nara/slashd/ino_compat.c	(working copy)
@@ -25,22 +25,26 @@
 
 #include "bmap_mds.h"
 #include "fidc_mds.h"
 #include "inode.h"
 #include "journal_mds.h"
 #include "mdsio.h"
 #include "mdslog.h"
 #include "slashd.h"
 #include "slerr.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
+extern int current_vfsid;
+
 int
-mds_inode_dump(struct sl_ino_compat *sic, struct slash_inode_handle *ih,
+mds_inode_dump(int vfsid, struct sl_ino_compat *sic, struct slash_inode_handle *ih,
     void *readh)
 {
 	struct fidc_membh *f;
 	struct bmapc_memb *b;
 	sl_bmapno_t i;
 	int rc, fl;
 	void *th;
 
 	f = ih->inoh_fcmh;
 	th = inoh_2_mdsio_data(ih);
@@ -73,130 +77,139 @@
 			}
 		}
 
 		rc = mds_bmap_write(b, 0, NULL, NULL);
 		bmap_op_done_type(b, BMAP_OPCNT_LOOKUP);
 		INOH_RLOCK(ih);
 		if (rc)
 			return (rc);
 	}
 
-	rc = mds_inox_write(ih, NULL, NULL);
+	rc = mds_inox_write(vfsid, ih, NULL, NULL);
 	if (rc)
 		return (rc);
 
-	rc = mds_inode_write(ih, NULL, NULL);
+	rc = mds_inode_write(vfsid, ih, NULL, NULL);
 	if (rc)
 		return (rc);
 
-	mdsio_fsync(&rootcreds, 1, th);
+	mdsio_fsync(vfsid, &rootcreds, 1, th);
 	return (0);
 }
 
 int
-mds_inode_update(struct slash_inode_handle *ih, int old_version)
+mds_inode_update(int vfsid, struct slash_inode_handle *ih, int old_version)
 {
 	char fn[NAME_MAX + 1];
 	struct sl_ino_compat *sic;
 	struct srt_stat sstb;
 	void *h = NULL, *th;
 	int rc;
+	struct fidc_membh	*fcmh;
 
 	sic = &sl_ino_compat_table[old_version];
 	rc = sic->sic_read_ino(ih);
 	if (rc)
 		return (rc);
 	DEBUG_INOH(PLL_INFO, ih, "updating old inode (v %d)",
 	    old_version);
 
+	fcmh = ih->inoh_fcmh;
 	snprintf(fn, sizeof(fn), "%016"PRIx64".update",
-	    fcmh_2_fid(ih->inoh_fcmh));
-	rc = mdsio_opencreatef(mds_tmpdir_inum, &rootcreds, O_RDWR |
-	    O_CREAT | O_TRUNC, MDSIO_OPENCRF_NOLINK, 0644, fn, NULL,
-	    NULL, &h, NULL, NULL, 0);
+	    fcmh_2_fid(fcmh));
+	rc = mdsio_opencreatef(vfsid, mds_tmpdir_inum[vfsid], 
+		&rootcreds, O_RDWR | O_CREAT | O_TRUNC, MDSIO_OPENCRF_NOLINK, 0644, fn, NULL, 
+		NULL, &h, NULL, NULL, 0);
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
 	psc_assert(ih->inoh_extras == NULL);
 	ih->inoh_extras = PSCALLOC(INOX_SZ);
 	ih->inoh_flags |= INOH_HAVE_EXTRAS;
 
 	/* convert old structures into new into temp file */
 	rc = sic->sic_read_inox(ih);
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
 	th = inoh_2_mdsio_data(ih);
 	inoh_2_mdsio_data(ih) = h;
-	rc = mds_inode_dump(sic, ih, th);
+	rc = mds_inode_dump(vfsid, sic, ih, th);
 	inoh_2_mdsio_data(ih) = th;
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
 	/* move new structures to inode meta file */
 	memset(&sstb, 0, sizeof(sstb));
-	rc = mdsio_setattr(0, &sstb, SL_SETATTRF_METASIZE, &rootcreds,
+	rc = mdsio_setattr(vfsid, 0, &sstb, SL_SETATTRF_METASIZE, &rootcreds,
 	    NULL, th, NULL);
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
 //	mdsio_rename(mds_tmpdir_inum, NULL, fn, &rootcreds, NULL);
-	rc = mds_inode_dump(NULL, ih, h);
+	rc = mds_inode_dump(vfsid, NULL, ih, h);
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
-	mdsio_unlink(mds_tmpdir_inum, NULL, fn, &rootcreds, NULL, NULL);
+	mdsio_unlink(vfsid, mds_tmpdir_inum[vfsid], NULL, fn, &rootcreds, NULL, NULL);
 
  out:
 	if (h)
-		mdsio_release(&rootcreds, h);
+		mdsio_release(vfsid, &rootcreds, h);
 	if (rc) {
-		mdsio_unlink(mds_tmpdir_inum, NULL, fn, &rootcreds,
+		mdsio_unlink(vfsid, mds_tmpdir_inum[vfsid], NULL, fn, &rootcreds,
 		    NULL, NULL);
 		DEBUG_INOH(PLL_ERROR, ih, "error updating old inode "
 		    "rc=%d", rc);
 	}
 	return (rc);
 }
 
 int
-mds_inode_update_interrupted(struct slash_inode_handle *ih, int *rc)
+mds_inode_update_interrupted(int vfsid, struct slash_inode_handle *ih, int *rc)
 {
 	char fn[NAME_MAX + 1];
 	struct srt_stat sstb;
 	struct iovec iovs[2];
 	uint64_t crc, od_crc;
 	void *h = NULL, *th;
 	mdsio_fid_t inum;
 	int exists = 0;
 	size_t nb;
+	struct fidc_membh *fcmh;
 
+	fcmh = ih->inoh_fcmh;
+	if (vfsid != current_vfsid) {
+		*rc = EINVAL;
+		PFL_GOTOERR(out, *rc);
+	}
+	
 	th = inoh_2_mdsio_data(ih);
 
 	snprintf(fn, sizeof(fn), "%016"PRIx64".update",
 	    fcmh_2_fid(ih->inoh_fcmh));
 
-	*rc = mdsio_lookup(mds_tmpdir_inum, fn, &inum, &rootcreds, NULL);
+	*rc = mdsio_lookup(vfsid, mds_tmpdir_inum[vfsid], fn, &inum, &rootcreds, NULL);
 	if (*rc)
 		PFL_GOTOERR(out, *rc);
 
-	*rc = mdsio_opencreatef(inum, &rootcreds, O_RDONLY,
+	*rc = mdsio_opencreatef(vfsid, inum, &rootcreds, O_RDONLY,
 	    MDSIO_OPENCRF_NOLINK, 0644, NULL, NULL, NULL, &h, NULL,
 	    NULL, 0);
 	if (*rc)
 		PFL_GOTOERR(out, *rc);
 
 	iovs[0].iov_base = &ih->inoh_ino;
 	iovs[0].iov_len = sizeof(ih->inoh_ino);
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	*rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb, 0, h);
+	*rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb, 0, h);
 	if (*rc)
 		PFL_GOTOERR(out, *rc);
 
 	psc_crc64_calc(&crc, &ih->inoh_ino, sizeof(ih->inoh_ino));
 	if (crc != od_crc) {
 		*rc = SLERR_BADCRC;
 		PFL_GOTOERR(out, *rc);
 	}
 
 	exists = 1;
@@ -206,60 +219,64 @@
 	ih->inoh_flags |= INOH_HAVE_EXTRAS;
 
 	inoh_2_mdsio_data(ih) = h;
 	*rc = mds_inox_ensure_loaded(ih);
 	if (*rc)
 		PFL_GOTOERR(out, *rc);
 
 	inoh_2_mdsio_data(ih) = th;
 
 	memset(&sstb, 0, sizeof(sstb));
-	*rc = mdsio_setattr(0, &sstb, SL_SETATTRF_METASIZE, &rootcreds,
+	*rc = mdsio_setattr(vfsid, 0, &sstb, SL_SETATTRF_METASIZE, &rootcreds,
 	    NULL, th, NULL);
 	if (*rc)
 		PFL_GOTOERR(out, *rc);
 
-	*rc = mds_inode_dump(NULL, ih, h);
+	*rc = mds_inode_dump(vfsid, NULL, ih, h);
 	if (*rc)
 		PFL_GOTOERR(out, *rc);
 
-	mdsio_unlink(mds_tmpdir_inum, NULL, fn, &rootcreds, NULL, NULL);
+	mdsio_unlink(vfsid, mds_tmpdir_inum[vfsid], NULL, fn, &rootcreds, NULL, NULL);
 
  out:
 	if (h)
-		mdsio_release(&rootcreds, h);
-	mdsio_unlink(mds_tmpdir_inum, NULL, fn, &rootcreds, NULL, NULL);
+		mdsio_release(vfsid, &rootcreds, h);
+	mdsio_unlink(vfsid, mds_tmpdir_inum[vfsid], NULL, fn, &rootcreds, NULL, NULL);
 	inoh_2_mdsio_data(ih) = th;
 	return (exists);
 }
 
 int
 mds_ino_read_v1(struct slash_inode_handle *ih)
 {
 	struct {
 		uint16_t	version;
 		uint16_t	flags;
 		uint32_t	bsz;
 		uint32_t	nrepls;
 		uint32_t	replpol;
 		sl_replica_t	repls[4];
 	} ino;
 	uint64_t crc, od_crc;
 	struct iovec iovs[2];
 	size_t nb;
-	int i, rc;
+	int i, rc, vfsid;
+	struct fidc_membh	*fcmh;
 
 	iovs[0].iov_base = &ino;
 	iovs[0].iov_len = sizeof(ino);
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb, 0,
+
+	fcmh = ih->inoh_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb, 0,
 	    inoh_2_mdsio_data(ih));
 
 	if (rc)
 		return (rc);
 	if (nb != sizeof(ino) + sizeof(od_crc))
 		return (SLERR_SHORTIO);
 
 	psc_crc64_calc(&crc, &ino, sizeof(ino));
 	if (crc != od_crc)
 		return (SLERR_BADCRC);
@@ -275,29 +292,33 @@
 int
 mds_inox_read_v1(struct slash_inode_handle *ih)
 {
 	struct {
 		sl_snap_t	snaps[1];
 		sl_replica_t	repls[60];
 	} inox;
 	uint64_t crc, od_crc;
 	struct iovec iovs[2];
 	size_t nb;
-	int i, rc;
+	int i, rc, vfsid;
+	struct fidc_membh	*fcmh;
 
 	memset(&inox, 0, sizeof(inox));
 
 	iovs[0].iov_base = &inox;
 	iovs[0].iov_len = sizeof(inox);
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb, 0x400,
+
+	fcmh = ih->inoh_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb, 0x400,
 	    inoh_2_mdsio_data(ih));
 
 	if (rc)
 		return (rc);
 	if (pfl_memchk(&inox, 0, sizeof(inox)) && od_crc == 0)
 		return (0);
 	if (nb != sizeof(inox) + sizeof(od_crc))
 		return (SLERR_SHORTIO);
 
 	psc_crc64_calc(&crc, &inox, sizeof(inox));
@@ -314,29 +335,32 @@
 	struct {
 		uint8_t		crcstates[128];
 		uint8_t		repls[24];
 		uint64_t	crcs[128];
 		uint32_t	gen;
 		uint32_t	replpol;
 	} bod;
 	uint64_t crc, od_crc;
 	struct iovec iovs[2];
 	size_t nb, bsz;
-	int i, rc;
+	int i, rc, vfsid;
+	struct fidc_membh	*fcmh;
 
 	bsz = sizeof(bod) + sizeof(crc);
 
 	iovs[0].iov_base = &bod;
 	iovs[0].iov_len = sizeof(bod);
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb,
+	fcmh = b->bcm_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb,
 	    bsz * b->bcm_bmapno + 0x1000, readh);
 
 	if (rc)
 		return (rc);
 	if (nb == 0)
 		return (SLERR_BMAP_INVALID);
 	if (nb != bsz)
 		return (SLERR_SHORTIO);
 
 	psc_crc64_calc(&crc, &bod, sizeof(bod));
Index: slash_nara/slashd/rpc_mds.h
===================================================================
--- slash_nara/slashd/rpc_mds.h	(revision 19015)
+++ slash_nara/slashd/rpc_mds.h	(working copy)
@@ -84,21 +84,21 @@
 
 int	slm_rmc_handle_lookup(struct pscrpc_request *);
 
 int	slm_rmc_handler(struct pscrpc_request *);
 int	slm_rmi_handler(struct pscrpc_request *);
 int	slm_rmm_handler(struct pscrpc_request *);
 int	slm_rmm_forward_namespace(int, struct slash_fidgen *,
 	    struct slash_fidgen *, char *, char *, uint32_t,
 	    const struct slash_creds *, struct srt_stat *, int32_t);
 
-int	slm_mkdir(struct srm_mkdir_req *, struct srm_mkdir_rep *, int,
+int	slm_mkdir(int, struct srm_mkdir_req *, struct srm_mkdir_rep *, int,
 	    struct fidc_membh **);
 int	slm_symlink(struct pscrpc_request *, struct srm_symlink_req *,
 	    struct srm_symlink_rep *, int);
 
 /* aliases for connection management */
 #define slm_getmcsvcx(resm, exp)					\
 	sl_csvc_get(&(resm)->resm_csvc, CSVCF_USE_MULTIWAIT, (exp),	\
 	    &(resm)->resm_nids, SRMM_REQ_PORTAL, SRMM_REP_PORTAL,	\
 	    SRMM_MAGIC, SRMM_VERSION, &resm2rmmi(resm)->rmmi_mutex,	\
 	    &resm2rmmi(resm)->rmmi_mwcond, SLCONNT_MDS, NULL)
Index: slash_nara/slashd/mdsio_zfs.c
===================================================================
--- slash_nara/slashd/mdsio_zfs.c	(revision 19015)
+++ slash_nara/slashd/mdsio_zfs.c	(working copy)
@@ -37,33 +37,63 @@
 #include "fidcache.h"
 #include "inode.h"
 #include "journal_mds.h"
 #include "mdsio.h"
 #include "pathnames.h"
 #include "slashd.h"
 #include "slerr.h"
 
 #include "zfs-fuse/zfs_slashlib.h"
 
-mdsio_fid_t		 mds_metadir_inum;
-mdsio_fid_t		 mds_upschdir_inum;
-mdsio_fid_t		 mds_fidnsdir_inum;
-mdsio_fid_t		 mds_tmpdir_inum;
+mdsio_fid_t		 mds_metadir_inum[MAX_FILESYSTEMS];
+mdsio_fid_t		 mds_upschdir_inum[MAX_FILESYSTEMS];
+mdsio_fid_t		 mds_fidnsdir_inum[MAX_FILESYSTEMS];
+mdsio_fid_t		 mds_tmpdir_inum[MAX_FILESYSTEMS];
+
+int
+mdsio_fid_to_vfsid(slfid_t fid, int *vfsid)
+{
+	int i, fsid;
+	
+#if 0
+	/* our client uses this special fid to contact us
+	 * during mount. */
+	if (fid == SLFID_ROOT) {
+		*vfsid = current_vfsid;
+		return (0);
+	}
+#endif
+	/* only have default file system in the root */
+	if (mount_index == 1) {
+		*vfsid = current_vfsid;
+		return (0);
+	}
+
+	fsid = FID_GET_SITEID(fid);
+	for (i = 0; i < mount_index; i++) {
+		if (zfsMount[i].fsid == (uint64_t)fsid) {
+			*vfsid = i;
+			return (0);
+		}
+	}
+	return (-1);
+}
 
 int
 mdsio_fcmh_refreshattr(struct fidc_membh *f, struct srt_stat *out_sstb)
 {
-	int locked, rc;
+	int locked, rc, vfsid;
 
 	locked = FCMH_RLOCK(f);
 	fcmh_wait_locked(f, f->fcmh_flags & FCMH_IN_SETATTR);
-	rc = mdsio_getattr(fcmh_2_mdsio_fid(f), fcmh_2_mdsio_data(f),
+	mdsio_fid_to_vfsid(fcmh_2_fid(f), &vfsid);
+	rc = mdsio_getattr(vfsid, fcmh_2_mdsio_fid(f), fcmh_2_mdsio_data(f),
 	    &rootcreds, &f->fcmh_sstb);
 
 	psc_assert(rc == 0);
 
 	if (out_sstb)
 		*out_sstb = f->fcmh_sstb;
 	FCMH_URLOCK(f, locked);
 
 	return (rc);
 }
@@ -168,15 +198,15 @@
 	zfsslash2_replay_link,
 	zfsslash2_replay_mkdir,
 	zfsslash2_replay_rename,
 	zfsslash2_replay_rmdir,
 	zfsslash2_replay_setattr,
 	zfsslash2_replay_symlink,
 	zfsslash2_replay_unlink
 };
 
 int
-mdsio_write_cursor(void *buf, size_t size, void *finfo,
+mdsio_write_cursor(int vfsid, void *buf, size_t size, void *finfo,
     sl_log_write_t funcp)
 {
-	return (zfsslash2_write_cursor(buf, size, finfo, funcp));
+	return (zfsslash2_write_cursor(vfsid, buf, size, finfo, funcp));
 }
Index: slash_nara/slashd/inode.c
===================================================================
--- slash_nara/slashd/inode.c	(revision 19015)
+++ slash_nara/slashd/inode.c	(working copy)
@@ -23,73 +23,81 @@
 #include "pfl/cdefs.h"
 
 #include "fidc_mds.h"
 #include "inode.h"
 #include "journal_mds.h"
 #include "mdsio.h"
 #include "mdslog.h"
 #include "slashd.h"
 #include "slerr.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 __static void
 mds_inode_od_initnew(struct slash_inode_handle *ih)
 {
 	ih->inoh_flags = INOH_INO_NEW;
 
 	/* For now this is a fixed size. */
 	ih->inoh_ino.ino_bsz = SLASH_BMAP_SIZE;
 	ih->inoh_ino.ino_version = INO_VERSION;
 }
 
 int
 mds_inode_read(struct slash_inode_handle *ih)
 {
 	struct iovec iovs[2];
 	uint64_t crc, od_crc = 0;
 	uint16_t vers;
-	int rc, locked;
+	int rc, locked, vfsid;
 	size_t nb;
+	struct fidc_membh *fcmh;
+
+	fcmh = ih->inoh_fcmh;
+	if (mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid) < 0)
+		return (EINVAL);
 
 	locked = INOH_RLOCK(ih); /* XXX bad on slow archiver */
 	psc_assert(ih->inoh_flags & INOH_INO_NOTLOADED);
 
 	memset(&ih->inoh_ino, 0, sizeof(ih->inoh_ino));
 
 	iovs[0].iov_base = &ih->inoh_ino;
 	iovs[0].iov_len = sizeof(ih->inoh_ino);
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb, 0,
+
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb, 0,
 	    inoh_2_mdsio_data(ih));
 
 	if (rc == 0 && nb != sizeof(ih->inoh_ino) + sizeof(od_crc))
 		rc = SLERR_SHORTIO;
 
 	if (rc == SLERR_SHORTIO && od_crc == 0 &&
 	    pfl_memchk(&ih->inoh_ino, 0, sizeof(ih->inoh_ino))) {
-		if (!mds_inode_update_interrupted(ih, &rc)) {
+		if (!mds_inode_update_interrupted(vfsid, ih, &rc)) {
 			DEBUG_INOH(PLL_INFO, ih, "detected a new inode");
 			mds_inode_od_initnew(ih);
 			rc = 0;
 		}
 	} else if (rc && rc != SLERR_SHORTIO) {
 		DEBUG_INOH(PLL_ERROR, ih, "inode read error %d", rc);
 	} else {
 		psc_crc64_calc(&crc, &ih->inoh_ino, sizeof(ih->inoh_ino));
 		if (crc != od_crc) {
 			vers = ih->inoh_ino.ino_version;
 			memset(&ih->inoh_ino, 0, sizeof(ih->inoh_ino));
 
-			if (mds_inode_update_interrupted(ih, &rc))
+			if (mds_inode_update_interrupted(vfsid, ih, &rc))
 				;
 			else if (vers && vers < INO_VERSION)
-				rc = mds_inode_update(ih, vers);
+				rc = mds_inode_update(vfsid, ih, vers);
 			else if (rc == SLERR_SHORTIO)
 				DEBUG_INOH(PLL_INFO, ih,
 				    "short read I/O (%zd vs %zd)",
 				    nb, sizeof(ih->inoh_ino) +
 				    sizeof(od_crc));
 			else {
 				rc = SLERR_BADCRC;
 				DEBUG_INOH(PLL_WARN, ih, "CRC failed "
 				    "want=%"PSCPRIxCRC64", got=%"PSCPRIxCRC64,
 				    od_crc, crc);
@@ -98,21 +106,21 @@
 		if (rc == 0) {
 			ih->inoh_flags &= ~INOH_INO_NOTLOADED;
 			DEBUG_INOH(PLL_INFO, ih, "successfully loaded inode od");
 		}
 	}
 	INOH_URLOCK(ih, locked);
 	return (rc);
 }
 
 int
-mds_inode_write(struct slash_inode_handle *ih, void *logf, void *arg)
+mds_inode_write(int vfsid, struct slash_inode_handle *ih, void *logf, void *arg)
 {
 	struct iovec iovs[2];
 	uint64_t crc;
 	size_t nb;
 	int rc;
 
 	INOH_LOCK_ENSURE(ih);
 
 	fcmh_wait_locked(ih->inoh_fcmh, ih->inoh_flags & INOH_IN_IO);
 	ih->inoh_flags |= INOH_IN_IO;
@@ -121,21 +129,21 @@
 
 	iovs[0].iov_base = &ih->inoh_ino;
 	iovs[0].iov_len = sizeof(ih->inoh_ino);
 	iovs[1].iov_base = &crc;
 	iovs[1].iov_len = sizeof(crc);
 
 	INOH_ULOCK(ih);
 
 	if (logf)
 		mds_reserve_slot(1);
-	rc = mdsio_pwritev(&rootcreds, iovs, nitems(iovs), &nb, 0, 0,
+	rc = mdsio_pwritev(vfsid, &rootcreds, iovs, nitems(iovs), &nb, 0, 0,
 	    inoh_2_mdsio_data(ih), logf, arg);
 	if (logf)
 		mds_unreserve_slot(1);
 
 	INOH_LOCK(ih);
 	ih->inoh_flags &= ~INOH_IN_IO;
 	fcmh_wake_locked(ih->inoh_fcmh);
 
 	if (rc == 0 && nb != sizeof(ih->inoh_ino) + sizeof(crc))
 		rc = SLERR_SHORTIO;
@@ -147,21 +155,21 @@
 	else {
 		DEBUG_INOH(PLL_INFO, ih, "wrote inode, flags=%x, size=%d, data=%p",
 			ih->inoh_flags,  inoh_2_fsz(ih), inoh_2_mdsio_data(ih));
 		if (ih->inoh_flags & INOH_INO_NEW)
 			ih->inoh_flags &= ~INOH_INO_NEW;
 	}
 	return (rc);
 }
 
 int
-mds_inox_write(struct slash_inode_handle *ih, void *logf, void *arg)
+mds_inox_write(int vfsid, struct slash_inode_handle *ih, void *logf, void *arg)
 {
 	struct iovec iovs[2];
 	uint64_t crc;
 	size_t nb;
 	int rc;
 
 	INOH_LOCK_ENSURE(ih);
 
 	psc_assert(ih->inoh_extras);
 
@@ -172,21 +180,21 @@
 
 	iovs[0].iov_base = ih->inoh_extras;
 	iovs[0].iov_len = INOX_SZ;
 	iovs[1].iov_base = &crc;
 	iovs[1].iov_len = sizeof(crc);
 
 	INOH_ULOCK(ih);
 
 	if (logf)
 		mds_reserve_slot(1);
-	rc = mdsio_pwritev(&rootcreds, iovs, nitems(iovs), &nb,
+	rc = mdsio_pwritev(vfsid, &rootcreds, iovs, nitems(iovs), &nb,
 	    SL_EXTRAS_START_OFF, 0, inoh_2_mdsio_data(ih), logf, arg);
 	if (logf)
 		mds_unreserve_slot(1);
 
 	INOH_LOCK(ih);
 	ih->inoh_flags &= ~INOH_IN_IO;
 	fcmh_wake_locked(ih->inoh_fcmh);
 
 	if (rc == 0 && nb != INOX_SZ + sizeof(crc))
 		rc = SLERR_SHORTIO;
@@ -197,34 +205,38 @@
 
 	return (rc);
 }
 
 int
 mds_inox_load_locked(struct slash_inode_handle *ih)
 {
 	struct iovec iovs[2];
 	uint64_t crc, od_crc;
 	size_t nb;
-	int rc;
+	int rc, vfsid;
+	struct fidc_membh *fcmh;
 
 	INOH_LOCK_ENSURE(ih);
 
 	psc_assert(!(ih->inoh_flags & INOH_HAVE_EXTRAS));
 
 	psc_assert(ih->inoh_extras == NULL);
 	ih->inoh_extras = PSCALLOC(INOX_SZ);
 
 	iovs[0].iov_base = ih->inoh_extras;
 	iovs[0].iov_len = INOX_SZ;
 	iovs[1].iov_base = &od_crc;
 	iovs[1].iov_len = sizeof(od_crc);
-	rc = mdsio_preadv(&rootcreds, iovs, nitems(iovs), &nb,
+
+	fcmh = ih->inoh_fcmh;
+	mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+	rc = mdsio_preadv(vfsid, &rootcreds, iovs, nitems(iovs), &nb,
 	    SL_EXTRAS_START_OFF, inoh_2_mdsio_data(ih));
 	if (rc == 0 && od_crc == 0 &&
 	    pfl_memchk(ih->inoh_extras, 0, INOX_SZ)) {
 		ih->inoh_flags |= INOH_HAVE_EXTRAS;
 		rc = 0;
 	} else if (rc) {
 		rc = -abs(rc);
 		DEBUG_INOH(PLL_ERROR, ih, "read inox: %d", rc);
 	} else if (nb != INOX_SZ + sizeof(od_crc)) {
 		rc = -SLERR_SHORTIO;
@@ -253,40 +265,40 @@
 	int locked, rc = 0;
 
 	locked = INOH_RLOCK(ih);
 	if (ATTR_NOTSET(ih->inoh_flags, INOH_HAVE_EXTRAS))
 		rc = mds_inox_load_locked(ih);
 	INOH_URLOCK(ih, locked);
 	return (rc);
 }
 
 int
-mds_inodes_odsync(struct fidc_membh *f, void (*logf)(void *, uint64_t, int))
+mds_inodes_odsync(int vfsid, struct fidc_membh *f, void (*logf)(void *, uint64_t, int))
 {
 	struct slash_inode_handle *ih = fcmh_2_inoh(f);
 	int locked, rc;
 
 	locked = INOH_RLOCK(ih);
 	if (ih->inoh_ino.ino_nrepls > SL_DEF_REPLICAS) {
 		/* Don't assume the inox have been loaded.  It's possible
 		 * our caller didn't require them (BZ #258).
 		 */
 		rc = mds_inox_ensure_loaded(ih);
 		if (rc) {
 			INOH_URLOCK(ih, locked);
 			return (rc);
 		}
 	}
 
-	rc = mds_inode_write(ih, logf, f);
+	rc = mds_inode_write(vfsid, ih, logf, f);
 	if (rc == 0 && ih->inoh_ino.ino_nrepls > SL_DEF_REPLICAS)
-		rc = mds_inox_write(ih, NULL, NULL);
+		rc = mds_inox_write(vfsid, ih, NULL, NULL);
 
 	DEBUG_FCMH(PLL_DEBUG, f, "wrote updated ino_repls logf=%p", logf);
 	INOH_URLOCK(ih, locked);
 	return (rc);
 }
 
 #if PFL_DEBUG > 0
 static __inline void
 dump_inoh(const struct slash_inode_handle *ih)
 {
Index: slash_nara/slashd/inode.h
===================================================================
--- slash_nara/slashd/inode.h	(revision 19015)
+++ slash_nara/slashd/inode.h	(working copy)
@@ -125,30 +125,30 @@
 
 #define DEBUG_INOH(level, ih, fmt, ...)					\
 	_log_debug_inoh(PFL_CALLERINFO(), (level), (ih), (fmt), ## __VA_ARGS__)
 
 struct sl_ino_compat {
 	int			(*sic_read_ino)(struct slash_inode_handle *);
 	int			(*sic_read_inox)(struct slash_inode_handle *);
 	int			(*sic_read_bmap)(struct bmapc_memb *, void *);
 };
 
-int	mds_inode_update(struct slash_inode_handle *, int);
-int	mds_inode_update_interrupted(struct slash_inode_handle *, int *);
+int	mds_inode_update(int, struct slash_inode_handle *, int);
+int	mds_inode_update_interrupted(int, struct slash_inode_handle *, int *);
 int	mds_inode_read(struct slash_inode_handle *);
-int	mds_inode_write(struct slash_inode_handle *, void *, void *);
-int	mds_inox_write(struct slash_inode_handle *, void *, void *);
+int	mds_inode_write(int, struct slash_inode_handle *, void *, void *);
+int	mds_inox_write(int, struct slash_inode_handle *, void *, void *);
 
 int	mds_inox_load_locked(struct slash_inode_handle *);
 int	mds_inox_ensure_loaded(struct slash_inode_handle *);
 
-int	mds_inodes_odsync(struct fidc_membh *, void (*logf)(void *, uint64_t, int));
+int	mds_inodes_odsync(int, struct fidc_membh *, void (*logf)(void *, uint64_t, int));
 
 extern struct sl_ino_compat sl_ino_compat_table[];
 
 static __inline void
 slash_inode_handle_init(struct slash_inode_handle *ih,
     struct fidc_membh *f)
 {
 	ih->inoh_fcmh = f;
 	ih->inoh_flags = INOH_INO_NOTLOADED;
 }
Index: slash_nara/slashd/fidc_mds.c
===================================================================
--- slash_nara/slashd/fidc_mds.c	(revision 19015)
+++ slash_nara/slashd/fidc_mds.c	(working copy)
@@ -29,77 +29,85 @@
 #include "psc_util/lock.h"
 #include "psc_util/log.h"
 
 #include "cache_params.h"
 #include "fid.h"
 #include "fidc_mds.h"
 #include "fidcache.h"
 #include "mdsio.h"
 #include "slashd.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 int
-_mds_fcmh_setattr(struct fidc_membh *f, int to_set,
+_mds_fcmh_setattr(int vfsid, struct fidc_membh *f, int to_set,
     const struct srt_stat *sstb, int log)
 {
 	int rc = 0;
 
 	FCMH_LOCK_ENSURE(f);
 	psc_assert((f->fcmh_flags & FCMH_IN_SETATTR) == 0);
 
 	f->fcmh_flags |= FCMH_IN_SETATTR;
 
 	DEBUG_FCMH(PLL_INFO, f, "updating attributes, to_set=%#x",
 	    to_set);
 
 	FCMH_ULOCK(f);
 	if (log)
 		mds_reserve_slot(1);
-	rc = mdsio_setattr(fcmh_2_mdsio_fid(f), sstb, to_set,
+	rc = mdsio_setattr(vfsid, fcmh_2_mdsio_fid(f), sstb, to_set,
 	    &rootcreds, &f->fcmh_sstb, fcmh_2_mdsio_data(f),
 	    log ? mdslog_namespace : NULL);
 	if (log)
 		mds_unreserve_slot(1);
 	FCMH_LOCK(f);
 	psc_assert(f->fcmh_flags & FCMH_IN_SETATTR);
 
 	f->fcmh_flags &= ~FCMH_IN_SETATTR;
 	fcmh_wake_locked(f);
 	return (rc);
 }
 
 int
 slm_fcmh_ctor(struct fidc_membh *fcmh)
 {
 	struct fcmh_mds_info *fmi;
 	int rc;
+	int vfsid;
 
 	DEBUG_FCMH(PLL_INFO, fcmh, "ctor");
 
+	if (mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid) < 0) {
+		rc = EINVAL;
+		DEBUG_FCMH(PLL_WARN, fcmh, "invalid file system id (rc=%d)", rc);
+		return (rc);
+	}
 	fmi = fcmh_2_fmi(fcmh);
 	memset(fmi, 0, sizeof(*fmi));
 	psc_dynarray_init(&fmi->fmi_ptrunc_clients);
 
-	rc = mdsio_lookup_slfid(fcmh_2_fid(fcmh), &rootcreds,
-	    &fcmh->fcmh_sstb, &fcmh_2_mdsio_fid(fcmh));
+	rc = mdsio_lookup_slfid(vfsid, fcmh_2_fid(fcmh), 
+		&rootcreds, &fcmh->fcmh_sstb, &fcmh_2_mdsio_fid(fcmh));
 	if (rc) {
 		fmi->fmi_ctor_rc = rc;
 		DEBUG_FCMH(PLL_WARN, fcmh,
 		    "mdsio_lookup_slfid failed (rc=%d)", rc);
 		return (rc);
 	}
 
 	if (fcmh_isdir(fcmh))
-		rc = mdsio_opendir(fcmh_2_mdsio_fid(fcmh), &rootcreds,
-		    NULL, &fmi->fmi_mdsio_data);
+		rc = mdsio_opendir(vfsid, fcmh_2_mdsio_fid(fcmh), 
+			&rootcreds, NULL, &fmi->fmi_mdsio_data);
 	else if (fcmh_isreg(fcmh)) {
 		slash_inode_handle_init(&fmi->fmi_inodeh, fcmh);
-		rc = mdsio_opencreate(fcmh_2_mdsio_fid(fcmh),
+		rc = mdsio_opencreate(vfsid, fcmh_2_mdsio_fid(fcmh),
 		    &rootcreds, O_RDWR, 0, NULL, NULL, NULL,
 		    &fcmh_2_mdsio_data(fcmh), NULL, NULL, 0);
 		if (rc == 0) {
 			rc = mds_inode_read(&fmi->fmi_inodeh);
 			if (rc)
 				DEBUG_FCMH(PLL_WARN, fcmh,
 				    "could not load inode; rc=%d", rc);
 		} else {
 			fmi->fmi_ctor_rc = rc;
 			DEBUG_FCMH(PLL_WARN, fcmh,
@@ -108,68 +116,69 @@
 	} else
 		DEBUG_FCMH(PLL_INFO, fcmh, "special file, no zfs obj");
 
 	return (rc);
 }
 
 void
 slm_fcmh_dtor(struct fidc_membh *fcmh)
 {
 	struct fcmh_mds_info *fmi;
-	int rc;
+	int rc, vfsid;
 
 	fmi = fcmh_2_fmi(fcmh);
 	psc_assert(psc_dynarray_len(&fmi->fmi_ptrunc_clients) == 0);
 	psc_dynarray_free(&fmi->fmi_ptrunc_clients);
 
 	if (S_ISREG(fcmh->fcmh_sstb.sst_mode) ||
 	    S_ISDIR(fcmh->fcmh_sstb.sst_mode)) {
 		/* XXX Need to worry about other modes here */
 		if (!fmi->fmi_ctor_rc) {
-			rc = mdsio_release(&rootcreds,
+			mdsio_fid_to_vfsid(fcmh_2_fid(fcmh), &vfsid);
+			rc = mdsio_release(vfsid, &rootcreds,
 			    fmi->fmi_mdsio_data);
 			psc_assert(rc == 0);
 		}
 	}
 	if (fmi->fmi_inodeh.inoh_extras)
 		PSCFREE(fmi->fmi_inodeh.inoh_extras);
 }
 
 int
-_slm_fcmh_endow(struct fidc_membh *p, struct fidc_membh *c, int log)
+_slm_fcmh_endow(int vfsid, struct fidc_membh *p, struct fidc_membh *c, int log)
 {
 //	sl_replica_t repls[SL_MAX_REPLICAS];
 	uint32_t pol;
 //	int nrepls;
 	int rc = 0;
 
 	FCMH_LOCK(p);
 	pol = p->fcmh_sstb.sstd_freplpol;
 //	nrepls =
 //	memcpy();
 	FCMH_ULOCK(p);
 
 	FCMH_LOCK(c);
 	if (fcmh_isdir(c)) {
 		struct srt_stat sstb;
 
 		sstb.sstd_freplpol = pol;
 //		c->nrepls =
 //		c->memcpy();
-		mds_fcmh_setattr(c, SL_SETATTRF_FREPLPOL, &sstb);
+		mds_fcmh_setattr(vfsid, c, SL_SETATTRF_FREPLPOL, &sstb);
 	} else {
 //		fcmh_wait_locked(c, c->fcmh_flags & FCMH_IN_SETATTR);
 		fcmh_2_ino(c)->ino_replpol = pol;
 //		fcmh_2_ino(c)->ino_nrepls = 1;
 //		memcpy(fcmh_2_ino(c)->ino_repls, repls, sizeof());
 		if (log)
-			rc = mds_inode_write(fcmh_2_inoh(c), mdslog_ino_repls, c);
+			rc = mds_inode_write(vfsid, fcmh_2_inoh(c), mdslog_ino_repls, c);
 //		if (log)
 //			rc = mds_inox_write(fcmh_2_inoh(c), mdslog_ino_repls, c);
 	}
 	FCMH_ULOCK(c);
 	return (rc);
 }
 
 #if PFL_DEBUG > 0
 void
 dump_fcmh_flags(int flags)
Index: slash_nara/slashd/fidc_mds.h
===================================================================
--- slash_nara/slashd/fidc_mds.h	(revision 19015)
+++ slash_nara/slashd/fidc_mds.h	(working copy)
@@ -49,34 +49,34 @@
 #define fcmh_2_mdsio_fid(f)	fcmh_2_fmi(f)->fmi_mdsio_fid
 #define fcmh_2_nrepls(f)	fcmh_2_ino(f)->ino_nrepls
 #define fcmh_2_replpol(f)	fcmh_2_ino(f)->ino_replpol
 #define fcmh_2_metafsize(f)	(f)->fcmh_sstb.sst_blksize
 #define fcmh_nallbmaps(f)	howmany(fcmh_2_metafsize(f) - SL_BMAP_START_OFF, BMAP_OD_SZ)
 #define fcmh_nvalidbmaps(f)	howmany(fcmh_2_fsz(f), SLASH_BMAP_SIZE)
 
 #define FCMH_HAS_GARBAGE(f)	(fcmh_nallbmaps(f) > fcmh_nvalidbmaps(f))
 
 #define IS_REMOTE_FID(fid)						\
-	((fid) != SLFID_ROOT && nodeSite->site_id != FID_GET_SITEID(fid))
+	((fid) != SLFID_ROOT && current_vfsid != (int)FID_GET_SITEID(fid))
 
 #define slm_fcmh_get(fgp, fp)	fidc_lookup((fgp), FIDC_LOOKUP_CREATE, NULL, 0, (fp))
 #define slm_fcmh_peek(fgp, fp)	fidc_lookup((fgp), FIDC_LOOKUP_NONE, NULL, 0, (fp))
 
-#define	mds_fcmh_setattr(f, to_set, sstb)	_mds_fcmh_setattr((f), (to_set), (sstb), 1)
-#define	mds_fcmh_setattr_nolog(f, to_set, sstb)	_mds_fcmh_setattr((f), (to_set), (sstb), 0)
+#define	mds_fcmh_setattr(vfsid, f, to_set, sstb)	_mds_fcmh_setattr((vfsid), (f), (to_set), (sstb), 1)
+#define	mds_fcmh_setattr_nolog(vfsid, f, to_set, sstb)	_mds_fcmh_setattr((vfsid), (f), (to_set), (sstb), 0)
 
-int	_mds_fcmh_setattr(struct fidc_membh *, int, const struct srt_stat *, int);
+int	_mds_fcmh_setattr(int, struct fidc_membh *, int, const struct srt_stat *, int);
 
-#define slm_fcmh_endow(p, c)			_slm_fcmh_endow((p), (c), 1)
-#define slm_fcmh_endow_nolog(p, c)		_slm_fcmh_endow((p), (c), 0)
+#define slm_fcmh_endow(vfsid, p, c)			_slm_fcmh_endow((vfsid), (p), (c), 1)
+#define slm_fcmh_endow_nolog(vfsid, p, c)		_slm_fcmh_endow((vfsid), (p), (c), 0)
 
-int	_slm_fcmh_endow(struct fidc_membh *, struct fidc_membh *, int);
+int	_slm_fcmh_endow(int, struct fidc_membh *, struct fidc_membh *, int);
 
 extern uint64_t		slm_next_fid;
 extern psc_spinlock_t	slm_fid_lock;
 
 static __inline struct fcmh_mds_info *
 fcmh_2_fmi(struct fidc_membh *f)
 {
 	return (fcmh_get_pri(f));
 }
 
Index: slash_nara/slashd/rmc.c
===================================================================
--- slash_nara/slashd/rmc.c	(revision 19015)
+++ slash_nara/slashd/rmc.c	(working copy)
@@ -51,23 +51,36 @@
 #include "mkfn.h"
 #include "pathnames.h"
 #include "repl_mds.h"
 #include "rpc_mds.h"
 #include "slashd.h"
 #include "slashrpc.h"
 #include "slerr.h"
 #include "slutil.h"
 #include "up_sched_res.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
 uint64_t		slm_next_fid = UINT64_MAX;
 psc_spinlock_t		slm_fid_lock = SPINLOCK_INIT;
 
+extern struct psc_hashtbl rootHtable;
+
+void *
+slm_rmc_search_roots(char *name)
+{
+	void *p;
+
+	p = psc_hashtbl_search(&rootHtable, NULL, NULL, name);
+	return (p);
+}
+
 slfid_t
 slm_get_curr_slashfid(void)
 {
 	slfid_t fid;
 
 	spinlock(&slm_fid_lock);
 	fid = slm_next_fid;
 	freelock(&slm_fid_lock);
 	return (fid);
 }
@@ -308,153 +321,209 @@
 	fcmh_op_done_type(fcmh, FCMH_OPCNT_LOOKUP_FIDC);
 	return (rc ? rc : mp->rc);
 }
 
 int
 slm_rmc_handle_link(struct pscrpc_request *rq)
 {
 	struct fidc_membh *p = NULL, *c = NULL;
 	struct srm_link_req *mq;
 	struct srm_link_rep *mp;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+
+	if (mdsio_fid_to_vfsid(mq->fg.fg_fid, &vfsid) < 0) {
+		mp->rc = -EINVAL;
+		goto out;
+	}
+
 	mp->rc = slm_fcmh_get(&mq->fg, &c);
 	if (mp->rc)
 		goto out;
 	mp->rc = slm_fcmh_get(&mq->pfg, &p);
 	if (mp->rc)
 		goto out;
 
 	mq->name[sizeof(mq->name) - 1] = '\0';
 	mds_reserve_slot(1);
-	mp->rc = mdsio_link(fcmh_2_mdsio_fid(c), fcmh_2_mdsio_fid(p),
+	mp->rc = mdsio_link(vfsid, fcmh_2_mdsio_fid(c), fcmh_2_mdsio_fid(p),
 	    mq->name, &rootcreds, &mp->cattr, mdslog_namespace);
 	mds_unreserve_slot(1);
 
 	mdsio_fcmh_refreshattr(p, &mp->pattr);
 
  out:
 	if (c)
 		fcmh_op_done_type(c, FCMH_OPCNT_LOOKUP_FIDC);
 	if (p)
 		fcmh_op_done_type(p, FCMH_OPCNT_LOOKUP_FIDC);
 	return (0);
 }
 
 int
 slm_rmc_handle_lookup(struct pscrpc_request *rq)
 {
 	struct srm_lookup_req *mq;
 	struct srm_lookup_rep *mp;
 	struct fidc_membh *p;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = -EINVAL;
+		goto out;
+	}
 	mp->rc = slm_fcmh_get(&mq->pfg, &p);
 	if (mp->rc)
 		goto out;
 
 	mq->name[sizeof(mq->name) - 1] = '\0';
 	if (fcmh_2_mdsio_fid(p) == SLFID_ROOT &&
 	    strcmp(mq->name, SL_RPATH_META_DIR) == 0) {
 		mp->rc = -EINVAL;
 		goto out;
 	}
-	mp->rc = mdsio_lookup(fcmh_2_mdsio_fid(p),
+	mp->rc = mdsio_lookup(vfsid, fcmh_2_mdsio_fid(p),
 	    mq->name, NULL, &rootcreds, &mp->attr);
+	if (mp->rc)
+		goto out;
+	if (mq->pfg.fg_fid == SLFID_ROOT) {
+
+		int error;
+		uint64_t fid;
+		struct rootNames *p;
+		mount_info_t *mountinfo;
+		struct srt_stat tmpattr;
+
+		p = slm_rmc_search_roots(mq->name);
+		if (p) {
+			mountinfo = &zfsMount[p->rn_vfsid];
+			fid = SLFID_ROOT;
+			FID_SET_SITEID(fid, mountinfo->fsid);
+
+			error = mdsio_getattr(p->rn_vfsid, mountinfo->rootid, 
+				mountinfo->rootinfo, &rootcreds, &tmpattr); 
+			if (!error) {
+				tmpattr.sst_fg.fg_fid = fid;
+				mp->attr = tmpattr;
+			} else
+				/* better than nothing */
+				mp->attr.sst_fg.fg_fid = fid;
+		}
+	}
 
  out:
 	if (p)
 		fcmh_op_done_type(p, FCMH_OPCNT_LOOKUP_FIDC);
 	return (0);
 }
 
 int
-slm_mkdir(struct srm_mkdir_req *mq, struct srm_mkdir_rep *mp,
+slm_mkdir(int vfsid, struct srm_mkdir_req *mq, struct srm_mkdir_rep *mp,
     int opflags, struct fidc_membh **dp)
 {
 	struct fidc_membh *p = NULL, *c = NULL;
 
 	mq->name[sizeof(mq->name) - 1] = '\0';
 
 	mp->rc = slm_fcmh_get(&mq->pfg, &p);
 	if (mp->rc)
 		goto out;
 
+#if 0
 	if (IS_REMOTE_FID(mq->pfg.fg_fid)) {
 		struct slash_creds cr;
 
 		cr.scr_uid = mq->sstb.sst_uid;
 		cr.scr_gid = mq->sstb.sst_gid;
 		/* XXX pass opflags */
 		mp->rc = slm_rmm_forward_namespace(SLM_FORWARD_MKDIR,
 		    &mq->pfg, NULL, mq->name, NULL, mq->sstb.sst_mode,
 		    &cr, &mp->cattr, 0);
 		goto out;
 	}
+#endif
 
 	mds_reserve_slot(1);
-	mp->rc = -mdsio_mkdir(fcmh_2_mdsio_fid(p), mq->name, &mq->sstb,
+	mp->rc = -mdsio_mkdir(vfsid, fcmh_2_mdsio_fid(p), mq->name, &mq->sstb,
 	    0, opflags, &mp->cattr, NULL, mdslog_namespace,
 	    slm_get_next_slashfid, 0);
 	mds_unreserve_slot(1);
 
  out:
 	if (p)
 		mdsio_fcmh_refreshattr(p, &mp->pattr);
 
 	/*
 	 * Set new subdir's new files' default replication policy from
 	 * parent dir.
 	 */
 	if (mp->rc == 0 && slm_fcmh_get(&mp->cattr.sst_fg, &c) == 0)
-		slm_fcmh_endow_nolog(p, c);
+		slm_fcmh_endow_nolog(vfsid, p, c);
 
 	if (dp) {
 		if (mp->rc == -EEXIST &&
-		    mdsio_lookup(fcmh_2_mdsio_fid(p), mq->name, NULL,
+		    mdsio_lookup(vfsid, fcmh_2_mdsio_fid(p), mq->name, NULL,
 		    &rootcreds, &mp->cattr) == 0)
 			slm_fcmh_get(&mp->cattr.sst_fg, &c);
 		*dp = c;
 		c = NULL;
 	}
 	if (p)
 		fcmh_op_done_type(p, FCMH_OPCNT_LOOKUP_FIDC);
 	if (c)
 		fcmh_op_done_type(c, FCMH_OPCNT_LOOKUP_FIDC);
 	return (0);
 }
 
 int
 slm_rmc_handle_mkdir(struct pscrpc_request *rq)
 {
 	struct srm_mkdir_req *mq;
 	struct srm_mkdir_rep *mp;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
-	return (slm_mkdir(mq, mp, 0, NULL));
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		return (0);
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = -EACCES;
+		return (0);
+	}
+	return (slm_mkdir(vfsid, mq, mp, 0, NULL));
 }
 
 int
 slm_rmc_handle_mknod(struct pscrpc_request *rq)
 {
 	struct srm_mknod_req *mq;
 	struct srm_mknod_rep *mp;
 	struct fidc_membh *p;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+
 	mp->rc = slm_fcmh_get(&mq->pfg, &p);
 	if (mp->rc)
 		goto out;
 
 	mq->name[sizeof(mq->name) - 1] = '\0';
 	mds_reserve_slot(1);
-	mp->rc = mdsio_mknod(fcmh_2_mdsio_fid(p), mq->name, mq->mode,
+	mp->rc = mdsio_mknod(vfsid, fcmh_2_mdsio_fid(p), mq->name, mq->mode,
 	    &mq->creds, &mp->cattr, NULL, mdslog_namespace,
 	    slm_get_next_slashfid);
 	mds_unreserve_slot(1);
 
 	mdsio_fcmh_refreshattr(p, &mp->pattr);
  out:
 	if (p)
 		fcmh_op_done_type(p, FCMH_OPCNT_LOOKUP_FIDC);
 	return (0);
 }
@@ -464,80 +533,93 @@
  *	optimization, we bundle a write bmap lease in the reply.
  */
 int
 slm_rmc_handle_create(struct pscrpc_request *rq)
 {
 	struct fidc_membh *p = NULL, *c;
 	struct srm_create_rep *mp;
 	struct srm_create_req *mq;
 	struct bmapc_memb *bmap;
 	void *mdsio_data;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = -EINVAL;
+		goto out;
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EACCES;
+		goto out;
+	}
+
 	if (mq->flags & SRM_LEASEBMAPF_GETREPLTBL) {
 		mp->rc = -EINVAL;
 		goto out;
 	}
 
 	/* Lookup the parent directory in the cache so that the
 	 *   SLASH2 ino can be translated into the inode for the
 	 *   underlying fs.
 	 */
 	mp->rc = slm_fcmh_get(&mq->pfg, &p);
 	if (mp->rc)
 		goto out;
 
 	mq->name[sizeof(mq->name) - 1] = '\0';
 
+#if 0
 	if (IS_REMOTE_FID(mq->pfg.fg_fid)) {
 		mp->rc = slm_rmm_forward_namespace(SLM_FORWARD_CREATE,
 		    &mq->pfg, NULL, mq->name, NULL, mq->mode,
 		    &mq->creds, &mp->cattr, 0);
 		if (!mp->rc) {
 			mp->rc2 = ENOENT;
 			mdsio_fcmh_refreshattr(p, &mp->pattr);
 		}
 		goto out;
 	}
+#endif
 
 	DEBUG_FCMH(PLL_DEBUG, p, "create op start for %s", mq->name);
 
 	mds_reserve_slot(1);
-	mp->rc = mdsio_opencreate(fcmh_2_mdsio_fid(p), &mq->creds,
+	mp->rc = mdsio_opencreate(vfsid, fcmh_2_mdsio_fid(p), &mq->creds,
 	    O_CREAT | O_EXCL | O_RDWR, mq->mode, mq->name, NULL,
 	    &mp->cattr, &mdsio_data, mdslog_namespace,
 	    slm_get_next_slashfid, 0);
 	mds_unreserve_slot(1);
 
 	if (mp->rc)
 		goto out;
 
 	/* Refresh the cached attributes of our parent and pack them
 	 *   in the reply.
 	 */
 	mdsio_fcmh_refreshattr(p, &mp->pattr);
 
 	DEBUG_FCMH(PLL_DEBUG, p, "create op done for %s", mq->name);
 	/* XXX enter this into the fcmh cache instead of doing it again
 	 *   This release may be the sanest thing actually, unless EXCL is
 	 *   used.
 	 */
-	mdsio_release(&rootcreds, mdsio_data);
+	mdsio_release(vfsid, &rootcreds, mdsio_data);
 
 	DEBUG_FCMH(PLL_DEBUG, p, "mdsio_release() done for %s",
 	    mq->name);
 
 	mp->rc = slm_fcmh_get(&mp->cattr.sst_fg, &c);
 	if (mp->rc)
 		goto out;
 
-	slm_fcmh_endow_nolog(p, c);
+	slm_fcmh_endow_nolog(vfsid, p, c);
 
 	/* obtain lease for first bmap as optimization */
 	mp->flags = mq->flags;
 
 	bmap = NULL;
 	mp->rc2 = mds_bmap_load_cli(c, 0, mp->flags, SL_WRITE,
 	    mq->prefios[0], &mp->sbd, rq->rq_export, &bmap);
 
 	fcmh_op_done_type(c, FCMH_OPCNT_LOOKUP_FIDC);
 
@@ -545,35 +627,78 @@
 		goto out;
 
 	slm_rmc_bmapdesc_setup(bmap, &mp->sbd, SL_WRITE);
 
  out:
 	if (p)
 		fcmh_op_done_type(p, FCMH_OPCNT_LOOKUP_FIDC);
 	return (0);
 }
 
+void
+slm_rmc_handle_readdir_roots(struct iovec *iov0, struct iovec *iov1, size_t nents)
+{
+	int error;
+	struct srt_stat tmpattr, *attr;
+	struct pscfs_dirent *dirent;
+	size_t i, entsize;
+	uint64_t fid;
+	struct rootNames *p;
+	mount_info_t *mountinfo;
+
+	attr = iov1->iov_base;
+	dirent = iov0->iov_base;
+	for (i = 0; i < nents; i++) {
+
+		p = slm_rmc_search_roots(dirent->pfd_name);
+		if (p) {
+			mountinfo = &zfsMount[p->rn_vfsid];
+			fid = SLFID_ROOT;
+			FID_SET_SITEID(fid, mountinfo->fsid);
+			dirent->pfd_ino = fid;
+
+			error = mdsio_getattr(p->rn_vfsid, mountinfo->rootid, 
+				mountinfo->rootinfo, &rootcreds, &tmpattr); 
+			if (!error) {
+				tmpattr.sst_fg.fg_fid = fid;
+				*attr = tmpattr;
+			} else
+				/* better than nothing */
+				attr->sst_fg.fg_fid = fid;
+		}
+		attr++;
+		entsize = PFL_DIRENT_SIZE(dirent->pfd_namelen);
+		dirent = PSC_AGP(dirent, entsize);
+
+	}
+}
+
 int
 slm_rmc_handle_readdir(struct pscrpc_request *rq)
 {
 	struct fidc_membh *fcmh = NULL;
 	struct srm_readdir_req *mq;
 	struct srm_readdir_rep *mp;
 	struct iovec iov[2];
 	size_t outsize, nents;
-	int niov;
+	int niov, vfsid;
 
 	iov[0].iov_base = NULL;
 	iov[1].iov_base = NULL;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
 
+	if (mdsio_fid_to_vfsid(mq->fg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+
 	mp->rc = slm_fcmh_get(&mq->fg, &fcmh);
 	if (mp->rc)
 		goto out;
 
 	if (mq->size > MAX_READDIR_BUFSIZ ||
 	    mq->nstbpref > MAX_READDIR_NENTS) {
 		mp->rc = -EINVAL;
 		goto out;
 	}
 
@@ -583,33 +708,39 @@
 	niov = 1;
 	if (mq->nstbpref) {
 		niov++;
 		iov[1].iov_len = mq->nstbpref * sizeof(struct srt_stat);
 		iov[1].iov_base = PSCALLOC(iov[1].iov_len);
 	} else {
 		iov[1].iov_len = 0;
 		iov[1].iov_base = NULL;
 	}
 
-	mp->rc = mdsio_readdir(&rootcreds, mq->size, mq->offset,
+	mp->rc = mdsio_readdir(vfsid, &rootcreds, mq->size, mq->offset,
 	    iov[0].iov_base, &outsize, &nents, iov[1].iov_base,
 	    mq->nstbpref, fcmh_2_mdsio_data(fcmh));
-	mp->size = outsize;
-	mp->num = nents;
 
 	psclog_info("mdsio_readdir: rc=%d, data=%p", mp->rc,
 	    fcmh_2_mdsio_data(fcmh));
+	mp->size = outsize;
+	mp->num = nents;
 
 	if (mp->rc)
 		goto out;
 
-#if 0
+	/*
+	 * If this is the root, we fake part of readdir contents by
+	 * return the file system names here.
+	 */
+	if (mq->fg.fg_fid == SLFID_ROOT) 
+		slm_rmc_handle_readdir_roots(&iov[0], &iov[1], nents);
+#if 1
 	{
 		/* debugging only */
 		unsigned int i;
 		struct srt_stat *attr;
 		attr = iov[1].iov_base;
 		for (i = 0; i < mq->nstbpref; i++, attr++) {
 			if (!attr->sst_fg.fg_fid)
 				break;
 			psclog_info("reply: f+g:"SLPRI_FG", mode=%#o",
 				SLPRI_FG_ARGS(&attr->sst_fg),
@@ -641,27 +772,34 @@
 }
 
 int
 slm_rmc_handle_readlink(struct pscrpc_request *rq)
 {
 	struct srm_readlink_req *mq;
 	struct srm_readlink_rep *mp;
 	struct fidc_membh *fcmh;
 	struct iovec iov;
 	char buf[SL_PATH_MAX];
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->fg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+
+	mp->rc = slm_fcmh_get(&mq->fg, &fcmh);
 	mp->rc = slm_fcmh_get(&mq->fg, &fcmh);
 	if (mp->rc)
 		goto out;
 
-	mp->rc = mdsio_readlink(fcmh_2_mdsio_fid(fcmh), buf,
+	mp->rc = mdsio_readlink(vfsid, fcmh_2_mdsio_fid(fcmh), buf,
 	    &rootcreds);
 	if (mp->rc)
 		goto out;
 
 	iov.iov_base = buf;
 	iov.iov_len = sizeof(buf);
 	mp->rc = rsx_bulkserver(rq, BULK_PUT_SOURCE, SRMC_BULK_PORTAL,
 	    &iov, 1);
 
  out:
@@ -679,24 +817,31 @@
 
 int
 slm_rmc_handle_rename(struct pscrpc_request *rq)
 {
 	char from[SL_NAME_MAX + 1], to[SL_NAME_MAX + 1];
 	struct fidc_membh *op = NULL, *np = NULL;
 	struct srm_rename_req *mq;
 	struct srm_rename_rep *mp;
 	struct slash_fidgen chfg;
 	struct iovec iov[2];
+	int vfsid;
 
 	chfg.fg_fid = FID_ANY;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->opfg.fg_fid, &vfsid) < 0) 
+		return (EINVAL);
+
+	if (current_vfsid != vfsid)
+		return (EINVAL);
+
 	if (mq->fromlen == 0 || mq->tolen == 0 ||
 	    mq->fromlen > SL_NAME_MAX || mq->tolen > SL_NAME_MAX)
 		return (EINVAL);
 
 	iov[0].iov_base = from;
 	iov[0].iov_len = mq->fromlen;
 	iov[1].iov_base = to;
 	iov[1].iov_len = mq->tolen;
 
 	mp->rc = rsx_bulkserver(rq, BULK_GET_SINK, SRMC_BULK_PORTAL,
@@ -718,30 +863,32 @@
 		if (mp->rc)
 			goto out;
 	}
 
 	if (FID_GET_SITEID(mq->opfg.fg_fid) !=
 	    FID_GET_SITEID(mq->npfg.fg_fid)) {
 		mp->rc = -EXDEV;
 		goto out;
 	}
 
+#if 0
 	if (IS_REMOTE_FID(mq->opfg.fg_fid)) {
 		mp->rc = slm_rmm_forward_namespace(SLM_FORWARD_RENAME,
 		    &mq->opfg, &mq->npfg, from, to, 0, &rootcreds,
 		    &mp->srr_npattr, 0);
 		goto out;
 	}
+#endif
 
 	/* if we get here, op and np must be owned by the current MDS */
 	mds_reserve_slot(2);
-	mp->rc = mdsio_rename(fcmh_2_mdsio_fid(op), from,
+	mp->rc = mdsio_rename(vfsid, fcmh_2_mdsio_fid(op), from,
 	    fcmh_2_mdsio_fid(np), to, &rootcreds, mdslog_namespace,
 	    &chfg);
 	mds_unreserve_slot(2);
 
  out:
 	if (mp->rc == 0) {
 		mdsio_fcmh_refreshattr(op, &mp->srr_opattr);
 		if (op != np)
 			mdsio_fcmh_refreshattr(np, &mp->srr_npattr);
 
@@ -765,38 +912,49 @@
 }
 
 int
 slm_rmc_handle_setattr(struct pscrpc_request *rq)
 {
 	int to_set, flush, tadj = 0, unbump = 0;
 	struct slashrpc_cservice *csvc;
 	struct fidc_membh *fcmh = NULL;
 	struct srm_setattr_req *mq;
 	struct srm_setattr_rep *mp;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->attr.sst_fg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EACCES;
+		goto out;
+	}
 
 	mp->rc = slm_fcmh_get(&mq->attr.sst_fg, &fcmh);
 	if (mp->rc)
 		goto out;
 
 	FCMH_LOCK(fcmh);
 	fcmh_wait_locked(fcmh, fcmh->fcmh_flags & FCMH_IN_SETATTR);
 
 	flush = mq->to_set & PSCFS_SETATTRF_FLUSH;
 	to_set = mq->to_set & SL_SETATTRF_CLI_ALL;
 
 	if (to_set & PSCFS_SETATTRF_DATASIZE) {
+#if 0
 		if (IS_REMOTE_FID(mq->attr.sst_fg.fg_fid)) {
 			mp->rc = -ENOSYS;
 			goto out;
 		}
+#endif
 		/* our client should really do this on its own */
 		if (!(to_set & PSCFS_SETATTRF_MTIME)) {
 			psclog_warn("setattr: missing MTIME flag in RPC request");
 			to_set |= PSCFS_SETATTRF_MTIME;
 			SL_GETTIMESPEC(&mq->attr.sst_mtim);
 		}
 		if (mq->attr.sst_size == 0) {
 			/*
 			 * Full truncate.  If file size is already zero,
 			 * we must still bump the generation since size
@@ -814,34 +972,38 @@
 			if (fcmh->fcmh_flags & FCMH_IN_PTRUNC) {
 				mp->rc = -SLERR_BMAP_IN_PTRUNC;
 				goto out;
 			}
 			to_set &= ~PSCFS_SETATTRF_DATASIZE;
 			tadj |= PSCFS_SETATTRF_DATASIZE;
 		}
 	}
 
 	if (to_set) {
+#if 0
 		if (IS_REMOTE_FID(mq->attr.sst_fg.fg_fid)) {
 			mp->rc = slm_rmm_forward_namespace(
 			    SLM_FORWARD_SETATTR, &mq->attr.sst_fg, NULL,
 			    NULL, NULL, 0, NULL, &mq->attr, to_set);
 			mp->attr = mq->attr;
 		} else {
+#endif
 			/*
 			 * If the file is open, mdsio_data will be valid
 			 * and used.  Otherwise, it will be NULL, and
 			 * we'll use the mdsio_fid.
 			 */
-			mp->rc = mds_fcmh_setattr(fcmh, to_set,
+			mp->rc = mds_fcmh_setattr(vfsid, fcmh, to_set,
 			    &mq->attr);
+#if 0
 		}
+#endif
 	}
 
 	if (mp->rc) {
 		if (unbump)
 			fcmh_2_gen(fcmh)--;
 	} else if (!flush) {
 		if (tadj & PSCFS_SETATTRF_DATASIZE) {
 			fcmh->fcmh_flags |= FCMH_IN_PTRUNC;
 
 			csvc = slm_getclcsvc(rq->rq_export);
@@ -863,35 +1025,44 @@
 	}
 	return (0);
 }
 
 int
 slm_rmc_handle_set_newreplpol(struct pscrpc_request *rq)
 {
 	struct srm_set_newreplpol_req *mq;
 	struct srm_set_newreplpol_rep *mp;
 	struct fidc_membh *fcmh;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
 
 	if (mq->pol < 0 || mq->pol >= NBRPOL) {
 		mp->rc = -EINVAL;
 		return (0);
 	}
+	if (mdsio_fid_to_vfsid(mq->fg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EINVAL;
+		goto out;
+	}
 
 	mp->rc = slm_fcmh_get(&mq->fg, &fcmh);
 	if (mp->rc)
 		goto out;
 
 	FCMH_LOCK(fcmh);
 	fcmh_2_replpol(fcmh) = mq->pol;
-	mp->rc = mds_inode_write(fcmh_2_inoh(fcmh), mdslog_ino_repls,
+	mp->rc = mds_inode_write(vfsid, fcmh_2_inoh(fcmh), mdslog_ino_repls,
 	    fcmh);
 
  out:
 	if (fcmh)
 		fcmh_op_done_type(fcmh, FCMH_OPCNT_LOOKUP_FIDC);
 
 	return (0);
 }
 
 int
@@ -932,25 +1103,29 @@
 }
 
 int
 slm_rmc_handle_statfs(struct pscrpc_request *rq)
 {
 	struct sl_resource *r, *ri;
 	struct srm_statfs_req *mq;
 	struct srm_statfs_rep *mp;
 	struct sl_mds_iosinfo *si;
 	struct statvfs sfb;
-	int j = 0, single = 0;
+	int j = 0, single = 0, vfsid;
 	double adj;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
-	mp->rc = mdsio_statfs(&sfb);
+	if (mdsio_fid_to_vfsid(mq->fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		return (0);
+	}
+	mp->rc = mdsio_statfs(vfsid, &sfb);
 	sl_externalize_statfs(&sfb, &mp->ssfb);
 	r = libsl_id2res(mq->iosid);
 	if (r == NULL) {
 		mp->rc = -SLERR_RES_UNKNOWN;
 		return (0);
 	}
 	mp->ssfb.sf_bsize = 0;
 	mp->ssfb.sf_blocks = 0;
 	mp->ssfb.sf_bfree = 0;
 	mp->ssfb.sf_bavail = 0;
@@ -978,20 +1153,26 @@
 }
 
 int
 slm_symlink(struct pscrpc_request *rq, struct srm_symlink_req *mq,
     struct srm_symlink_rep *mp, int ptl)
 {
 	char linkname[SL_PATH_MAX];
 	struct fidc_membh *p = NULL;
 	struct slash_creds cr;
 	struct iovec iov;
+	int vfsid;
+
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0)
+		return (-EINVAL);
+	if (vfsid != current_vfsid)
+		return (-EACCES);
 
 	mq->name[sizeof(mq->name) - 1] = '\0';
 	if (mq->linklen == 0 || mq->linklen >= SL_PATH_MAX)
 		return (EINVAL);
 
 	iov.iov_base = linkname;
 	iov.iov_len = mq->linklen;
 	mp->rc = rsx_bulkserver(rq, BULK_GET_SINK, ptl, &iov, 1);
 	if (mp->rc)
 		return (mp->rc);
@@ -999,21 +1180,21 @@
 	mp->rc = slm_fcmh_get(&mq->pfg, &p);
 	if (mp->rc)
 		goto out;
 
 	linkname[mq->linklen] = '\0';
 
 	cr.scr_uid = mq->sstb.sst_uid;
 	cr.scr_gid = mq->sstb.sst_gid;
 
 	mds_reserve_slot(1);
-	mp->rc = mdsio_symlink(linkname, fcmh_2_mdsio_fid(p), mq->name,
+	mp->rc = mdsio_symlink(vfsid, linkname, fcmh_2_mdsio_fid(p), mq->name,
 	    &cr, &mp->cattr, NULL, slm_get_next_slashfid,
 	    mdslog_namespace);
 	mds_unreserve_slot(1);
 
 	mdsio_fcmh_refreshattr(p, &mp->pattr);
 
  out:
 	if (p)
 		fcmh_op_done_type(p, FCMH_OPCNT_LOOKUP_FIDC);
 	return (0);
@@ -1029,45 +1210,56 @@
 	return (slm_symlink(rq, mq, mp, SRMC_BULK_PORTAL));
 }
 
 int
 slm_rmc_handle_unlink(struct pscrpc_request *rq, int isfile)
 {
 	struct slash_fidgen fg, chfg;
 	struct fidc_membh *p = NULL;
 	struct srm_unlink_req *mq;
 	struct srm_unlink_rep *mp;
+	int vfsid;
 
 	chfg.fg_fid = FID_ANY;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->pfid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EACCES; 
+		goto out;
+	}
 
 	fg.fg_fid = mq->pfid;
 	fg.fg_gen = FGEN_ANY;
 	mq->name[sizeof(mq->name) - 1] = '\0';
 	mp->rc = slm_fcmh_get(&fg, &p);
 	if (mp->rc)
 		goto out;
 
+#if 0
 	if (IS_REMOTE_FID(mq->pfid)) {
 		mp->rc = slm_rmm_forward_namespace(isfile ?
 		    SLM_FORWARD_UNLINK : SLM_FORWARD_RMDIR, &fg, NULL,
 		    mq->name, NULL, 0, NULL, NULL, 0);
 		goto out;
 	}
+#endif
 
 	mds_reserve_slot(1);
 	if (isfile)
-		mp->rc = mdsio_unlink(fcmh_2_mdsio_fid(p), NULL,
+		mp->rc = mdsio_unlink(vfsid, fcmh_2_mdsio_fid(p), NULL,
 		    mq->name, &rootcreds, mdslog_namespace, &chfg);
 	else
-		mp->rc = mdsio_rmdir(fcmh_2_mdsio_fid(p), NULL,
+		mp->rc = mdsio_rmdir(vfsid, fcmh_2_mdsio_fid(p), NULL,
 		    mq->name, &rootcreds, mdslog_namespace);
 	mds_unreserve_slot(1);
 
  out:
 	if (mp->rc == 0)
 		mdsio_fcmh_refreshattr(p, &mp->pattr);
 	if (p)
 		fcmh_op_done_type(p, FCMH_OPCNT_LOOKUP_FIDC);
 
 	if (chfg.fg_fid != FID_ANY) {
Index: slash_nara/slashd/mdslog.c
===================================================================
--- slash_nara/slashd/mdslog.c	(revision 19015)
+++ slash_nara/slashd/mdslog.c	(working copy)
@@ -169,37 +169,37 @@
 struct psc_journal_cursor	 mds_cursor;
 
 psc_spinlock_t			 mds_txg_lock = SPINLOCK_INIT;
 
 static int
 mds_open_file(char *fn, int flags, void **handle)
 {
 	mdsio_fid_t mf;
 	int rc;
 
-	rc = mdsio_lookup(mds_metadir_inum, fn, &mf, &rootcreds, NULL);
+	rc = mdsio_lookup(current_vfsid, mds_metadir_inum[current_vfsid], fn, &mf, &rootcreds, NULL);
 	if (rc == ENOENT && (flags & O_CREAT)) {
-		rc = mdsio_opencreatef(mds_metadir_inum, &rootcreds,
+		rc = mdsio_opencreatef(current_vfsid, mds_metadir_inum[current_vfsid], &rootcreds,
 		    flags, MDSIO_OPENCRF_NOLINK, 0600, fn, NULL, NULL,
 		    handle, NULL, NULL, 0);
 	} else if (!rc) {
-		rc = mdsio_opencreate(mf, &rootcreds, flags, 0, NULL,
+		rc = mdsio_opencreate(current_vfsid, mf, &rootcreds, flags, 0, NULL,
 		    NULL, NULL, handle, NULL, NULL, 0);
 	}
 	return (rc);
 }
 
 #define mds_read_file(h, buf, size, nb, off)				\
-	mdsio_read(&rootcreds, (buf), (size), (nb), (off), (h))
+	mdsio_read(current_vfsid, &rootcreds, (buf), (size), (nb), (off), (h))
 
 #define mds_write_file(h, buf, size, nb, off)				\
-	mdsio_write(&rootcreds, (buf), (size), (nb), (off), 0, (h), NULL, NULL)
+	mdsio_write(current_vfsid, &rootcreds, (buf), (size), (nb), (off), 0, (h), NULL, NULL)
 
 static void
 mds_record_update_prog(void)
 {
 	struct sl_mds_peerinfo *peerinfo;
 	struct sl_resm *resm;
 	size_t size;
 	int i, rc;
 
 	i = 0;
@@ -253,22 +253,22 @@
 void
 mds_remove_logfile(uint64_t batchno, int update)
 {
 	int rc;
 	char logfn[PATH_MAX];
 
 	if (update)
 		xmkfn(logfn, "%s.%d", SL_FN_UPDATELOG, batchno);
 	else
 		xmkfn(logfn, "%s.%d", SL_FN_RECLAIMLOG, batchno);
-	rc = mdsio_unlink(mds_metadir_inum, NULL, logfn, &rootcreds, NULL,
-	    NULL);
+	rc = mdsio_unlink(current_vfsid, mds_metadir_inum[current_vfsid], NULL, 
+		logfn, &rootcreds, NULL, NULL);
 	psclog_warnx("Removing log file %s, rc = %d\n", logfn, rc);
 }
 
 int
 mds_open_logfile(uint64_t batchno, int update, int readonly,
     void **handle)
 {
 	char log_fn[PATH_MAX];
 	int rc;
 
@@ -368,21 +368,21 @@
 	    sjnm->sjnm_op == NS_OP_RECLAIM ||
 	    sjnm->sjnm_op == NS_OP_SETATTR ||
 	    sjnm->sjnm_op == NS_OP_UNLINK ||
 	    sjnm->sjnm_op == NS_OP_SETSIZE);
 
 	if (reclaim_logfile_handle == NULL) {
 
 		rc = mds_open_logfile(current_reclaim_batchno, 0, 0, &reclaim_logfile_handle);
 		psc_assert(rc == 0);
 
-		rc = mdsio_getattr(0, reclaim_logfile_handle, &rootcreds, &sstb);
+		rc = mdsio_getattr(current_vfsid, 0, reclaim_logfile_handle, &rootcreds, &sstb);
 		psc_assert(rc == 0);
 
 		reclaim_logfile_offset = 0;
 		/*
 		 * Even if there is no need to replay after a startup,
 		 * we should still skip existing entries.
 		 */
 		if (sstb.sst_size) {
 			reclaimbuf = PSCALLOC(sstb.sst_size);
 			rc = mds_read_file(reclaim_logfile_handle, reclaimbuf, sstb.sst_size, &size, 0);
@@ -455,21 +455,21 @@
 		    current_reclaim_batchno);
 
 	spinlock(&mds_distill_lock);
 	current_reclaim_xid = pje->pje_xid;
 	freelock(&mds_distill_lock);
 
 	reclaim_logfile_offset += current_reclaim_entrysize;
 	if (reclaim_logfile_offset ==
 	    SLM_RECLAIM_BATCH * (off_t)current_reclaim_entrysize) {
 
-		mdsio_release(&rootcreds, reclaim_logfile_handle);
+		mdsio_release(current_vfsid, &rootcreds, reclaim_logfile_handle);
 
 		reclaim_logfile_handle = NULL;
 		current_reclaim_batchno++;
 
 		spinlock(&mds_distill_lock);
 		sync_reclaim_xid = pje->pje_xid;
 		freelock(&mds_distill_lock);
 
 		spinlock(&mds_reclaim_waitqlock);
 		psc_waitq_wakeall(&mds_reclaim_waitq);
@@ -565,21 +565,21 @@
 	    update_logfile_offset);
 	if (size != sizeof(struct srt_update_entry))
 		psc_fatal("Failed to write update log file, batchno=%"PRId64,
 		    current_update_batchno);
 
 	/* see if we need to close the current update log file */
 	update_logfile_offset += sizeof(struct srt_update_entry);
 	if (update_logfile_offset ==
 	    SLM_UPDATE_BATCH * sizeof(struct srt_update_entry)) {
 
-		mdsio_release(&rootcreds, update_logfile_handle);
+		mdsio_release(current_vfsid, &rootcreds, update_logfile_handle);
 
 		update_logfile_handle = NULL;
 		current_update_batchno++;
 
 		spinlock(&mds_distill_lock);
 		sync_update_xid = pje->pje_xid;
 		freelock(&mds_distill_lock);
 
 		spinlock(&mds_update_waitqlock);
 		psc_waitq_wakeall(&mds_update_waitq);
@@ -863,21 +863,21 @@
 		 * the next log file after closing the old one.
 		 */
 		if (rc != ENOENT)
 			psc_fatalx("failed to open update log file, "
 			    "batchno=%"PRId64": %s",
 			    batchno, slstrerror(rc));
 		return (didwork);
 	}
 	rc = mds_read_file(handle, updatebuf,
 	    SLM_UPDATE_BATCH * sizeof(struct srt_update_entry), &size, 0);
-	mdsio_release(&rootcreds, handle);
+	mdsio_release(current_vfsid, &rootcreds, handle);
 
 	if (size == 0)
 		return (didwork);
 
 	psc_assert((size % sizeof(struct srt_update_entry)) == 0);
 	count = (int)size / (int)sizeof(struct srt_update_entry);
 
 	/* find the xid associated with the last log entry */
 	entryp = PSC_AGP(updatebuf, (count - 1) *
 	    sizeof(struct srt_update_entry));
@@ -1073,21 +1073,21 @@
  *	status.  If there is no activity in system other that this write
  *	to update the cursor, our customized ZFS will extend the
  *	lifetime of the transaction group.
  */
 void
 mds_cursor_thread(__unusedx struct psc_thread *thr)
 {
 	int rc;
 
 	while (pscthr_run()) {
-		rc = mdsio_write_cursor(&mds_cursor, sizeof(mds_cursor),
+		rc = mdsio_write_cursor(current_vfsid, &mds_cursor, sizeof(mds_cursor),
 			mds_cursor_handle, mds_update_cursor);
 		if (rc)
 			psclog_warnx("failed to update cursor, rc=%d", rc);
 		else
 			psclog_notice("cursor updated: txg=%"PRId64", xid=%"PRId64
 			    ", fid="SLPRI_FID", seqno=(%"PRIx64", %"PRIx64")",
 			    mds_cursor.pjc_commit_txg,
 			    mds_cursor.pjc_distill_xid,
 			    mds_cursor.pjc_fid,
 			    mds_cursor.pjc_seqno_lwm,
@@ -1096,42 +1096,55 @@
 }
 
 void
 mds_open_cursor(void)
 {
 	char *p, tmbuf[26];
 	mdsio_fid_t mf;
 	size_t nb;
 	int rc;
 
-	rc = mdsio_lookup(mds_metadir_inum, SL_FN_CURSOR, &mf,
+	rc = mdsio_lookup(current_vfsid, mds_metadir_inum[current_vfsid], SL_FN_CURSOR, &mf,
 	    &rootcreds, NULL);
 	psc_assert(rc == 0);
 
-	rc = mdsio_opencreate(mf, &rootcreds, O_RDWR, 0, NULL, NULL,
+	rc = mdsio_opencreate(current_vfsid, mf, &rootcreds, O_RDWR, 0, NULL, NULL,
 	    NULL, &mds_cursor_handle, NULL, NULL, 0);
 	psc_assert(!rc && mds_cursor_handle);
 
-	rc = mdsio_read(&rootcreds, &mds_cursor,
+	rc = mdsio_read(current_vfsid, &rootcreds, &mds_cursor,
 	    sizeof(struct psc_journal_cursor), &nb, 0, mds_cursor_handle);
 	psc_assert(rc == 0 && nb == sizeof(struct psc_journal_cursor));
 
 	psc_assert(mds_cursor.pjc_magic == PJRNL_CURSOR_MAGIC);
 	psc_assert(mds_cursor.pjc_version == PJRNL_CURSOR_VERSION);
 	psc_assert(mds_cursor.pjc_fid >= SLFID_MIN);
 
+#if 0
 	if (FID_GET_SITEID(mds_cursor.pjc_fid) == 0)
 		mds_cursor.pjc_fid |= (uint64_t)nodeSite->site_id <<
 		    SLASH_FID_SITE_SHFT;
 	if (FID_GET_SITEID(mds_cursor.pjc_fid) != nodeSite->site_id)
 		psc_fatal("Mismatched site ID in the FID, expected %d",
 		    nodeSite->site_id);
+#endif
+	/* old utility does not set fsid, so we fill it here */
+	if (FID_GET_SITEID(mds_cursor.pjc_fid) == 0)
+		FID_SET_SITEID(mds_cursor.pjc_fid, nodeSite->site_id);
+
+#if 0
+	/* backward compatibility */
+	if (mount_index == 1) {
+		psc_assert(current_vfsid == 0);
+		zfsMount[current_vfsid].fsid = FID_GET_SITEID(mds_cursor.pjc_fid);
+	}
+#endif
 
 	slm_set_curr_slashfid(mds_cursor.pjc_fid);
 	psclog_notice("File system was formatted on %"PRIu64" seconds "
 	    "since the Epoch", mds_cursor.pjc_timestamp);
 	psclog_notice("SLFID prior to replay="SLPRI_FID, mds_cursor.pjc_fid);
 	ctime_r((time_t *)&mds_cursor.pjc_timestamp, tmbuf);
 	p = strchr(tmbuf, '\n');
 	if (p)
 		*p = '\0';
 	psclog_notice("File system was formatted on %s", tmbuf);
@@ -1200,32 +1213,32 @@
 		/*
 		 * It is fine that the distill process hasn't written
 		 * the next log file after closing the old one.
 		 */
 		if (rc != ENOENT)
 			psc_fatalx("Failed to open reclaim log file, "
 			    "batchno=%"PRId64": %s",
 			    batchno, slstrerror(rc));
 		return (didwork);
 	}
-	rc = mdsio_getattr(0, handle, &rootcreds, &sstb);
+	rc = mdsio_getattr(current_vfsid, 0, handle, &rootcreds, &sstb);
 	psc_assert(rc == 0);
 
 	if (sstb.sst_size == 0) {
-		mdsio_release(&rootcreds, handle);
+		mdsio_release(current_vfsid, &rootcreds, handle);
 		return (didwork);
 	}
 	reclaimbuf = PSCALLOC(sstb.sst_size);
 
 	rc = mds_read_file(handle, reclaimbuf, sstb.sst_size, &size, 0);
 	psc_assert(rc == 0 && sstb.sst_size == size);
-	mdsio_release(&rootcreds, handle);
+	mdsio_release(current_vfsid, &rootcreds, handle);
 
 	version = 0;
 	entrysize = RECLAIM_ENTRY_SIZE;
 	entryp = (struct srt_reclaim_entry *) reclaimbuf;
 	if (entryp->fg.fg_fid == RECLAIM_MAGIC_FID &&
 	    entryp->fg.fg_gen == RECLAIM_MAGIC_GEN) {
 		version = RECLAIM_MAGIC_VER;
 		entrysize = sizeof(struct srt_reclaim_entry);
 	}
 
@@ -1738,28 +1751,28 @@
 	while (batchno < UINT64_MAX) {
 		rc = mds_open_logfile(batchno, 0, 1, &handle);
 		if (rc) {
 			psc_assert(rc == ENOENT);
 			if (batchno > lwm) {
 				batchno--;
 				rc = mds_open_logfile(batchno, 0, 1, &handle);
 			}
 			break;
 		}
-		mdsio_release(&rootcreds, handle);
+		mdsio_release(current_vfsid, &rootcreds, handle);
 		batchno++;
 	}
 	if (rc)
 		psc_fatalx("failed to open reclaim log file, "
 		    "batchno=%"PRId64": %s", batchno, slstrerror(rc));
 
-	rc = mdsio_getattr(0, handle, &rootcreds, &sstb);
+	rc = mdsio_getattr(current_vfsid, 0, handle, &rootcreds, &sstb);
 	psc_assert(rc == 0);
 
 	current_reclaim_batchno = batchno;
 
 	entrysize = RECLAIM_ENTRY_SIZE;
 	if (sstb.sst_size) {
 		reclaimbuf = PSCALLOC(sstb.sst_size);
 
 		rc = mds_read_file(handle, reclaimbuf, sstb.sst_size, &size, 0);
 		psc_assert(rc == 0 && size == sstb.sst_size);
@@ -1788,21 +1801,21 @@
 		}
 		if (total == SLM_RECLAIM_BATCH)
 			current_reclaim_batchno++;
 		PSCFREE(reclaimbuf);
 	}
 	current_reclaim_entrysize = entrysize;
 	current_reclaim_xid = last_reclaim_xid;
 
 	last_distill_xid = last_reclaim_xid;
 
-	mdsio_release(&rootcreds, handle);
+	mdsio_release(current_vfsid, &rootcreds, handle);
 
 	/* search for newly-added I/O servers */
 	SITE_FOREACH_RES(nodeSite, res, ri) {
 		if (!RES_ISFS(res))
 			continue;
 		rpmi = res2rpmi(res);
 		iosinfo = rpmi->rpmi_info;
 
 		if (!(iosinfo->si_flags & SIF_NEED_JRNL_INIT))
 			continue;
@@ -1865,21 +1878,21 @@
 	if (rc)
 		psc_fatalx("Failed to open update log file, "
 		    "batchno=%"PRId64": %s", batchno, slstrerror(rc));
 
 	current_update_batchno = batchno;
 	updatebuf = PSCALLOC(SLM_UPDATE_BATCH *
 	    sizeof(struct srt_update_entry));
 
 	rc = mds_read_file(handle, updatebuf,
 	    SLM_UPDATE_BATCH * sizeof(struct srt_update_entry), &size, 0);
-	mdsio_release(&rootcreds, handle);
+	mdsio_release(current_vfsid, &rootcreds, handle);
 
 	psc_assert(rc == 0);
 	psc_assert((size % sizeof(struct srt_update_entry)) == 0);
 
 	total = size / sizeof(struct srt_update_entry);
 	count = 0;
 	update_entryp = updatebuf;
 	while (count < total) {
 		last_update_xid = update_entryp->xid;
 		update_entryp++;
Index: slash_nara/slashd/rmi.c
===================================================================
--- slash_nara/slashd/rmi.c	(revision 19015)
+++ slash_nara/slashd/rmi.c	(working copy)
@@ -39,20 +39,24 @@
 #include "fidc_mds.h"
 #include "mdsio.h"
 #include "repl_mds.h"
 #include "rpc_mds.h"
 #include "slashd.h"
 #include "slashrpc.h"
 #include "slconn.h"
 #include "slerr.h"
 #include "up_sched_res.h"
 
+#include "zfs-fuse/zfs_slashlib.h"
+
+extern int current_vfsid;
+
 /**
  * slm_rmi_handle_bmap_getcrcs - Handle a BMAPGETCRCS request from ION,
  *	so the ION can load the CRCs for a bmap and verify them against
  *	the data he has for the region of data that bmap represents.
  * @rq: request.
  */
 int
 slm_rmi_handle_bmap_getcrcs(struct pscrpc_request *rq)
 {
 	struct srm_getbmap_full_req *mq;
@@ -207,21 +211,21 @@
 
 	/* XXX should we trust them to tell us who the src was? */
 	src_res = libsl_id2res(mq->src_resid);
 	if (src_res == NULL)
 		PFL_GOTOERR(out, mp->rc = -SLERR_ION_UNKNOWN);
 	src_resm = psc_dynarray_getpos(&src_res->res_members, 0);
 	dst_resm = libsl_try_nid2resm(rq->rq_export->exp_connection->c_peer.nid);
 	if (dst_resm == NULL)
 		PFL_GOTOERR(out, mp->rc = -SLERR_ION_UNKNOWN);
 
-	iosidx = mds_repl_ios_lookup(USWI_INOH(wk),
+	iosidx = mds_repl_ios_lookup(current_vfsid, USWI_INOH(wk),
 	    dst_resm->resm_res->res_id);
 	if (iosidx < 0) {
 		DEBUG_USWI(PLL_ERROR, wk,
 		    "res %s not found found in file",
 		    dst_resm->resm_name);
 		goto out;
 	}
 
 	if (bmap_getf(wk->uswi_fcmh, mq->bmapno, SL_WRITE,
 	    BMAPGETF_LOAD | BMAPGETF_NOAUTOINST, &bcm)) {
@@ -238,21 +242,21 @@
 	if (mq->rc == 0 && mq->bgen != gen)
 		mq->rc = SLERR_GEN_OLD;
 	if (mq->rc) {
 		DEBUG_USWI(PLL_WARN, wk, "rc=%d", mq->rc);
 
 		if (mq->rc == SLERR_BADCRC) {
 			/*
 			 * Bad CRC, media error perhaps.
 			 * Check if other replicas exist.
 			 */
-			src_iosidx = mds_repl_ios_lookup(USWI_INOH(wk),
+			src_iosidx = mds_repl_ios_lookup(current_vfsid, USWI_INOH(wk),
 			    src_res->res_id);
 			if (src_iosidx < 0)
 				goto out;
 
 			brepls_init(retifset, 0);
 			retifset[BREPLST_VALID] = 1;
 
 			if (mds_repl_bmap_walk(bcm, NULL, retifset,
 			    REPL_WALKF_MODOTH, &src_iosidx, 1)) {
 				/*
@@ -336,21 +340,21 @@
 	f = fidc_lookup_fg(&mq->fg);
 	if (f == NULL) {
 		mp->rc = ENOENT;
 		return (0);
 	}
 
 	mp->rc = mds_bmap_load(f, mq->bmapno, &b);
 	if (mp->rc)
 		return (0);
 
-	iosidx = mds_repl_ios_lookup(fcmh_2_inoh(b->bcm_fcmh),
+	iosidx = mds_repl_ios_lookup(current_vfsid, fcmh_2_inoh(b->bcm_fcmh),
 	    libsl_nid2resm(rq->rq_export->exp_connection->
 	    c_peer.nid)->resm_res_id);
 
 	brepls_init(tract, -1);
 	tract[BREPLST_GARBAGE_SCHED] = BREPLST_INVALID;
 	mds_repl_bmap_walk(b, tract, NULL, 0, &iosidx, 1);
 	mds_bmap_write_repls_rel(b);
 
 //	brepls_init(retifset, 1);
 	tract[BREPLST_GARBAGE] = BREPLST_INVALID;
@@ -393,58 +397,67 @@
 	struct srm_import_rep *mp;
 	struct slash_creds cr;
 	struct bmapc_memb *b;
 	struct srt_stat sstb;
 	struct sl_resm *m;
 	int fl, rc, rc2, idx;
 	void *mdsio_data;
 	sl_bmapno_t bno;
 	int64_t fsiz;
 	uint32_t i;
+	int vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		goto out;
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EINVAL;
+		goto out;
+	}
 
 	m = libsl_try_nid2resm(rq->rq_export->exp_connection->c_peer.nid);
 	if (m == NULL)
 		PFL_GOTOERR(out, mp->rc = -SLERR_IOS_UNKNOWN);
 
 	/*
 	 * Lookup the parent directory in the cache so that the SLASH2
 	 * inode can be translated into the inode for the underlying fs.
 	 */
 	mp->rc = slm_fcmh_get(&mq->pfg, &p);
 	if (mp->rc)
 		PFL_GOTOERR(out, mp->rc);
 
 	mq->cpn[sizeof(mq->cpn) - 1] = '\0';
 
 	mds_reserve_slot(1);
-	rc = mdsio_opencreatef(fcmh_2_mdsio_fid(p), &rootcreds,
+	rc = mdsio_opencreatef(current_vfsid, fcmh_2_mdsio_fid(p), &rootcreds,
 	    O_CREAT | O_EXCL | O_RDWR, MDSIO_OPENCRF_NOMTIM,
 	    mq->sstb.sst_mode, mq->cpn, NULL, &sstb, &mdsio_data,
 	    mdslog_namespace, slm_get_next_slashfid, 0);
 	mds_unreserve_slot(1);
 	mp->rc = -rc;
 
 	if (rc && rc != EEXIST)
 		PFL_GOTOERR(out, mp->rc);
 
 	if (rc == EEXIST) {
-		rc2 = mdsio_lookup(fcmh_2_mdsio_fid(p), mq->cpn,
+		rc2 = mdsio_lookup(current_vfsid, fcmh_2_mdsio_fid(p), mq->cpn,
 		    NULL, &rootcreds, &sstb);
 		if (rc2)
 			PFL_GOTOERR(out, mp->rc = -rc2);
 
 		if (IS_REMOTE_FID(sstb.sst_fid))
 			PFL_GOTOERR(out, mp->rc = -ENOTSUP);
 	} else
-		mdsio_release(&cr, mdsio_data);
+		mdsio_release(current_vfsid, &cr, mdsio_data);
 
 	mp->fg = sstb.sst_fg;
 	if (S_ISDIR(sstb.sst_mode))
 		PFL_GOTOERR(out, mp->rc = -EISDIR);
 
 	rc2 = slm_fcmh_get(&sstb.sst_fg, &c);
 	if (rc2)
 		PFL_GOTOERR(out, mp->rc = rc2);
 
 	if (rc == EEXIST) {
@@ -461,33 +474,33 @@
 			/* reclaim old data */
 			FCMH_LOCK(c);
 			fcmh_wait_locked(c, c->fcmh_flags &
 			    FCMH_IN_SETATTR);
 			sstb.sst_fg.fg_gen = fcmh_2_gen(c) + 1;
 			sstb.sst_size = 0;
 			sstb.sst_blocks = 0;
 			for (i = 0; i < fcmh_2_nrepls(c); i++)
 				fcmh_set_repl_nblks(c, i, 0);
 			/* XXX does this update mtim? */
-			rc = mds_fcmh_setattr(c,
+			rc = mds_fcmh_setattr(vfsid, c,
 			    PSCFS_SETATTRF_DATASIZE | SL_SETATTRF_GEN |
 			    SL_SETATTRF_NBLKS, &sstb);
-			mds_inodes_odsync(c, NULL); /* journal repl_nblks */
+			mds_inodes_odsync(vfsid, c, NULL); /* journal repl_nblks */
 			FCMH_ULOCK(c);
 
 			if (rc)
 				PFL_GOTOERR(out, mp->rc = -rc);
 		}
 	} else
-		slm_fcmh_endow_nolog(p, c);
+		slm_fcmh_endow_nolog(vfsid, p, c);
 
-	idx = mds_repl_ios_lookup_add(fcmh_2_inoh(c), m->resm_res_id,
+	idx = mds_repl_ios_lookup_add(vfsid, fcmh_2_inoh(c), m->resm_res_id,
 	    1);
 	if (idx < 0)
 		PFL_GOTOERR(out, mp->rc = rc);
 	fsiz = mq->sstb.sst_size;
 	for (bno = 0; bno < howmany(mq->sstb.sst_size, SLASH_BMAP_SIZE);
 	    bno++) {
 		rc = mds_bmap_load(c, bno, &b);
 		if (rc)
 			PFL_GOTOERR(out, mp->rc = rc);
 		for (i = 0; i < SLASH_SLVRS_PER_BMAP &&
@@ -523,25 +536,25 @@
 	fcmh_wait_locked(c, c->fcmh_flags & FCMH_IN_SETATTR);
 	/* set nblks regardless of XREPL.
 	 */
 	fcmh_set_repl_nblks(c, idx, mq->sstb.sst_blocks);
 	fl = SL_SETATTRF_NBLKS;
 	if ((mq->flags & SRM_IMPORTF_XREPL) == 0) {
 		fl |= PSCFS_SETATTRF_DATASIZE | PSCFS_SETATTRF_MTIME |
 		    PSCFS_SETATTRF_CTIME | PSCFS_SETATTRF_ATIME |
 		    PSCFS_SETATTRF_UID | PSCFS_SETATTRF_GID;
 	}
-	rc = mds_fcmh_setattr(c, fl, &mq->sstb);
+	rc = mds_fcmh_setattr(vfsid, c, fl, &mq->sstb);
 	if (rc)
 		PFL_GOTOERR(out, mp->rc = -rc);
 
-	rc = mds_inodes_odsync(c, NULL); /* journal repl_nblks */
+	rc = mds_inodes_odsync(vfsid, c, NULL); /* journal repl_nblks */
 	if (rc)
 		mp->rc = rc;
 
  out:
 	psclog_info("import: parent="SLPRI_FG" name=%s rc=%d",
 	    SLPRI_FG_ARGS(&p->fcmh_fg), mq->cpn, mp->rc);
 
 	/*
 	 * XXX if we created the file but left it in a bad state (e.g.
 	 * no repl table), then we should unlink it...
@@ -554,38 +567,47 @@
 	return (0);
 }
 
 int
 slm_rmi_handle_mkdir(struct pscrpc_request *rq)
 {
 	struct srm_mkdir_req *mq;
 	struct srm_mkdir_rep *mp;
 	struct fidc_membh *d;
 	struct srt_stat sstb;
-	int rc;
+	int rc, vfsid;
 
 	SL_RSX_ALLOCREP(rq, mq, mp);
+	if (mdsio_fid_to_vfsid(mq->pfg.fg_fid, &vfsid) < 0) {
+		mp->rc = EINVAL;
+		return (0);
+	}
+	if (vfsid != current_vfsid) {
+		mp->rc = EINVAL;
+		return (0);
+	}
+
 	sstb = mq->sstb;
 	mq->sstb.sst_uid = 0;
 	mq->sstb.sst_gid = 0;
-	rc = slm_mkdir(mq, mp, MDSIO_OPENCRF_NOMTIM, &d);
+	rc = slm_mkdir(vfsid, mq, mp, MDSIO_OPENCRF_NOMTIM, &d);
 	if (rc)
 		return (rc);
 	if (mp->rc && mp->rc != -EEXIST)
 		return (0);
 	FCMH_LOCK(d);
 	fcmh_wait_locked(d, d->fcmh_flags & FCMH_IN_SETATTR);
 	/*
 	 * XXX if mp->rc == -EEXIST, only update attrs if target isn't
 	 * newer
 	 */
-	rc = -mds_fcmh_setattr(d,
+	rc = -mds_fcmh_setattr(vfsid, d,
 	    PSCFS_SETATTRF_UID | PSCFS_SETATTRF_GID |
 	    PSCFS_SETATTRF_ATIME | PSCFS_SETATTRF_MTIME |
 	    PSCFS_SETATTRF_CTIME, &sstb);
 	fcmh_op_done_type(d, FCMH_OPCNT_LOOKUP_FIDC);
 	if (rc)
 		mp->rc = rc;
 	return (0);
 }
 
 int
Index: slash_nara/slashd/main_mds.c
===================================================================
--- slash_nara/slashd/main_mds.c	(revision 19015)
+++ slash_nara/slashd/main_mds.c	(working copy)
@@ -48,32 +48,38 @@
 #include "rpc_mds.h"
 #include "slashd.h"
 #include "slconfig.h"
 #include "slerr.h"
 #include "slsubsys.h"
 #include "subsys_mds.h"
 #include "up_sched_res.h"
 
 #include "zfs-fuse/zfs_slashlib.h"
 
+
+/* this table is immutable, at least for now */
+struct psc_hashtbl		 rootHtable;
+
 GCRY_THREAD_OPTION_PTHREAD_IMPL;
 
 int			 allow_root_uid = 1;
 int			 disable_propagation = 0;
 
+int			 current_vfsid;
+
 const char		*progname;
 
 struct psc_poolmaster	 upsched_poolmaster;
 
 struct slash_creds	 rootcreds = { 0, 0 };
 struct pscfs		 pscfs;
-uint64_t		 slm_fsuuid;
+uint64_t		 slm_fsuuid[MAX_FILESYSTEMS];
 uint32_t		 sys_upnonce;
 
 int
 psc_usklndthr_get_type(const char *namefmt)
 {
 	if (strstr(namefmt, "lnacthr"))
 		return (SLMTHRT_LNETAC);
 	return (SLMTHRT_USKLNDPL);
 }
 
@@ -149,26 +155,167 @@
 usage(void)
 {
 	fprintf(stderr,
 	    "usage: %s [-V] [-D datadir] [-f slashconf] [-p zpoolcache] [-S socket]\n"
 	    "\t[zpoolname]\n",
 	    progname);
 	exit(1);
 }
 
 int
+read_vfsid(int vfsid, char *fn, uint64_t *id)
+{
+	int rc;
+	void *h;
+	char *endp;
+	size_t nb;
+	mdsio_fid_t mf;
+	char buf[30];
+	
+	rc = mdsio_lookup(vfsid, mds_metadir_inum[vfsid], fn, &mf,
+	    &rootcreds, NULL);
+
+	/* backward compatibility */
+	if (rc == ENOENT && !strcmp(fn, SL_FN_FSID)) {
+		*id = nodeSite->site_id;
+		return (0);
+	}
+
+	if (rc) {
+		psclog_errorx("lookup %s/%s: %s", SL_RPATH_META_DIR,
+		    fn, slstrerror(rc));
+		goto out;
+	}
+	rc = mdsio_opencreate(vfsid, mf, &rootcreds, O_RDONLY, 0, NULL,
+	    NULL, NULL, &h, NULL, NULL, 0);
+	if (rc) {
+		psclog_errorx("open %s/%s: %s", SL_RPATH_META_DIR,
+		    fn, slstrerror(rc));
+		goto out;
+	}
+	rc = mdsio_read(vfsid, &rootcreds, buf, sizeof(buf), &nb, 0, h);
+	mdsio_release(vfsid, &rootcreds, h);
+
+	if (rc) {
+		psclog_errorx("read %s/%s: %s", SL_RPATH_META_DIR,
+		    fn, slstrerror(rc));
+		goto out;
+	}
+
+	buf[nb - 1] = '\0';
+	* id = strtoull(buf, &endp, 16);
+	if (*endp || endp == buf) {
+		rc = EINVAL;
+		psclog_errorx("read %s/%s: %s", SL_RPATH_META_DIR,
+		    fn, slstrerror(rc));
+	}
+out:
+	return (rc);
+}
+
+void
+psc_register_filesystem(int vfsid)
+{
+	int i, rc, found;
+	uint64_t fsid;
+	uint64_t uuid;
+	struct psc_hashbkt *b;
+	struct rootNames *entry;
+
+	psclog_warnx("Checking file system %s\n", zfsMount[vfsid].name);
+
+	rc = mdsio_lookup(vfsid, MDSIO_FID_ROOT, SL_RPATH_META_DIR,
+	    &mds_metadir_inum[vfsid], &rootcreds, NULL);
+	if (rc) {
+		psclog_warnx("lookup .slmd metadir: %s", slstrerror(rc));
+		goto out;
+	}
+
+	rc = mdsio_lookup(vfsid, mds_metadir_inum[vfsid], SL_RPATH_UPSCH_DIR,
+	    &mds_upschdir_inum[vfsid], &rootcreds, NULL);
+	if (rc) {
+		psclog_warnx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
+			SL_RPATH_UPSCH_DIR, slstrerror(rc));
+		goto out;
+	}
+
+	rc = mdsio_lookup(vfsid, mds_metadir_inum[vfsid], SL_RPATH_FIDNS_DIR,
+		&mds_fidnsdir_inum[vfsid], &rootcreds, NULL);
+	if (rc) {
+		psclog_warnx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
+			SL_RPATH_FIDNS_DIR, slstrerror(rc));
+		goto out;
+	}
+
+	rc = mdsio_lookup(vfsid, mds_metadir_inum[vfsid], SL_RPATH_TMP_DIR,
+		&mds_tmpdir_inum[vfsid], &rootcreds, NULL);
+	if (rc) {
+		psclog_warnx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
+			SL_RPATH_TMP_DIR, slstrerror(rc));
+		goto out;
+	}
+
+	rc = read_vfsid(vfsid, SL_FN_FSID, &zfsMount[vfsid].fsid);
+	if (rc)
+		goto out;
+	rc = read_vfsid(vfsid, SL_FN_FSUUID, &zfsMount[vfsid].uuid);
+	if (rc)
+		goto out;
+
+	found = 0;
+	fsid = zfsMount[vfsid].fsid;
+	uuid = zfsMount[vfsid].uuid;
+	for (i = 0; i < mount_index; i++) {
+		if (i == vfsid)
+			continue;
+		if (zfsMount[i].fsid == fsid)
+			found++;
+		if (zfsMount[i].uuid == uuid)
+			found++;
+	}
+	if (found) {
+		psclog_warnx("Duplicate FSID/UUID found: %lu\n", fsid);
+		goto out;
+	}
+	rc = zfsslash2_build_immns_cache(vfsid);
+	if (rc) {
+		psclog_warnx("Fail to create cache for file system %s\n", 
+			basename(zfsMount[vfsid].name));
+		goto out;
+	}
+	entry = PSCALLOC(sizeof(struct rootNames));
+	if (!entry) {
+		psclog_warnx("Fail to allocate memory to register %s\n", 
+			basename(zfsMount[vfsid].name));
+		goto out;
+	}
+
+	strcpy(entry->rn_name, basename(zfsMount[vfsid].name));
+	entry->rn_vfsid = vfsid;
+	psc_hashent_init(&rootHtable, entry);
+	b = psc_hashbkt_get(&rootHtable, entry->rn_name);
+	psc_hashbkt_add_item(&rootHtable, b, entry);
+
+	psclog_warnx("File system %s has been registered.\n", 
+		basename(zfsMount[vfsid].name));
+ out:
+	return;
+}
+
+int
 main(int argc, char *argv[])
 {
 	char *zpcachefn = NULL, *zpname;
 	const char *cfn, *sfn, *p;
-	int rc, c, nofsuuid = 0;
-	mdsio_fid_t mf;
+	int c, found, nofsuuid = 0;
+
+	int vfsid;
 
 	/* gcrypt must be initialized very early on */
 	gcry_control(GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);
 	if (!gcry_check_version(GCRYPT_VERSION))
 		errx(1, "libgcrypt version mismatch");
 
 	pfl_init();
 	sl_subsys_register();
 	psc_subsys_register(SLMSS_ZFS, "zfs");
 	psc_subsys_register(SLMSS_JOURNAL, "log");
@@ -233,123 +380,76 @@
 	else if (globalConfig.gconf_zpname[0])
 		zpname = globalConfig.gconf_zpname;
 	else {
 		warn("no ZFS pool specified");
 		usage();
 	}
 
 	fidc_init(sizeof(struct fcmh_mds_info), FIDC_MDS_DEFSZ);
 	bmap_cache_init(sizeof(struct bmap_mds_info));
 
+	authbuf_createkeyfile();
+	authbuf_readkeyfile();
+
+	sl_drop_privs(allow_root_uid);
+
+	libsl_init(2 * (SLM_RMM_NBUFS + SLM_RMI_NBUFS + SLM_RMC_NBUFS));
+
+	slm_workq_init();
+
 	/*
 	 * Initialize the mdsio layer.  There is where ZFS threads
 	 * are started and the given ZFS pool is imported.
 	 */
 	mdsio_init();
 	import_zpool(zpname, zpcachefn);
 
-	rc = mdsio_lookup(MDSIO_FID_ROOT, SL_RPATH_META_DIR,
-	    &mds_metadir_inum, &rootcreds, NULL);
-	if (rc)
-		psc_fatalx("lookup .slmd metadir: %s", slstrerror(rc));
+	psc_hashtbl_init(&rootHtable, PHTF_STR, struct rootNames,
+		rn_name, rn_hentry, 1024, NULL, "rootnames");
 
-	rc = mdsio_lookup(mds_metadir_inum, SL_RPATH_UPSCH_DIR,
-	    &mds_upschdir_inum, &rootcreds, NULL);
-	if (rc)
-		psc_fatalx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
-		    SL_RPATH_UPSCH_DIR, slstrerror(rc));
+	for (vfsid = 0; vfsid < mount_index; vfsid++)
+		psc_register_filesystem(vfsid);
 
-	rc = mdsio_lookup(mds_metadir_inum, SL_RPATH_FIDNS_DIR,
-	    &mds_fidnsdir_inum, &rootcreds, NULL);
-	if (rc)
-		psc_fatalx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
-		    SL_RPATH_FIDNS_DIR, slstrerror(rc));
-
-	rc = mdsio_lookup(mds_metadir_inum, SL_RPATH_TMP_DIR,
-	    &mds_tmpdir_inum, &rootcreds, NULL);
-	if (rc)
-		psc_fatalx("lookup %s/%s dir: %s", SL_RPATH_META_DIR,
-		    SL_RPATH_TMP_DIR, slstrerror(rc));
-
-	rc = mdsio_lookup(mds_metadir_inum, SL_FN_FSUUID, &mf,
-	    &rootcreds, NULL);
-	if (rc)
-		psclog_errorx("lookup %s/%s: %s", SL_RPATH_META_DIR,
-		    SL_FN_FSUUID, slstrerror(rc));
-	else {
-		char *endp, buf[17] = "";
-		size_t nb;
-		void *h;
-
-		rc = mdsio_opencreate(mf, &rootcreds, O_RDONLY, 0, NULL,
-		    NULL, NULL, &h, NULL, NULL, 0);
-		if (rc)
-			PFL_GOTOERR(skipfsuuid, rc);
-		rc = mdsio_read(&rootcreds, buf, sizeof(buf), &nb, 0,
-		    h);
-		mdsio_release(&rootcreds, h);
-
-		if (rc)
-			goto skipfsuuid;
-		if (nb != sizeof(buf))
-			PFL_GOTOERR(skipfsuuid, rc = SLERR_SHORTIO);
-		buf[sizeof(buf) - 1] = '\0';
-		slm_fsuuid = strtoull(buf, &endp, 16);
-		if (*endp || endp == buf)
-			PFL_GOTOERR(skipfsuuid, rc = EINVAL);
-
-		if (0) {
- skipfsuuid:
-			psclog_errorx("%s/%s: %s %s",
-			    SL_RPATH_META_DIR, SL_FN_FSUUID,
-			    buf, slstrerror(rc));
-			slm_fsuuid = 0;
+	found = 0;
+	for (vfsid = 0; vfsid < mount_index; vfsid++) {
+		if (globalConfig.gconf_fsuuid == zfsMount[vfsid].uuid) {
+			psc_assert(!found);
+			found = 1;
+			current_vfsid = vfsid;
+			psclog_warnx("Found file system %s matching UUID=%"PRIx64,
+			    zfsMount[vfsid].name, globalConfig.gconf_fsuuid);
 		}
 	}
+	if (!found)
+		psc_fatalx("config UUID=%"PRIx64" doesn't match any file system",
+		    globalConfig.gconf_fsuuid);
 
-	zfsslash2_build_immns_cache();
-
-	authbuf_createkeyfile();
-	authbuf_readkeyfile();
-
-	sl_drop_privs(allow_root_uid);
-
-	libsl_init(2 * (SLM_RMM_NBUFS + SLM_RMI_NBUFS + SLM_RMC_NBUFS));
-
-	slm_workq_init();
+	zfsslash2_register_hook(psc_register_filesystem);
 
 	psc_poolmaster_init(&upsched_poolmaster,
 	    struct up_sched_work_item, uswi_lentry, PPMF_AUTO, 256, 256,
 	    0, NULL, NULL, NULL, "upschwk");
 	upsched_pool = psc_poolmaster_getmgr(&upsched_poolmaster);
 
 	psc_poolmaster_init(&bmapMdsLeasePoolMaster,
 	    struct bmap_mds_lease, bml_bmdsi_lentry, PPMF_AUTO, 256,
 	    256, 0, NULL, NULL, NULL, "bmplease");
 	bmapMdsLeasePool = psc_poolmaster_getmgr(&bmapMdsLeasePoolMaster);
 
 	lc_reginit(&slm_replst_workq, struct slm_replst_workreq,
 	    rsw_lentry, "replstwkq");
 
 	sl_nbrqset = pscrpc_nbreqset_init(NULL, NULL);
 	pscrpc_nbreapthr_spawn(sl_nbrqset, SLMTHRT_NBRQ, "slmnbrqthr");
 
-	if (!nofsuuid) {
-		if (globalConfig.gconf_fsuuid != slm_fsuuid)
-			psc_fatalx("config UUID=%"PRIx64" doesn't match "
-			    "FS UUID=%"PRIx64,
-			    globalConfig.gconf_fsuuid, slm_fsuuid);
-	} else
-		psclog_warnx("config UUID=%"PRIx64" doesn't match FS "
-		    "UUID=%"PRIx64, globalConfig.gconf_fsuuid, slm_fsuuid);
 
-	mds_journal_init(disable_propagation, (nofsuuid ? 0 : slm_fsuuid));
+	mds_journal_init(disable_propagation, zfsMount[current_vfsid].uuid);
 	mds_odtable_load(&mdsBmapAssignTable, SL_FN_BMAP_ODTAB, "bmapassign");
 	mds_bmap_timeotbl_init();
 	mds_odtable_scan(mdsBmapAssignTable, mds_bia_odtable_startup_cb);
 
 	slm_workers_spawn();
 	slmcohthr_spawn();
 	slmbmaptimeothr_spawn();
 	slmupschedthr_spawnall();
 	slm_rpc_initsvc();
 
Index: slash_nara/slashd/rmm.c
===================================================================
--- slash_nara/slashd/rmm.c	(revision 19015)
+++ slash_nara/slashd/rmm.c	(working copy)
@@ -157,99 +157,105 @@
  */
 int
 slm_rmm_handle_namespace_forward(struct pscrpc_request *rq)
 {
 	struct fidc_membh *p, *op, *np;
 	struct srm_forward_req *mq;
 	struct srm_forward_rep *mp;
 	struct srt_stat sstb;
 	void *mdsio_data;
 	char *from, *to;
+	int vfsid;
 
 	p = op = np = NULL;
 	SL_RSX_ALLOCREP(rq, mq, mp);
 
 	if (mq->op != SLM_FORWARD_MKDIR &&
 	    mq->op != SLM_FORWARD_RMDIR &&
 	    mq->op != SLM_FORWARD_CREATE &&
 	    mq->op != SLM_FORWARD_UNLINK &&
 	    mq->op != SLM_FORWARD_RENAME &&
 	    mq->op != SLM_FORWARD_SETATTR) {
 		mp->rc = EINVAL;
 		return (0);
 	}
 
 	psclog_info("op=%d, fid="SLPRI_FID", name=%s", mq->op, mq->fid,
 	    mq->req.name);
 
+	if (mdsio_fid_to_vfsid(mq->fg.fg_fid, &vfsid)) {
+		mp->rc = EINVAL;
+		return (0);
+	}
+
 	mds_reserve_slot(1);
 	switch (mq->op) {
 	    case SLM_FORWARD_MKDIR:
 		mp->rc = slm_fcmh_get(&mq->fg, &p);
 		if (mp->rc)
 			break;
 		sstb.sst_mode = mq->mode;
 		sstb.sst_uid = mq->creds.scr_uid;
 		sstb.sst_gid = mq->creds.scr_gid;
-		mp->rc = mdsio_mkdir(fcmh_2_mdsio_fid(p), mq->req.name,
+		mp->rc = mdsio_mkdir(vfsid, fcmh_2_mdsio_fid(p), mq->req.name,
 		    &sstb, 0, 0, &mp->cattr, NULL, mdslog_namespace,
 		    NULL, mq->fid);
 		break;
 	    case SLM_FORWARD_CREATE:
 		mp->rc = slm_fcmh_get(&mq->fg, &p);
 		if (mp->rc)
 			break;
-		mp->rc = mdsio_opencreate(fcmh_2_mdsio_fid(p),
+		mp->rc = mdsio_opencreate(vfsid, fcmh_2_mdsio_fid(p),
 		    &mq->creds, O_CREAT | O_EXCL | O_RDWR, mq->mode,
 		    mq->req.name, NULL, &mp->cattr, &mdsio_data,
 		    mdslog_namespace, NULL, mq->fid);
 		if (!mp->rc)
-			mdsio_release(&rootcreds, mdsio_data);
+			mdsio_release(vfsid, &rootcreds, mdsio_data);
 		break;
 	    case SLM_FORWARD_RMDIR:
 		mp->rc = slm_fcmh_get(&mq->fg, &p);
 		if (mp->rc)
 			break;
-		mp->rc = mdsio_rmdir(fcmh_2_mdsio_fid(p), &mp->fid,
+		mp->rc = mdsio_rmdir(vfsid, fcmh_2_mdsio_fid(p), &mp->fid,
 		    mq->req.name, &rootcreds, mdslog_namespace);
 		break;
 	    case SLM_FORWARD_UNLINK:
 		mp->rc = slm_fcmh_get(&mq->fg, &p);
 		if (mp->rc)
 			break;
-		mp->rc = mdsio_unlink(fcmh_2_mdsio_fid(p), &mp->fid,
+		mp->rc = mdsio_unlink(vfsid, fcmh_2_mdsio_fid(p), &mp->fid,
 		    mq->req.name, &rootcreds, mdslog_namespace,
 		    &mp->cattr);
 		break;
 	    case SLM_FORWARD_RENAME:
 		mp->rc = slm_fcmh_get(&mq->fg, &op);
 		if (mp->rc)
 			break;
 		mp->rc = slm_fcmh_get(&mq->nfg, &np);
 		if (mp->rc)
 			break;
 		from = mq->req.name;
 		to = mq->req.name + strlen(mq->req.name) + 1;
-		mp->rc = mdsio_rename(fcmh_2_mdsio_fid(op), from,
+		mp->rc = mdsio_rename(vfsid, fcmh_2_mdsio_fid(op), from,
 		    fcmh_2_mdsio_fid(np), to, &rootcreds,
 		    mdslog_namespace, &mp->cattr);
 		break;
 	    case SLM_FORWARD_SETATTR:
 		/*
 		 * This is tough, because we have some logic at the fcmh
 		 * layer dealing with (partial) truncates.  It is not a
 		 * pure namespace operation.
 		 */
 		mp->rc = slm_fcmh_get(&mq->fg, &p);
 		if (mp->rc)
 			break;
-		mp->rc = mdsio_setattr(fcmh_2_mdsio_fid(p),
+		mp->rc = mdsio_setattr(vfsid, fcmh_2_mdsio_fid(p),
 		    &mq->req.sstb, mq->to_set, &rootcreds, &mp->cattr,
 		    fcmh_2_mdsio_data(p), mdslog_namespace);
 		break;
 	}
 	mds_unreserve_slot(1);
 	if (p)
 		fcmh_op_done_type(p, FCMH_OPCNT_LOOKUP_FIDC);
 	if (op)
 		fcmh_op_done_type(op, FCMH_OPCNT_LOOKUP_FIDC);
 	if (np)
@@ -359,20 +365,25 @@
 		mq->creds = *creds;
 		rc = slm_get_next_slashfid(&mq->fid);
 	}
 	if (rc)
 		goto out;
 
 	rc = SL_RSX_WAITREP(csvc, rq, mp);
 	if (rc)
 		goto out;
 
+#if 0
+	/*
+ 	 * We don't replicate namespace in a piecemeal fashion any more.
+ 	 * Instead, the plan is to use snapshot.
+ 	 */
 	switch (op) {
 	    case SLM_FORWARD_MKDIR:
 		rc = mdsio_redo_mkdir(mq->fg.fg_fid, name, &mp->cattr);
 		if (!rc)
 			*sstb = mp->cattr;
 		break;
 	    case SLM_FORWARD_RMDIR:
 		rc = mdsio_redo_rmdir(mq->fg.fg_fid, mp->fid, name);
 		break;
 	    case SLM_FORWARD_CREATE:
@@ -394,18 +405,19 @@
 		    sstb);
 		if (!rc)
 			*sstb = mp->cattr;
 		break;
 	    default:
 		rc = EINVAL;
 		break;
 	}
 	psclog_errorx("replay failed: op=%d fid="SLPRI_FID" name=%s rc=%d",
 	    op, mq->fg.fg_fid, name, rc);
+#endif
 
  out:
 	if (rq)
 		pscrpc_req_finished(rq);
 	if (csvc)
 		sl_csvc_decref(csvc);
 	return (rc);
 }
Index: slash_nara/slashd/replay.c
===================================================================
--- slash_nara/slashd/replay.c	(revision 19015)
+++ slash_nara/slashd/replay.c	(working copy)
@@ -22,26 +22,38 @@
 #include "pfl/fs.h"
 
 #include "bmap_mds.h"
 #include "fidc_mds.h"
 #include "journal_mds.h"
 #include "mdsio.h"
 #include "namespace.h"
 #include "pathnames.h"
 #include "repl_mds.h"
 #include "slerr.h"
+#include "zfs-fuse/zfs_slashlib.h"
 
 #define B_REPLAY_OP_CRC		0
 #define B_REPLAY_OP_REPLS	1
 
 #define I_REPLAY_OP_REPLS	0
 
+/*
+ * Alternatively, we could add vfsid to each log entry in the journal.  But doing
+ * so can break backward compatibility. It also reduces the space of each log
+ * entry.  We could infer vfsid from the fid stored in a log entry.  But some 
+ * entries such as bmap assignment log entries do not have one.
+ * 
+ * Actually, we can use the FSUUID stored in the log header to do the matching.
+ */
+
+extern int current_vfsid;
+
 /**
  * mds_replay_bmap - Replay an operation on a bmap.
  */
 static int
 mds_replay_bmap(void *jent, int op)
 {
 	struct slmds_jent_bmap_repls *sjbr = jent;
 	struct slmds_jent_bmap_crc *sjbc = jent;
 	struct srt_bmap_crcwire *bmap_wire;
 	struct fidc_membh *f = NULL;
@@ -70,44 +82,44 @@
 		memcpy(b->bcm_repls, sjbr->sjbr_repls,
 		    SL_REPLICA_NBYTES);
 		break;
 	case B_REPLAY_OP_CRC: {
 		struct slash_inode_handle *ih;
 		struct srt_stat sstb;
 		int fl, idx;
 
 		FCMH_LOCK(f);
 		ih = fcmh_2_inoh(f);
-		idx = mds_repl_ios_lookup(ih, sjbc->sjbc_iosid);
+		idx = mds_repl_ios_lookup(current_vfsid, ih, sjbc->sjbc_iosid);
 		if (idx < 0) {
 			psclog_errorx("iosid %d not found in repl "
 			    "table", sjbc->sjbc_iosid);
 			goto out;
 		}
 		sstb.sst_blocks = sjbc->sjbc_aggr_nblks;
 		fcmh_set_repl_nblks(f, idx, sjbc->sjbc_repl_nblks);
 		if (idx >= SL_DEF_REPLICAS)
-			rc = mds_inox_write(ih, NULL, NULL);
+			rc = mds_inox_write(current_vfsid, ih, NULL, NULL);
 		else
-			rc = mds_inode_write(ih, NULL, NULL);
+			rc = mds_inode_write(current_vfsid, ih, NULL, NULL);
 		if (rc)
 			goto out;
 
 		fl = SL_SETATTRF_NBLKS;
 
 		/* Apply the filesize from the journal entry.
 		 */
 		if (sjbc->sjbc_extend) {
 			sstb.sst_size = sjbc->sjbc_fsize;
 			fl |= PSCFS_SETATTRF_DATASIZE;
 		}
-		rc = mds_fcmh_setattr_nolog(f, fl, &sstb);
+		rc = mds_fcmh_setattr_nolog(current_vfsid, f, fl, &sstb);
 		if (rc)
 			goto out;
 
 		for (i = 0; i < sjbc->sjbc_ncrcs; i++) {
 			bmap_wire = &sjbc->sjbc_crc[i];
 			bmap_2_crcs(b, bmap_wire->slot) = bmap_wire->crc;
 			b->bcm_crcstates[bmap_wire->slot] |=
 			    BMAP_SLVR_DATA | BMAP_SLVR_CRC;
 		}
 		break;
@@ -207,56 +219,56 @@
 				    sjir->sjir_nrepls);
 		}
 
 		psc_assert(sjir->sjir_nrepls <= SL_MAX_REPLICAS);
 
 		if (sjir->sjir_nrepls > SL_DEF_REPLICAS) {
 			mds_inox_ensure_loaded(ih);
 			memcpy(ih->inoh_extras->inox_repls,
 			    &sjir->sjir_repls[SL_DEF_REPLICAS],
 			    sizeof(ih->inoh_extras->inox_repls));
-			rc = mds_inox_write(ih, NULL, NULL);
+			rc = mds_inox_write(current_vfsid, ih, NULL, NULL);
 			if (rc)
 				goto out;
 
 			DEBUG_INOH(PLL_DEBUG, ih, "replayed inox_repls");
 		}
 
 		ih->inoh_ino.ino_replpol = sjir->sjir_replpol;
 		ih->inoh_ino.ino_nrepls = sjir->sjir_nrepls;
 		memcpy(ih->inoh_ino.ino_repls, sjir->sjir_repls,
 		    sizeof(ih->inoh_ino.ino_repls));
 		break;
 	default:
 		psc_fatalx("unknown op");
 	}
 
-	rc = mds_inode_write(ih, NULL, NULL);
+	rc = mds_inode_write(current_vfsid, ih, NULL, NULL);
 
  out:
 	if (ih)
 		INOH_ULOCK(ih);
 	psclog(rc ? PLL_ERROR : PLL_DEBUG,
 	    "fid="SLPRI_FID" rc=%d", fg.fg_fid, rc);
 	if (f)
 		fcmh_op_done_type(f, FCMH_OPCNT_LOOKUP_FIDC);
 	return (rc);
 }
 
 static int
 mds_replay_ino_repls(struct psc_journal_enthdr *pje)
 {
 	struct slmds_jent_ino_repls *sjir;
 	int rc;
 
 	sjir = PJE_DATA(pje);
-	rc = mdsio_redo_fidlink(sjir->sjir_fid, &rootcreds);
+	rc = mdsio_redo_fidlink(current_vfsid, sjir->sjir_fid, &rootcreds);
 	if (!rc)
 	    rc = mds_replay_ino(sjir, I_REPLAY_OP_REPLS);
 	return (rc);
 }
 
 /**
  * mds_replay_bmap_assign - Replay a bmap assignment update.
  */
 static int
 mds_replay_bmap_assign(struct psc_journal_enthdr *pje)
@@ -279,29 +291,29 @@
 	else {
 		sjba = &logentry->sjar_bmap;
 		psclog_info("replay item %zd, fid="SLPRI_FID", flags=%d",
 		    elem, sjba->sjba_fid, logentry->sjar_flags);
 	}
 	if (logentry->sjar_flags & SLJ_ASSIGN_REP_INO)
 		mds_replay_ino(&logentry->sjar_ino, I_REPLAY_OP_REPLS);
 	if (logentry->sjar_flags & SLJ_ASSIGN_REP_REP)
 		mds_replay_bmap(&logentry->sjar_rep,
 		    B_REPLAY_OP_REPLS);
-	rc = mdsio_lookup(mds_metadir_inum, SL_FN_BMAP_ODTAB, &mf,
+	rc = mdsio_lookup(current_vfsid, mds_metadir_inum[current_vfsid], SL_FN_BMAP_ODTAB, &mf,
 	    &rootcreds, NULL);
 	psc_assert(rc == 0);
 
-	rc = mdsio_opencreate(mf, &rootcreds, O_RDWR, 0, NULL, NULL,
+	rc = mdsio_opencreate(current_vfsid, mf, &rootcreds, O_RDWR, 0, NULL, NULL,
 	    NULL, &handle, NULL, NULL, 0);
 	psc_assert(!rc && handle);
 
-	rc = mdsio_read(&rootcreds, &odth, sizeof(odth), &nb, 0,
+	rc = mdsio_read(current_vfsid, &rootcreds, &odth, sizeof(odth), &nb, 0,
 	    handle);
 	psc_assert(rc == 0 && nb == sizeof(odth));
 
 	psc_assert((odth.odth_magic == ODTBL_MAGIC) &&
 		   (odth.odth_version == ODTBL_VERS));
 
 	p = PSCALLOC(odth.odth_slotsz);
 	odtf = p + odth.odth_elemsz;
 	odtf->odtf_magic = ODTBL_MAGIC;
 	odtf->odtf_slotno = elem;
@@ -323,27 +335,27 @@
 		if (len < odth.odth_elemsz)
 			memset(p + len, 0, odth.odth_elemsz - len);
 		psc_crc64_calc(&crc, p, odth.odth_elemsz);
 
 		odtf->odtf_crc = crc;
 		odtf->odtf_inuse = ODTBL_INUSE;
 	}
 	if (logentry->sjar_flags & SLJ_ASSIGN_REP_FREE)
 		odtf->odtf_inuse = ODTBL_FREE;
 
-	rc = mdsio_write(&rootcreds, p, odth.odth_slotsz,
+	rc = mdsio_write(current_vfsid, &rootcreds, p, odth.odth_slotsz,
 	   &nb, odth.odth_start + elem * odth.odth_slotsz,
 	   0, handle, NULL, NULL);
 	psc_assert(!rc && nb == odth.odth_slotsz);
 
 	PSCFREE(p);
-	mdsio_release(&rootcreds, handle);
+	mdsio_release(current_vfsid, &rootcreds, handle);
 	return (0);
 }
 
 /**
  * mds_replay_namespace - Replay a NAMESPACE modification operation.
  *	Note: this may not be a replay but could also be a namespace
  *	update from a remote MDS.
  * @sjnm: journal entry.
  * @replay: whether this is a replay or remote MDS update.
  */
@@ -392,60 +404,60 @@
 	 * If the receiving MDS is the one that initiated the namespace
 	 * operation, then we should have already propagated the remote
 	 * operation back to us.  If so, then seeing ENOENT for unlink
 	 * and EXIST for creates should be fine.
 	 */
 	switch (sjnm->sjnm_op) {
 	    case NS_OP_RECLAIM:
 		rc = 0;
 		break;
 	    case NS_OP_CREATE:
-		rc = mdsio_redo_create(sjnm->sjnm_parent_fid, name,
+		rc = mdsio_redo_create(current_vfsid, sjnm->sjnm_parent_fid, name,
 		    &sstb);
 		break;
 	    case NS_OP_MKDIR:
-		rc = mdsio_redo_mkdir(sjnm->sjnm_parent_fid, name,
+		rc = mdsio_redo_mkdir(current_vfsid, sjnm->sjnm_parent_fid, name,
 		    &sstb);
 		break;
 	    case NS_OP_LINK:
-		rc = mdsio_redo_link(sjnm->sjnm_parent_fid,
+		rc = mdsio_redo_link(current_vfsid, sjnm->sjnm_parent_fid,
 		    sjnm->sjnm_target_fid, name, &sstb);
 		break;
 	    case NS_OP_SYMLINK:
-		rc = mdsio_redo_symlink(sjnm->sjnm_parent_fid,
+		rc = mdsio_redo_symlink(current_vfsid, sjnm->sjnm_parent_fid,
 		    sjnm->sjnm_target_fid, name, newname, &sstb);
 		break;
 	    case NS_OP_RENAME:
-		rc = mdsio_redo_rename(sjnm->sjnm_parent_fid, name,
+		rc = mdsio_redo_rename(current_vfsid, sjnm->sjnm_parent_fid, name,
 		    sjnm->sjnm_new_parent_fid, newname, &sstb);
 		break;
 	    case NS_OP_UNLINK:
-		rc = mdsio_redo_unlink(sjnm->sjnm_parent_fid,
+		rc = mdsio_redo_unlink(current_vfsid, sjnm->sjnm_parent_fid,
 		    sjnm->sjnm_target_fid, name);
 		break;
 	    case NS_OP_RMDIR:
-		rc = mdsio_redo_rmdir(sjnm->sjnm_parent_fid,
+		rc = mdsio_redo_rmdir(current_vfsid, sjnm->sjnm_parent_fid,
 		    sjnm->sjnm_target_fid, name);
 		break;
 	    case NS_OP_SETSIZE:
 	    case NS_OP_SETATTR:
 		if (!replay) {
 			/*
 			 * Make sure that we propagate attributes
 			 * to the fcmh layer if work is done at
 			 * the ZFS layer.
 			 */
 			rc = slm_fcmh_peek(&sstb.sst_fg, &fcmh);
 			if (fcmh)
 				FCMH_LOCK(fcmh);
 		}
-		rc = mdsio_redo_setattr(sjnm->sjnm_target_fid,
+		rc = mdsio_redo_setattr(current_vfsid, sjnm->sjnm_target_fid,
 		    sjnm->sjnm_mask, &sstb);
 		slm_setattr_core(fcmh, &sstb,
 		    mdsio_setattrmask_2_slflags(sjnm->sjnm_mask));
 		if (!replay) {
 			if (fcmh) {
 				/* setattr() above has filled sstb */
 				COPY_SSTB(&sstb, &fcmh->fcmh_sstb);
 				fcmh_op_done_type(fcmh, FCMH_OPCNT_LOOKUP_FIDC);
 			}
 		}
