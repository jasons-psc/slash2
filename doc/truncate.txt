$Id$

This document describes the implementation of truncate operates in the
SLASH2 system.

There are two kinds of truncates that are handled differently:

    (o) full truncate, i.e. truncate to file offset position 0
    (o) partial truncate, i.e. truncate to non-zero file offset position

Full truncates cause the file generation number to be bumped and record
the old file ID/generation# into a logfile which is shipped to all
sliods that were registered in the file replica table.  Once these
logfiles are successfully received by all sliods they pertain to and the
sliods reply, signifying the actions have been applied, the logfiles on
the MDS are deleted.

Other actions that evoke this same garbage collection mechanism are:

    (o)	unlink(2)
    (o)	a clobbering rename(2)

Partial truncates are performed solely by the truncate(2) system call
and only affects the current metadata in the MDS of the affected file.

First, if the file is marked IN_PTRUNC, signifying that it is already
handling partial truncation resolution (i.e. the steps outlined here),
failure is returned immediately to the client issuing the SETATTR.

The file is marked (in memory only, at this point) IN_PTRUNC and the
client is notified that this behavior is taking place.  At this point,
it is the client's responsibility to reissue the SETATTR on failure as
the MDS provides no guarentees yet that the operation will be recorded
by a journal or other persistent behavior tracker.

Next, any leases currently granted to clients for bmaps including or
falling after the partial truncate file offset position (hereby referred
to as the 'ptrunc position') are asked to be released by the MDS.

The MDS then waits for clients to relinquish all said leases, waiting a
maximum of the bmap timeout time in the case of unresponsive clients.

The next action is determined depending on the value of the ptrunc
position:

    (o)	if the ptrunc position falls cleanly between two bmaps, the
	following actions are taken:

	(o) bmaps after the ptrunc position are marked VALID->GARBAGE
	    and written to ZFS,

	(o) the new file size is saved in sst_size and written to the
	    ZFS metadata backend file system without journaling, and

	(o) the IN_PTRUNC flag is cleared from the file, and

    (o) if the ptrunc position falls within a bmap, USSR work is
	queued to resolve the CRC recalculation that must occur before
	processing can return to normal.

	All full bmaps past the ptrunc position are marked
	VALID->GARBAGE and the bmap where the ptrunc position lies is
	marked VALID->TRUNCPNDG.

	At earliest convenience, a randomly selected TRUNCPNDG sliod is
	asked to perform the CRC recalculation.  When one finally does,
	the bmap is marked TRUNCPNDG->VALID and other replicas are
	marked TRUNCPNDG->GARBAGE.

At this point, the MDS issues BMAP_WAKE notifications to the original
client as well as to any new clients that attempted SETATTR or
BMAP_LEASE requests since IN_PTRUNC was set.  If a connection to the MDS
is ever lost, the clients are responsible for reestablishing and
reissuing requests to become "registered" for bmapwakeup callback when
the resolution finishes.

In either case, after any bmaps have been marked as GARBAGE, USSR work
is scheduled for garbage reclamation for those bmaps at earliest
convenience.  Once all sliods have notified the MDS that the garbage has
been reclaimed, the MDS truncates any entirely freed bmaps from the
backend metadata file.
