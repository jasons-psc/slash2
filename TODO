$Id$

11/22/09
* Thinking about truncate.. in the event of an O_TRUNC or truncate() syscall we
should not invalidate replicas but rather queue truncate or reclamation requests
for the affected storage backend systems and perform the appropriate truncate
on the metafile.  Somehow the truncate queue must be persistent on the mds.
Additionally, a sliver's worth of data may need to be checksummed.

Other garbage collection requests must be handled in a similar fashion.  For
instance an 'rm' operation must record the fid+gen pair and queue a garbage
collection request.  For this the replica IOS's should be read from the inode
and used to generate the requests.  This type of GC should be easy due to ZFS's
use fo fid+gen pairs.

Truncate is more of a problem because the fid+gen remains, thus making async IOS
truncate operations problematic because new writes may come from the client before
the truncate is processed by the IOS (whoops!).  Client to IOS truncate ops are
also unfavorable because replica maintenance may need to be done, the client may have
the replica table but should he be the one directing the truncates to all IOS's?
I'm inclined to say 'no'.  Care must be taken here so that we don't hurt performance
for (O_CREAT|O_TRUNC) of existing files which is the case where the fid+gen is not
changed.  As an optimization we could possibly delete the file on the mds first,
invoking the GC routines for that fid+gen and then create a new inode.  Of course
this may break semantics for some apps which assume the same inode # to be used.


11/02/09
* msl_io and rpc ION calls need to return actual size so that read() can
be short circuited  on EOF.

09/28/09
* Mds failure causes client to crash in fidc_fcoo_remove.

[1254162324:006671 msfsthr23:25431:pscrpc_deactivate_import:108] setting import 0xf3920b0 INVALID
[1254162324:006693 msfsthr23:25431:pscrpc_deactivate_import:113] Here's where failover is supposed to happen!!!
[1254162324:006727 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0x2aaab02d23e0 x43331/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006768 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0xf466f30 x43329/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006797 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0x2aaab02d1e50 x43327/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006825 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0xf45fa90 x43328/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006854 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0x2aaab414cd90 x43330/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006882 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0xf46de80 x43326/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006910 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0x2aaab414b7d0 x43325/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006939 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0x2aaaac09f770 x43324/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006979 msfsthr23:25431:fidc_fcoo_remove:416] [assert] SPLAY_EMPTY(&o->fcoo_bmapc)

09/23/09
* Sliod has too many open files but reports success anyway to mount_slash.

* Need a method for cleaning up sliod inodes, they're sitting around in the cache dirty (and
	hence, unreclaimable).
	. use biod_lentry to place bmaps onto an list which is periodically
	scanned for bmaps which have been inactive for some time.

	. the bmaps are gathered up and placed into an rpc bound for the mds.
	the mds unbinds the bmaps from the sliod (erasing the respective
	odtable entry).

	. fcmh will remain dirty until all of its bmaps have been reclaimed.  At
	that point the fcmh file des will be closed and the fcmh will be released.

	. Note that these operations are not beared upon by client-side release
	operations.  They are purposely kept separate.

* Sliod runs out of space in filesystem and returns from an rpc early (client sees the rc -28)
	the problem is that other sliod threads are blocked on a waitq and are never woken
	up.  Need a way to deal with the failure mode.

* It would seem that generation numbering is needed in the slfidns, still not sure what
	to do about deletes or truncates.

* While running a small file / create intensive fio test, I find that most of the threads
are blocking here waiting for rpc completion.  This makes things like 'ls -al' very slow
because no threads are left to process incoming operations.
Thread 4 (Thread 0x50fa7940 (LWP 31008)):
#0  0x000000331c20a899 in pthread_cond_wait@@GLIBC_2.3.2 ()
#1  0x00000000004748a9 in psc_waitq_waitrel ()
#2  0x0000000000423d2b in bmap_oftrq_waitempty ()
#3  0x0000000000424151 in msl_bmap_tryrelease ()
#4  0x000000000042425d in msl_fbr_free ()
#5  0x0000000000424f4d in msl_bmap_fhcache_clear ()
#6  0x000000000041b62c in slash2fuse_release ()
#7  0x00002b93b5a6c7c3 in do_release () from /usr/local/lib/libfuse.so.2
#8  0x000000000040f302 in slash2fuse_listener_loop ()
#9  0x000000331c206367 in start_thread () from /lib64/libpthread.so.0
#10 0x000000331bad309d in clone () from /lib64/libc.so.6

Actually, if all of the operations performed in slash2fuse_release could be done
asynchronously then performance would be greatly improved.

Well, after increasing the number of fuse threads to 48 I don't see the entire set blocked
in release but I don't see good performance for 'ls -al'.

* Namespace Disconnection Problem
  The namespace must be protected from a rename operation where a parent directory
  is renamed into one of its children.  Supposedly a global rename lock is used in
  today's filesystems which locks the entire namespace and looks analyzes the paths to ensure
  that a rename is source is not a parent of the target.  I think this is not a problem
  using directory hardlinks since the source's children may be determined via the immns
  dir hardlink.  EEB seems to think otherwise..  I think the issue is where the ".." directory
  of the destination points.  If it points to the immns then we're in trouble.


* Truncate Implementation
  Non O_TRUNC but otherwise aligned trunc operations should be fairly simple to implement.
  Here two things are required:
	 1. Zero out the bmap descriptors within the metafile.
	 2. Record the reclaimable regions so the the IONs may also reclaim that space.

  The question is, how do we deal with unaligned truncates?  We need some way to denote that
  the bmap crc is no longer valid.  Actually such a construct is probably needed in other places
  as well.  On truncate, the value of ino_lblk needs to be reset as does ino_lblk_sz.


* Fidcache Generation Numbering
	Fidcache must support generation numbers.
		. hash table code should be modified to add a cmp function.
		. ambiguous inode lookups should prefer the highest gen #

	On the fidcache generation # subject.  Implementing the FC with gen #'s is
	awkward because fuse does not provide the generation number except when it
	provides an 'fi'.  This means that the gen cannot be used for hash table lookups
	taking place on behalf of operations like: create, mkdir, open,	etc.

	Done but seeing a problem on the client when doing stress testing:
	[1233201864:695906 msfsthr9:__fidc_lookup_fg:320] [assert] fcmh_2_gen(tmp) != FID_ANY

	Not seeing the above on the server..


* Running out of FCMH's and threads hanging in fidc_get()
	On this deadlock.. check the refcnts on the fcmh's, this may be a
		true case of exhaustion.
		- Refcnts checked out to be ok.

	Problem described and fixed in r5093

	Here's a deadlock:

Thread 10 (Thread 1199630656 (LWP 5936)):
#0  0x0000000000425cb8 in _lc_get ()
#1  0x0000000000425a4a in lc_getnb ()
#2  0x0000000000424947 in fidc_reap ()
#3  0x00000000004260b1 in fidc_get ()
#4  0x00000000004296cb in __fidc_lookup_inode ()
#5  0x0000000000404088 in slash2fuse_fidc_putget ()
#6  0x000000000040a229 in slash2fuse_create ()
#7  0x00002b264fa70f53 in fuse_reply_err () from /usr/lib/libfuse.so.2
#8  0x00000000004036ec in slash2fuse_listener_loop ()
#9  0x00002b2650094305 in start_thread () from /lib64/libpthread.so.0
#10 0x00002b265037550d in clone () from /lib64/libc.so.6
#11 0x0000000000000000 in ?? ()


	1/27/09
		Here's the stack trace of a hung server thread:

Thread 105 (Thread 1325521216 (LWP 5518)):
#0  0x00000000004371ea in _tands ()
#1  0x00000000004371c1 in spinlock ()
#2  0x000000000043715c in reqlock ()
#3  0x0000000000438a98 in _lc_put ()
#4  0x00000000004385cc in fidc_reap ()
#5  0x0000000000438cf6 in fidc_get ()
#6  0x000000000043c310 in __fidc_lookup_inode ()
#7  0x000000000042ed3f in slrmc_inode_cacheput ()
#8  0x0000000000431b8c in slrmc_create ()
#9  0x0000000000435bcb in slrmc_handler ()
#10 0x0000000000478a13 in pscrpc_server_handle_request ()
#11 0x000000000047acc2 in pscrpc_main ()
#12 0x000000000047c3d0 in pscrpcthr_begin ()
#13 0x00000000004535c6 in pscthr_begin ()
#14 0x00002b6cc53f7305 in start_thread () from /lib64/libpthread.so.0
#15 0x00002b6cc5ce750d in clone () from /lib64/libc.so.6
#16 0x0000000000000000 in ?? ()


* MDS Memory Leak
	1/28/09
	After running some large tests, it's clear that the slash mds is leaking memory badly.
	This will have to be fixed before large scale tests can resume

	mount_slash seems to be leaking too, especially on large tree traversals with unlinks.

mds.c
	mexpfcm_cfd_init()
		mexpfcm
		fidc_mds_info to f->fcmh_fcoo->fcoo_pri
			. this wasn't being freed in mexpfcm_cfd_free()


* fcmh_2_gen(tmp) != FID_ANY __fidc_lookup_fg:320
	Look at this assert.  I'm not convinced that fidc_lookup_load_inode()
	is useful.  It occasionally lets inodes into the cache without a proper
	generation number.  Which then causes this assert.

	unique: 94876, opcode: UNLINK (10), nodeid: 379151, insize: 65

	[1233209602:863246 msfsthr8:__fidc_lookup_inode:480]  fcmh@0x6f5a70 fcoo@(nil) f
cooref(-66:-66) i+g:379151+281474976710655 s: CG lc:Free r:1 :: adding FID_ANY t
o cache

	[1233209602:866275 msfsthr5:__fidc_lookup_fg:320] [assert] fcmh_2_gen(tmp) != FI
D_ANY


	Look at removing load_inode alltogether.  Instead, maybe do an extra
	ref on lookup so that proceeding operations are guaranteed to have
	their inodes cached.

- differeniate I/O software terminology
	(o) ion - an I/O node (resm)
	(o) ios - an I/O system (res)
	(o) iod - the sliod daemon
- rename buffer.c -> slab.c
- rename fdbuf.c -> descbuf.c
- ensure fidc doesn't look up beyond SYM_NLOOPS #loops
- make it easy for sliod to run as user _sliod
- remove "iod" from bmdsiod
- new ctls for managing persistent replication:

  low-level persistence control primitives:
    $ msctl [-R] -f new-repl-policy=persist|onetime:fn
    $ msctl [-R] -f bmap-repl-policy=persist|onetime:4-6,9:fn

  mid-level persistence control aliases:
    $ slfctl [-R] -p file ...				# new-repl-policy=persist
    $ slfctl [-R] -o file ...				# new-repl-policy=onetime
    $ slfctl -B bmapspec:file ...			# bmap-repl-policy=persist
    $ slfctl -b bmapspec:file ...			# bmap-repl-policy=onetime

  mid-level replication request control aliases:
    $ slrepls [-R] file ...				# msctl [-R] -r file -r...
    $ slreplq [-R] site,...[|bmapspec]:file ...		# msctl [-R] -Q spec -Q...
    $ slreplrm [-R] site,...[|bmapspec]:file ...	# msctl [-R] -U spec -U...

  high-level aliases:
    $ slreplicate [-Rp] site,...:file ...
	if (-p)
		slfctl [-R] -p file ...
	msctl [-R] -Q site,...|*[P]:file ...
    $ slreplcancel file[:site] ...
	if (-p)
		slfctl [-R] -o file ...
	msctl [-R] -U site,...|*[P]:file ...
    $ slreplpersist file ...
	slfctl -p file ...
	slfctl -B *:file *:...
    $ slreplnopersist file ...
	slfctl -o file ...
	slfctl -b *:file *:...

----------------------------------------------------------------------

- get rid of global lpid var.  zest uses an array to listen on multiple
  interfaces; slash should do the same.
- slimmns does more than create the immutable namespace, and should
  be more intuitively named for formatting MDS file systems, such as
  slmkfs, slfmtfs, or slnewfs
- rename rpc_csvc_create to slashrpc_csvc_create() and don't expose it
  outside of rpc_common.c
- libsl_init() is getting an ENOMEM somewhere in slashd, maybe LNET
- do not keep sl_replrq in mem unless a bh_repl is OLD or SCHED
- add bmap_hdr in replst ctlmsg
- filenames with , and : will not make the msctl repl parser happy, reorder
- fix pool names in -Lall -Pall -iall -hall -Mall in each of slmctl, slictl, msctl
- handle msctl -Q bmap[P] persist policy overrider

maybe not:
- merge sl_replrq directly into fidc_mds_info
- use a sliding window to track valid cfd's and remove them from the window
  once they are CLOSE()'d
