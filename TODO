$Id$

reminders:
- be consistent with I/O software terminology
	(o) ion - an I/O node (resm)
	(o) ios - an I/O system (res)
	(o) iod - the sliod daemon

1/14/10
* Deal with problems surrounding full odtable. ATM odtable put errors are not dealt with properly
leading to problems later in cfdfree where the bmap refcnt is wrong.

gdb> bt
#0  0x0000003c10c30265 in raise () from /lib64/libc.so.6
#1  0x0000003c10c31d10 in abort () from /lib64/libc.so.6
#2  0x0000000000463032 in _psclogv (fn=0x59b3e0 "/home/yanovich/code/advsys/p4/slash_nara/share/bmap.c", func=0x59b617 "_bmap_op_done",
    line=83, subsys=4, level=0, options=0, fmt=0x59b46d "[assert] %s", ap=0x2aaacb203580)
    at /home/yanovich/code/advsys/p4/psc_fsutil_libs/psc_util/log.c:258
#3  0x000000000046326a in _psc_fatal (fn=0x59b3e0 "/home/yanovich/code/advsys/p4/slash_nara/share/bmap.c", func=0x59b617 "_bmap_op_done",
    line=83, subsys=4, level=0, options=0, fmt=0x59b46d "[assert] %s") at /home/yanovich/code/advsys/p4/psc_fsutil_libs/psc_util/log.c:281
#4  0x000000000043cabf in _bmap_op_done (b=0x11beb0f0) at /home/yanovich/code/advsys/p4/slash_nara/share/bmap.c:83
#5  0x00000000004166da in mds_bmap_ref_drop_locked (bmap=0x11beb0f0, rw=SL_WRITE)
    at /home/yanovich/code/advsys/p4/slash_nara/slashd/mds.c:792
#6  0x00000000004169a1 in mexpfcm_release_bref (bref=0x11bd2870) at /home/yanovich/code/advsys/p4/slash_nara/slashd/mds.c:817
#7  0x000000000041279c in mexpfcm_release_brefs (m=0x2aaad00a2570) at /home/yanovich/code/advsys/p4/slash_nara/slashd/mds.c:353
#8  0x0000000000412ed7 in mexpfcm_cfd_free (c=0x2aaad00941e0, e=0x11b4ef40) at /home/yanovich/code/advsys/p4/slash_nara/slashd/mds.c:394
#9  0x000000000040600a in cfdfree (exp=0x11b4ef40, cfd=1090) at /home/yanovich/code/advsys/p4/slash_nara/slashd/cfd.c:194
#10 0x0000000000432fbf in slm_rmc_handle_release (rq=0x2aaac402c930) at /home/yanovich/code/advsys/p4/slash_nara/slashd/rmc.c:606
#11 0x0000000000436bf2 in slm_rmc_handler (rq=0x2aaac402c930) at /home/yanovich/code/advsys/p4/slash_nara/slashd/rmc.c:930
#12 0x00000000004a028d in pscrpc_server_handle_request (svc=0x11b36e70, thread=0x11b4ccc0)
    at /home/yanovich/code/advsys/p4/psc_fsutil_libs/psc_rpc/service.c:366
#13 0x00000000004a2fbc in pscrpc_main (thread=0x11b4ccc0, svc=0x11b36e70)
    at /home/yanovich/code/advsys/p4/psc_fsutil_libs/psc_rpc/service.c:726
#14 0x00000000004a531d in pscrpcthr_begin (arg=0x11b4ccc0) at /home/yanovich/code/advsys/p4/psc_fsutil_libs/psc_rpc/service.c:1033
#15 0x000000000046d7b9 in _pscthr_begin (arg=0x7fffcfa2dae0) at /home/yanovich/code/advsys/p4/psc_fsutil_libs/psc_util/thread.c:256
#16 0x0000003c11406617 in start_thread () from /lib64/libpthread.so.0
#17 0x0000003c10cd3c2d in clone () from /lib64/libc.so.6




12/4/09
* More about truncate, unlink GC.

Unlinked inodes which contain bmaps we should link the fid file into a GC
directory.  From here we can scan the bmaps and issue GC requests to the
appropriate IOS's.   If we implement a 2nd generation #, managed by slash2,
we would use fmt fid_zfs-gen_slash2-gen in the C directory.

11/23/09
* mds_bmap_ion_assign fails when the doesn't specify a PIOS.

11/22/09
* Thinking about truncate.. in the event of an O_TRUNC or truncate() syscall we
should not invalidate replicas but rather queue truncate or reclamation requests
for the affected storage backend systems and perform the appropriate truncate
on the metafile.  Somehow the truncate queue must be persistent on the mds.
Additionally, a sliver's worth of data may need to be checksummed.

Other garbage collection requests must be handled in a similar fashion.  For
instance an 'rm' operation must record the fid+gen pair and queue a garbage
collection request.  For this the replica IOS's should be read from the inode
and used to generate the requests.  This type of GC should be easy due to ZFS's
use fo fid+gen pairs.

Truncate is more of a problem because the fid+gen remains, thus making async IOS
truncate operations problematic because new writes may come from the client before
the truncate is processed by the IOS (whoops!).  Client to IOS truncate ops are
also unfavorable because replica maintenance may need to be done, the client may have
the replica table but should he be the one directing the truncates to all IOS's?
I'm inclined to say 'no'.  Care must be taken here so that we don't hurt performance
for (O_CREAT|O_TRUNC) of existing files which is the case where the fid+gen is not
changed.  As an optimization we could possibly delete the file on the mds first,
invoking the GC routines for that fid+gen and then create a new inode.  Of course
this may break semantics for some apps which assume the same inode # to be used.


11/02/09
* msl_io and rpc ION calls need to return actual size so that read() can
be short circuited  on EOF.

09/28/09
* Mds failure causes client to crash in fidc_fcoo_remove.

[1254162324:006671 msfsthr23:25431:pscrpc_deactivate_import:108] setting import 0xf3920b0 INVALID
[1254162324:006693 msfsthr23:25431:pscrpc_deactivate_import:113] Here's where failover is supposed to happen!!!
[1254162324:006727 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0x2aaab02d23e0 x43331/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006768 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0xf466f30 x43329/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006797 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0x2aaab02d1e50 x43327/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006825 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0xf45fa90 x43328/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006854 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0x2aaab414cd90 x43330/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006882 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0xf46de80 x43326/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006910 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0x2aaab414b7d0 x43325/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006939 msfsthr23:25431:pscrpc_abort_inflight:1582] req@0x2aaaac09f770 x43324/t0 c0 o25->@54321-128.182.58.80@tcp10:10 lens 192/80 ref 1 res 0 ret 2 fl Rpc:X/2/0 replyc 0 rc 0/0 to=60 :: inflight
[1254162324:006979 msfsthr23:25431:fidc_fcoo_remove:416] [assert] SPLAY_EMPTY(&o->fcoo_bmapc)

09/23/09
* Sliod has too many open files but reports success anyway to mount_slash.

* Need a method for cleaning up sliod inodes, they're sitting around in the cache dirty (and
	hence, unreclaimable).
	. use biod_lentry to place bmaps onto an list which is periodically
	scanned for bmaps which have been inactive for some time.

	. the bmaps are gathered up and placed into an rpc bound for the mds.
	the mds unbinds the bmaps from the sliod (erasing the respective
	odtable entry).

	. fcmh will remain dirty until all of its bmaps have been reclaimed.  At
	that point the fcmh file des will be closed and the fcmh will be released.

	. Note that these operations are not beared upon by client-side release
	operations.  They are purposely kept separate.

* Sliod runs out of space in filesystem and returns from an rpc early (client sees the rc -28)
	the problem is that other sliod threads are blocked on a waitq and are never woken
	up.  Need a way to deal with the failure mode.

* It would seem that generation numbering is needed in the slfidns, still not sure what
	to do about deletes or truncates.

* While running a small file / create intensive fio test, I find that most of the threads
are blocking here waiting for rpc completion.  This makes things like 'ls -al' very slow
because no threads are left to process incoming operations.
Thread 4 (Thread 0x50fa7940 (LWP 31008)):
#0  0x000000331c20a899 in pthread_cond_wait@@GLIBC_2.3.2 ()
#1  0x00000000004748a9 in psc_waitq_waitrel ()
#2  0x0000000000423d2b in bmap_oftrq_waitempty ()
#3  0x0000000000424151 in msl_bmap_tryrelease ()
#4  0x000000000042425d in msl_fbr_free ()
#5  0x0000000000424f4d in msl_bmap_fhcache_clear ()
#6  0x000000000041b62c in slash2fuse_release ()
#7  0x00002b93b5a6c7c3 in do_release () from /usr/local/lib/libfuse.so.2
#8  0x000000000040f302 in slash2fuse_listener_loop ()
#9  0x000000331c206367 in start_thread () from /lib64/libpthread.so.0
#10 0x000000331bad309d in clone () from /lib64/libc.so.6

Actually, if all of the operations performed in slash2fuse_release could be done
asynchronously then performance would be greatly improved.
- this should be safe too, as FUSE guarentees to call flush() before release().
  however, perhaps the problem is that flush().

Well, after increasing the number of fuse threads to 48 I don't see the entire set blocked
in release but I don't see good performance for 'ls -al'.

* Namespace Disconnection Problem
  The namespace must be protected from a rename operation where a parent directory
  is renamed into one of its children.  Supposedly a global rename lock is used in
  today's filesystems which locks the entire namespace and analyzes the paths to ensure
  that a rename source is not a parent of the target.  I think this is not a problem
  using directory hardlinks since the source's children may be determined via the immns
  dir hardlink.  EEB seems to think otherwise..  I think the issue is where the ".." directory
  of the destination points.  If it points to the immns then we're in trouble.

  rule: when looking up the destination name, if any component FIDs match the source parent,
    return EINVAL.  this should be handled under the hood by FUSE.

* Truncate Implementation
  Non O_TRUNC but otherwise aligned trunc operations should be fairly simple to implement.
  Here two things are required:
	 1. Zero out the bmap descriptors within the metafile.
	 2. Record the reclaimable regions so the the IONs may also reclaim that space.

  The question is, how do we deal with unaligned truncates?  We need some way to denote that
  the bmap crc is no longer valid.  Actually such a construct is probably needed in other places
  as well.  On truncate, the value of ino_lblk needs to be reset as does ino_lblk_sz.


* Fidcache Generation Numbering
	Fidcache must support generation numbers.
		. hash table code should be modified to add a cmp function.
		. ambiguous inode lookups should prefer the highest gen #

	On the fidcache generation # subject.  Implementing the FC with gen #'s is
	awkward because fuse does not provide the generation number except when it
	provides an 'fi'.  This means that the gen cannot be used for hash table lookups
	taking place on behalf of operations like: create, mkdir, open,	etc.

	Done but seeing a problem on the client when doing stress testing:
	[1233201864:695906 msfsthr9:__fidc_lookup_fg:320] [assert] fcmh_2_gen(tmp) != FID_ANY

	Not seeing the above on the server..

* fcmh_2_gen(tmp) != FID_ANY __fidc_lookup_fg:320
	Look at this assert.  I'm not convinced that fidc_lookup_load_inode()
	is useful.  It occasionally lets inodes into the cache without a proper
	generation number.  Which then causes this assert.

	unique: 94876, opcode: UNLINK (10), nodeid: 379151, insize: 65

	[1233209602:863246 msfsthr8:__fidc_lookup_inode:480]  fcmh@0x6f5a70 fcoo@(nil) fcooref(-66:-66) i+g:379151+281474976710655 s: CG lc:Free r:1 :: adding FID_ANY to cache

	[1233209602:866275 msfsthr5:__fidc_lookup_fg:320] [assert] fcmh_2_gen(tmp) != FID_ANY


	Look at removing load_inode altogether.  Instead, maybe do an extra
	ref on lookup so that proceeding operations are guarenteed to have
	their inodes cached.

- rename buffer.c -> slab.c
- ensure fidc doesn't look up beyond SYM_NLOOPS #loops
- drop privs to user _slash for mount_slash/slashd/sliod
- add some high-level aliases to the replication interface for users:

  mid-level persistence control aliases:
    $ slfctl [-R] -p file ...				# msctl -f new-repl-policy=persist
    $ slfctl [-R] -o file ...				# msctl -f new-repl-policy=onetime
    $ slfctl -B bmapspec:file ...			# msctl -f bmap-repl-policy=persist
    $ slfctl -b bmapspec:file ...			# msctl -f bmap-repl-policy=onetime

  mid-level replication request control aliases:
    $ slfs replstatus [-R] file ...			# msctl [-R] -r file -r...
    $ slfs replqueue [-R] res[,...]:bmapspec:file ...	# msctl [-R] -Q spec -Q...
    $ slfs replremove [-R] res[,...]:bmapspec:file ...	# msctl [-R] -U spec -U...

  high-level aliases:
    $ slfs replicate [-Rp] res[,...] file ...
	if (-p)
		slfctl [-R] -p file ...
	msctl [-R] -Q res,...|*[P]:file ...
    $ slfs replcancel|cancel [res,...] file ...
	if (-p)
		slfctl [-R] -o file ...
	msctl [-R] -U res,...|*[P]:file ...
    $ slfs setpersist file ...
	slfctl -p file ...
	slfctl -B *:file *:...
    $ slfs setonetime file ...
	slfctl -o file ...
	slfctl -b *:file *:...

----------------------------------------------------------------------

- slimmns does more than create the immutable namespace, and should
  be more intuitively named for formatting MDS file systems, such as
  slmkfs, slfmtfs, or slnewfs
- libsl_init() is getting an ENOMEM somewhere in slashd, maybe LNET
- rename BMAPCHMODE -> BMAP_CHRWMODE
----------------------------------------------------
- removing the persistence policy on a bmap should mds_repl_delrq()
  for that bmap
-----------------------------------------------------
- get tsuite working
- merge set_bmapreplpol and friends into a single slfattr interface
- push O_APPEND writes always to EOF
-----------------------------------------------------
- make slmctl and slictl knobs for showing listen addresses/options
- add ctl for connections

msctl/slictl/slmctl -n -s conn

connections	host		type	 #refs	status
 ===================================================================
 @PSC
   mds		adamantium	MDS	 1	online
   io0		stryker		parallel 1	offline
		wolverine	parallel 0	connecting
   io1		grapefruit	archiver 0	inactive

(not available on msctl)
 clients
		kaminari	client	 0	online

-----------------------------------------------------

- add ctl knobs for changing preferred IOS
- allow multiple preferred IOS servers
- add flag to wait/return error/crash ms when slashd goes down

- think about routing blips where MDS<->ION is not quite what a ION<->ION
  can see each, causing unnecessary replication work processing

- the BUS errors look like they are being caused in some error scenario
  in PSCRPC

- implement mknod, link, symlink
- keep replication queue in .slrepls and keep around a small pool of sl_replrq
  at any time, enough to attempt to keep all IONs involved in replication saturated
- add ctlapi for bcmp

---------------------------------------------------------

sliod import/export
- slictl -I path
    lookup path

    approaches:
    (o) link into slfidns, calculate and transmit CRCS,
	delete link from user path.
    (o) link into slfidns, calculate and transmit CRCs,
	wait for CRC failure and auto deject.
    (o) link into slfidns, flag slivers to ignore CRCs,
	always allow access.

- slictl -X path
    lookup path FID and move file to destination
    if recursive, lookup recursively

---------------------------------------------------------

network scheduling
- preferentiate users
    (o) need classes, always complete a class before moving
	to next one, files in the same class have same fairness
- link bandwidth
- aggregate small files, keep MAX inflight at all times between links
- need way to prioritize specific endpoint <-> endpoint instead of
  random to avoid scheduling slow streams over faster streams

netqueued - universal interface
- LD_PRELOAD
- intercept for recompiling
- API

tracks endpoint connections
- if new ones are made that utilize the same link, manage and
  limit and wait until bandwidth is available

------------------------------

- sstb shouldn't have an ino field; fill it out each time from fg_fid

- always cache / on mount_slash, that will save RPCs
- rename SL_PATH_PREFIX to SL_FN_NS_RESERVED_PREFIX
- authbuf RPC bulk data, use wrappers of rsx_bulk routines to
  aid this
- sprinkle some iostats on zfs, namespace changelog

zfs
- rename the zfs_init() alias, it is already a routine in ZFS
