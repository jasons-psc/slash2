09/23/09
* Sliod has too many open files but reports success anyway to mount_slash.
* Sliod runs out of space in filesystem and returns from an rpc early (client sees the rc -28)
	the problem is that other sliod threads are blocked on a waitq and are never woken
	up.  Need a way to deal with the failure mode.
* Need a method for cleaning up sliod inodes, they're sitting around in the cache dirty (and
	hence, unreclaimable).
* It would seem that generation numbering is needed in the slfidns, still not sure what
	to do about deletes or truncates.

* While running a small file / create intensive fio test, I find that most of the threads
are blocking here waiting for rpc completion.  This makes things like 'ls -al' very slow
because no threads are left to process incoming operations.
Thread 4 (Thread 0x50fa7940 (LWP 31008)):
#0  0x000000331c20a899 in pthread_cond_wait@@GLIBC_2.3.2 ()
#1  0x00000000004748a9 in psc_waitq_waitrel ()
#2  0x0000000000423d2b in bmap_oftrq_waitempty ()
#3  0x0000000000424151 in msl_bmap_tryrelease ()
#4  0x000000000042425d in msl_fbr_free ()
#5  0x0000000000424f4d in msl_bmap_fhcache_clear ()
#6  0x000000000041b62c in slash2fuse_release ()
#7  0x00002b93b5a6c7c3 in do_release () from /usr/local/lib/libfuse.so.2
#8  0x000000000040f302 in slash2fuse_listener_loop ()
#9  0x000000331c206367 in start_thread () from /lib64/libpthread.so.0
#10 0x000000331bad309d in clone () from /lib64/libc.so.6

Actually, if all of the operations performed in slash2fuse_release could be done
asynchronously then performance would be greatly improved.

Well, after increasing the number of fuse threads to 48 I don't see the entire set blocked
in release but I don't see good performance for 'ls -al'.

* Namespace Disconnection Problem
  The namespace must be protected from a rename operation where a parent directory
  is renamed into one of its children.  Supposedly a global rename lock is used in
  today's filesystems which locks the entire namespace and looks analyzes the paths to ensure
  that a rename is source is not a parent of the target.  I think this is not a problem
  using directory hardlinks since the source's children may be determined via the immns
  dir hardlink.  EEB seems to think otherwise..  I think the issue is where the ".." directory
  of the destination points.  If it points to the immns then we're in trouble.


* Truncate Implementation
  Non O_TRUNC but otherwise aligned trunc operations should be fairly simple to implement.
  Here two things are required:
	 1. Zero out the bmap descriptors within the metafile.
	 2. Record the reclaimable regions so the the IONs may also reclaim that space.

  The question is, how do we deal with unaligned truncates?  We need some way to denote that
  the bmap crc is no longer valid.  Actually such a construct is probably needed in other places
  as well.  On truncate, the value of ino_lblk needs to be reset as does ino_lblk_sz.


* Fidcache Generation Numbering
	Fidcache must support generation numbers.
		. hash table code should be modified to add a cmp function.
		. ambiguous inode lookups should prefer the highest gen #

	On the fidcache generation # subject.  Implementing the FC with gen #'s is
	awkward because fuse does not provide the generation number except when it
	provides an 'fi'.  This means that the gen cannot be used for hash table lookups
	taking place on behalf of operations like: create, mkdir, open,	etc.

	Done but seeing a problem on the client when doing stress testing:
	[1233201864:695906 msfsthr9:__fidc_lookup_fg:320] [assert] fcmh_2_gen(tmp) != FID_ANY

	Not seeing the above on the server..


* Running out of FCMH's and threads hanging in fidc_get()
	On this deadlock.. check the refcnts on the fcmh's, this may be a
		true case of exhaustion.
		- Refcnts checked out to be ok.

	Problem described and fixed in r5093

	Here's a deadlock:

Thread 10 (Thread 1199630656 (LWP 5936)):
#0  0x0000000000425cb8 in _lc_get ()
#1  0x0000000000425a4a in lc_getnb ()
#2  0x0000000000424947 in fidc_reap ()
#3  0x00000000004260b1 in fidc_get ()
#4  0x00000000004296cb in __fidc_lookup_inode ()
#5  0x0000000000404088 in slash2fuse_fidc_putget ()
#6  0x000000000040a229 in slash2fuse_create ()
#7  0x00002b264fa70f53 in fuse_reply_err () from /usr/lib/libfuse.so.2
#8  0x00000000004036ec in slash2fuse_listener_loop ()
#9  0x00002b2650094305 in start_thread () from /lib64/libpthread.so.0
#10 0x00002b265037550d in clone () from /lib64/libc.so.6
#11 0x0000000000000000 in ?? ()


	1/27/09
		Here's the stack trace of a hung server thread:

Thread 105 (Thread 1325521216 (LWP 5518)):
#0  0x00000000004371ea in _tands ()
#1  0x00000000004371c1 in spinlock ()
#2  0x000000000043715c in reqlock ()
#3  0x0000000000438a98 in _lc_put ()
#4  0x00000000004385cc in fidc_reap ()
#5  0x0000000000438cf6 in fidc_get ()
#6  0x000000000043c310 in __fidc_lookup_inode ()
#7  0x000000000042ed3f in slrmc_inode_cacheput ()
#8  0x0000000000431b8c in slrmc_create ()
#9  0x0000000000435bcb in slrmc_handler ()
#10 0x0000000000478a13 in pscrpc_server_handle_request ()
#11 0x000000000047acc2 in pscrpc_main ()
#12 0x000000000047c3d0 in pscrpcthr_begin ()
#13 0x00000000004535c6 in pscthr_begin ()
#14 0x00002b6cc53f7305 in start_thread () from /lib64/libpthread.so.0
#15 0x00002b6cc5ce750d in clone () from /lib64/libc.so.6
#16 0x0000000000000000 in ?? ()


* MDS Memory Leak
	1/28/09
	After running some large tests, it's clear that the slash mds is leaking memory badly.
	This will have to be fixed before large scale tests can resume

	mount_slash seems to be leaking too, especially on large tree traversals with unlinks.

mds.c
	mexpfcm_cfd_init()
		mexpfcm
		fidc_mds_info to f->fcmh_fcoo->fcoo_pri
			. this wasn't being freed in mexpfcm_cfd_free()


* fcmh_2_gen(tmp) != FID_ANY __fidc_lookup_fg:320
	Look at this assert.  I'm not convinced that fidc_lookup_load_inode()
	is useful.  It occasionally lets inodes into the cache without a proper
	generation number.  Which then causes this assert.

	unique: 94876, opcode: UNLINK (10), nodeid: 379151, insize: 65

	[1233209602:863246 msfsthr8:__fidc_lookup_inode:480]  fcmh@0x6f5a70 fcoo@(nil) f
cooref(-66:-66) i+g:379151+281474976710655 s: CG lc:Free r:1 :: adding FID_ANY t
o cache

	[1233209602:866275 msfsthr5:__fidc_lookup_fg:320] [assert] fcmh_2_gen(tmp) != FI
D_ANY


	Look at removing load_inode alltogether.  Instead, maybe do an extra
	ref on lookup so that proceeding operations are guaranteed to have
	their inodes cached.


- rename ios to ion
- use a sliding window to track valid cfd's and remove them from the window
  once they are CLOSE()'d

