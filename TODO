$Id$

reminders:
- be consistent with I/O software terminology
	(o) ion - an I/O node (resm)
	(o) ios - an I/O system (res)
	(o) iod - the sliod daemon
- do sl_csvc_wantfree() in all to-CLI csvcs
- ensure reentrancy of 'static' variables in functions

* Kernel build causes bmap flushq to grow considerably (in the thousands..)
* Spend some time dealing with sliod crash / restart

-----------------------------------------------------------------------
* Bmpce Write
There may be some advantage to maintaining a seq or numeric window id for
each bmpce being processed for write.  Right before the bmpce is put on the
wire, the current window is closed and proceeding biorq's using that bmpce
must wait for the next window (and completion of the pending RPC).  This
is to prevent the same bmpce from being on the wire twice.  It should also
augment the coalescer by allowing for later writes to be included.  The
main change here is that biorq's could have their bmpces complete in totally
different rpc's or even rpcsets.  Essentially the biorq doesn't complete
until the window id for each bmpce is <= than the last processed bmpce window.
-----------------------------------------------------------------------
* Restore Issues:
1) need to split 64-bit inode space into upper and lower segments.  Each mds in the system will be given a start # and range for use in the upper segment.  The upper value will be incremented on restore (when the journal does not agree with the cursor) or when all id's in the lower segment have been exhausted

2) How does sliod and mds deal with the LWM in post restore scenarios?  Atm, the sliod doesn't like when the LWM decreases.
3) How do we deal with CRC's and size updates which were lost on mds restore
4) distillation XID - how do we cope with this when the journal has been reformatted

-----------------------------------------------------------------------
* Pending I/O Issues:
	. Sliod threads may be get tied up servicing requests from a
	failed client or client connection.  If the socket doesn't immediately
	fail, the rpc's need to time out.  This can cause requests from other
	clients to accumulate on the sliod, these requests could time out also.
	Worse yet, the leases for the blocked clients may expire causing
	more problems.  Unfortunately, all of this is exacerbated by the
	lack of flow control and aggressive read ahead.

-----------------------------------------------------------------------
* Revisit readdir.  Make sure we're not making unnecessary round trips for
bulks when the directories are small.

-----------------------------------------------------------------------

* Read-ahead work is needed.. Better detection for large I/O's and fast
connections vs. small file and latency sensitive workloads.  The current
approach favors lower latency at the cost of issuing more requests.  (ie
every RA request is 32k).  For 2 large files, this causes ~500 requests
to be queued to a sliod - which is a lot.

* Need to look into increasing the number of ric threads and slabs on the
sliod.

pauln (04/29/11)
-----------------------------------------------------------------------

* rpc timeouts should correspond to bmap lease timeouts.  In addition,
	threads blocked on RA bmpces, or another thread's bmpce fetch
	should timeout and not block indefinitely.  This does not
	completely address the issue from bug 132 but may be a useful
	asset.

	expired_request() should take lease timeout into account somehow
pauln (04/22/11)

-----------------------------------------------------------------------


* bmap flush needs to be reworked so that several threads can be
	assigned to flushing bmaps.  The current model is relatively
	slow because the bmap flush thread undertakes too much work.
	This means that subsequent requests tend to wait before being
	pushed out.  When dealing with force-expired requests a
	slow down results

pauln (04/19/2011)

-----------------------------------------------------------------------

* In bmap_flush_reap_rpcs() some work should be done to prove that
  time is not being needlessly wasted in pscrpc_set_finalize().  The
  speed in which pscrpc_nbreqset_reap(pndgReqs) is called determines
  how fast we can unblock flush-on-close calls.

* Bmap flush should have a call which checks the lease validity of a
       bmap.  If the lease has expired, then the I/O must be dropped and
       EIO returned to the caller.

pauln (03/31/2011)

-----------------------------------------------------------------------
- account metadata overhead in st_blocks
- there should be a slictl/msctl cmd to see other/aggr replicas:

	(o) msctl -s repl-disk-usage:file[,...]

TRUNCATE

Truncate is more of a problem because the fid+gen remains, thus making async IOS
truncate operations problematic because new writes may come from the client before
the truncate is processed by the IOS (whoops!).  Client to IOS truncate ops are
also unfavorable because replica maintenance may need to be done, the client may have
the replica table but should he be the one directing the truncates to all IOS's?
I'm inclined to say 'no'.  Care must be taken here so that we don't hurt performance
for (O_CREAT|O_TRUNC) of existing files which is the case where the fid+gen is not
changed.  As an optimization we could possibly delete the file on the mds first,
invoking the GC routines for that fid+gen and then create a new inode.  Of course
this may break semantics for some apps which assume the same inode # to be used.

* Truncate Implementation
  Non O_TRUNC but otherwise aligned trunc operations should be fairly simple to implement.
  Here two things are required:
	 1. Record the reclaimable regions as BREPL_GARBAGE so the the
	    IONs may reclaim the space.
	 2. When all IONs are known to be clear, zero out the bmap
	    descriptors within the metafile: when an notification update
	    from an ION is received, if all states are INVALID, ptrunc
	    the metafile.

  The question is, how do we deal with unaligned truncates?  We need
  some way to denote that the bmap crc for the affected sliver is no
  longer valid.  Actually such a construct is probably needed in other
  places as well.  On truncate, the value of ino_lblk needs to be reset
  as does ino_lblk_sz.

-----------------------------------------------------------------------
1/26/11
* ./fio.pthreads  -i MTWT_SZV.ves -- This test is causing unnecessary RBW requests.

1/14/10
* Deal with problems surrounding full odtable. ATM odtable put errors are not dealt with properly
leading to problems later in cfdfree where the bmap refcnt is wrong.

11/23/09
* mds_bmap_ion_assign fails when the caller doesn't specify a PIOS.

11/02/09
* msl_io and rpc ION calls need to return actual size so that read() can
be short circuited on EOF.

09/23/09
* Sliod has too many open files but reports success anyway to mount_slash.

* Sliod runs out of space in filesystem and returns from an rpc early (client sees the rc -28)
	the problem is that other sliod threads are blocked on a waitq and are never woken
	up.  Need a way to deal with the failure mode.

* While running a small file / create intensive fio test, I find that most of the threads
are blocking here waiting for rpc completion.  This makes things like 'ls -al' very slow
because no threads are left to process incoming operations.
Thread 4 (Thread 0x50fa7940 (LWP 31008)):
#0  0x000000331c20a899 in pthread_cond_wait@@GLIBC_2.3.2 ()
#1  0x00000000004748a9 in psc_waitq_waitrel ()
#2  0x0000000000423d2b in bmap_oftrq_waitempty ()
#3  0x0000000000424151 in msl_bmap_tryrelease ()
#4  0x000000000042425d in msl_fbr_free ()
#5  0x0000000000424f4d in msl_bmap_fhcache_clear ()
#6  0x000000000041b62c in slash2fuse_release ()
#7  0x00002b93b5a6c7c3 in do_release () from /usr/local/lib/libfuse.so.2
#8  0x000000000040f302 in slash2fuse_listener_loop ()
#9  0x000000331c206367 in start_thread () from /lib64/libpthread.so.0
#10 0x000000331bad309d in clone () from /lib64/libc.so.6

Actually, if all of the operations performed in slash2fuse_release could be done
asynchronously then performance would be greatly improved.
- this should be safe too, as FUSE guarentees to call flush() before release().
  however, perhaps the problem is that flush().

Well, after increasing the number of fuse threads to 48 I don't see the entire set blocked
in release but I don't see good performance for 'ls -al'.

* Namespace Disconnection Problem
  The namespace must be protected from a rename operation where a parent directory
  is renamed into one of its children.  Supposedly a global rename lock is used in
  today's filesystems which locks the entire namespace and analyzes the paths to ensure
  that a rename source is not a parent of the target.  I think this is not a problem
  using directory hardlinks since the source's children may be determined via the immns
  dir hardlink.  EEB seems to think otherwise..  I think the issue is where the ".." directory
  of the destination points.  If it points to the immns then we're in trouble.

  rule: when looking up the destination name, if any component FIDs match the source parent,
    return EINVAL.  this should be handled under the hood by FUSE.

* Fidcache Generation Numbering
	Fidcache must support generation numbers.
		. hash table code should be modified to add a cmp function.
		. ambiguous inode lookups should prefer the highest gen #

	On the fidcache generation # subject.  Implementing the FC with gen #'s is
	awkward because fuse does not provide the generation number except when it
	provides an 'fi'.  This means that the gen cannot be used for hash table lookups
	taking place on behalf of operations like: create, mkdir, open,	etc.

	Done but seeing a problem on the client when doing stress testing:
	[1233201864:695906 msfsthr9:__fidc_lookup_fg:320] [assert] fcmh_2_gen(tmp) != FID_ANY

	Not seeing the above on the server..

- add some high-level aliases to the replication interface for users:

  mid-level persistence control aliases:
    $ slfctl [-R] -p file ...				# msctl -f new-repl-policy=persist
    $ slfctl [-R] -o file ...				# msctl -f new-repl-policy=onetime
    $ slfctl -B bmapspec:file ...			# msctl -f bmap-repl-policy=persist
    $ slfctl -b bmapspec:file ...			# msctl -f bmap-repl-policy=onetime

  mid-level replication request control aliases:
    $ slfs replstatus [-R] file ...			# msctl [-R] -r file -r...
    $ slfs replqueue [-R] res[,...]:bmapspec:file ...	# msctl [-R] -Q spec -Q...
    $ slfs replremove [-R] res[,...]:bmapspec:file ...	# msctl [-R] -U spec -U...

  high-level aliases:
    $ slfs replicate [-Rp] res[,...] file ...
	if (-p)
		slfctl [-R] -p file ...
	msctl [-R] -Q res,...|*[P]:file ...
    $ slfs replcancel|cancel [res,...] file ...
	if (-p)
		slfctl [-R] -o file ...
	msctl [-R] -U res,...|*[P]:file ...
    $ slfs setpersist file ...
	slfctl -p file ...
	slfctl -B *:file *:...
    $ slfs setonetime file ...
	slfctl -o file ...
	slfctl -b *:file *:...

------------------------------------------------------------------------

- slimmns does more than create the immutable namespace, and should
  be more intuitively named for formatting MDS file systems, such as
  slmkfs, slfmtfs, or slnewfs
- libsl_init() is getting an ENOMEM somewhere in slashd, maybe LNET
------------------------------------------------------------------------
- removing the persistence policy on a bmap should mds_repl_delrq()
  for that bmap
- merge set_bmapreplpol and friends into a single slfattr interface
- push O_APPEND writes always to EOF instead of the the client-sent offset

- add ctl knobs for changing preferred IOS
- allow multiple preferred IOS servers

- hold a maximum # entries in mem from .slmd/upsch at any given time?
- merge uswk into fmi and kill uswi struct

- add msctl -s bmpc

-------------------------------------------------------------------------

sliod import
- slictl import path
    lookup path

    approaches:
    (o) link into slfidns, calculate and transmit CRCS,
	delete link from user path.
    (o) link into slfidns, calculate and transmit CRCs,
	wait for CRC failure and auto deject.
    (o) link into slfidns, flag slivers to ignore CRCs,
	always allow access.

sliod export
- slictl export path
    lookup path FID and move file to destination
    if recursive, lookup recursively

---------------------------------------------------------

network scheduling
- need slash.conf rules to specify link bandwidth
- preferentiate users/policies
    (o) need classes, always complete a class before moving
	to next one, files in the same class have same fairness
- add network topology descriptions to slash.conf

netsched/libnetsch - universal interface
- LD_PRELOAD?
- intercept for recompiling
- API
- needs to communicate with other nodes about traffic situation

tracks endpoint connections
- if new ones are made that utilize the same link, manage and
  limit and wait until bandwidth is available

- per-site network upscheduling is not enough; it has to be per link to
  maintain network link saturation effectively

- must consider multiple interfaces

MDS must do this for scheduling traffic between sliods

------------------------------

- add SSL transport for anytime cleartext is untrusted
- convert authbuf to pki, put hash back inside bdbuf fdbuf
  reasoning: if authbuf succeeded, we trust anything, so there is no
  point in having extra provisions such as src ION

  consequence: kill authbuf
- sprinkle some iostats on zfs, namespace changelog
- add journal I/O test mode to slashd
- tie zfslog to psclog

---------------

- failure of connections
    (o) have mount_slash provide the option of waiting or immediately
	returning EIO
    (o) write messages to stderr of the process trying to do I/O when
	the connections are down

- add throttling and ping channel control to slash

utime
    (o)	track how long sliod has held the I/O and send the difference to
	the MDS so the MDS can more accurately estimate when the I/O
	took place

tree
- rename include/buffer.h and share/buffer.c as sliod/slab.h sliod/slab.c
- move inode.h into slashd
- rename the zfs_init() alias, it is already a routine in ZFS
- rename slconfig.h to slcfg.h to disambiguate slco prefix

API rename
- rename FCMH_CREATE to POPULATE?
- mdsio_fid_t -> mdsio_inum_t
- mdsio_data -> mdsio_fh_t

- upsch items are not getting removed on completion
- ensure PINGs only happen every 30 seconds
- GETATTR should never return nlinks=0
- replace FCMH_CTOR_FAILED with fmi_ctor_rc
- slimmns -W should instead should rename the top-level its contents in
  the (forked) background after returning quickly to admin
  . not sure about the removal step.  Why not make use of a UUID that's
  generated by the MDS and provided as a parameter to the sliod slimmns
  operation?  So we'd have something like:  /s2io/{UUID}/.slimmns
  The UUID could be just a timestamp too.  This would allow admins to
  remove old backing directories at their convenience while not
  compromising data integrity.

- change upsched to do async callbacks
- does upsched get hung up by huge recursive repl reqs ?

- if the target ptrunc offset falls inside a bmap, do more stuff:
    (o) mark the CRC for this bmap as unknown (we don't do this)

- use pfl_memchk instead of null inode structures for memcmp
- SRMT_GETBMAPMINSEQ is not handled by slashd
- CRCs are currently ignored in the I/O path
- need a way to view a directory's newbmap_repl_policy
    (o) maybe in msctl -r view, so we can see which MDS a dir is
	centralized with
- need a general mechanism to pass data between msctl/slictl/slmctl
  so we get all the functionality everywhere and don't have to copy huge
  chunks of code
- slmctl -s peertraffic -s replrqs -s diskusage
- initialize new file repl table from parent dir to help with
  persistence policies
	- or just tell users to msctl -R everytime...
- ensure all system errno values in rpc msgs are standardized
- convert CONF_LOCK to a rwlock
- we can't hold fcmh in memory at all times just because PTRUNC has to
  be resolved.  have to store in inode and release fcmh.  we pass the
  fid to the ptrunc worker and when it processes it loads the fcmh.
- have slashd umount /zfs-kstat on teardown
- allow override of /zfs-kstat for running multiple instances of slashd/zfs-fuse
- disable RENAME and other ops are files in SL_RPATH_META_DIR (e.g. mv .slfidns .blah)
- clean up metadata (and replica garbage) for any files clobbered by RENAME, LINK
- add a generic SRMT_BMAPCTL that bunches up ops such as WAKE, RELEASE,
  DIO, etc.
- do full truncate and unlink do the right things while ptrunc is resolving?
- add SSL transport which uses keys and can therefore disable authbuf

- write a ptrunc tester: truncate(1)
- for -s connections, we arguably do not need to show members of the
  same resource we are part of since we will never connect to them
- patch fuse.ko since fuse_notify_entry_inval() causes segfault
- add zfs SPA version to slashd ctlparam
   - is this needed?  /zfs-kstat
- use umount -l if it is supported at teardown
- client needs to track when MDS goes down and recheck pinned ptrunc
  bmaps for resolvement
- on MDS resm failure inside msl, clear a bit on all fcmh's pinned by ptrunc
  whenever we check this flag, if the bit is not set, issue an RPC so
  that we get registered with the MDS to be notified when ptrunc resolves
- upsched only needs to be spawned for our own site
  - need way to specify in slash.conf other sites without MDS which MDS
    should be responsible for replications to resources at that site

      global pref_mds=md@PSC

- pjd tests used to fail due to inability to send FUSE updates to its
  cache after UNLINK, RENAME operations?

	link/00.t	18-19, 22, 44-45, 48
	rename/00.t	49, 53, 57, 61
	unlink/00.t	17, 22, 53

========================================================= KNOWN CAVEATS
- sljournal constraint on small file names (1023-byte symlink must fit
  in SLJ_NAMES_MAX):

- FUSE bug: during LOOKUP, there is no check for invalidated dirs to
  re-force lookups for child nodes.

  if this gets resolves, we should remove the code that explicitly
  invalidates FUSE child dentries of a directory when handling CHMOD

- move namespace in zfs into a subdir so we dont have to do any
  strcmp(fn, ".slmd") -> EPERM tricks

- parse LNET_NETWORKS format for `lnets' variable and assign lnetname to
  addresses that resolve from the interface in the pair

- make sure replrq over garbage does the right thing in sliod backfs (zeroing)
- mds: do not allow repl changes while IN_PTRUNC
- should replay crcupdate set ion to VALID ?
- support multi addresses for resms
- for long running I/O patterns by processes that issue no other syscalls,
  do fcmh's timeout and reload from MDS sst_size/gen values?
    - need fcmh_get() in mslfsop_read()
- try locally caching st_blocks in msl
- msl with sst_size local caching should still take higher values from MDS
  in cases of direct I/O
- use uint32_t for nanosecond atime/mtime/ctime in znode_phys to save space
- remote separate sl2 mtime/atime in slashd
- eradicate getrqstatus()
- keep testing replication
- 'slmctl stop' should completely wait for all ops to prevent relying on journal
- upsch will not scale without multiwait waker arg
- ensure user mounting works
- add provisions to ensure journal disk doesnt overwrite something special
- import
  - sliod links/symlinks
  - MDS immutable/readonly
